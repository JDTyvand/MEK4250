// This code conforms with the UFC specification version 1.6.0
// and was automatically generated by FFC version 1.6.0.
// 
// This code was generated with the following parameters:
// 
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   name:                           'ffc'
//   no-evaluate_basis_derivatives:  True
//   optimize:                       False
//   precision:                      15
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   restrict_keyword:               ''
//   split:                          False

#ifndef __FFC_FORM_7E9988AB285A1EA11A6C9984A0D4284B654E659D_H
#define __FFC_FORM_7E9988AB285A1EA11A6C9984A0D4284B654E659D_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 15; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[16];
    for (unsigned int r = 0; r < 16; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 30;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 26:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 27:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 28:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 29:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 30; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 30; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[32];
    for (unsigned int r = 0; r < 32; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 30; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 15:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 21:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 22:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 23:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 24:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 25:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 26:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 27:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 28:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 29:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[20] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[21] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[22] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[23] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[24] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[25] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[26] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[27] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[28] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[29] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[15];
    vertex_values[3] = dof_values[16];
    vertex_values[5] = dof_values[17];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 10;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666667, 0.0782460796435951, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333334, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731327, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 10; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 10; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 10; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 40;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 26:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 27:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 28:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 29:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 30:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666667, 0.0782460796435951, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 31:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 32:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333334, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 33:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731327, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 34:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 35:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 36:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 37:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 38:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 39:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 40; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 40; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[48];
    for (unsigned int r = 0; r < 48; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 40; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 15:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 21:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 22:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 23:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 24:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 25:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 26:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 27:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 28:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 29:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 30:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 31:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 32:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 33:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 34:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 35:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 36:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 37:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 38:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 39:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[20] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[21] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[22] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[23] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[24] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[25] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[26] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[27] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[28] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[29] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[30] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[31] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[32] = vals[2];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[33] = vals[2];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[34] = vals[2];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[35] = vals[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[36] = vals[2];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[37] = vals[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[38] = vals[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[39] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[15];
    vertex_values[4] = dof_values[16];
    vertex_values[7] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[30];
    vertex_values[5] = dof_values[31];
    vertex_values[8] = dof_values[32];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_1();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + 3*num_global_entities[1] + 3*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 5;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 3;
        break;
      }
    case 2:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_1: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 2*num_global_entities[0] + 6*num_global_entities[1] + 6*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 30;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 10;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 6;
        break;
      }
    case 2:
      {
        return 6;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[15] = offset + c.entity_indices[0][0];
    dofs[16] = offset + c.entity_indices[0][1];
    dofs[17] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset + 3*c.entity_indices[1][0];
    dofs[19] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[20] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[21] = offset + 3*c.entity_indices[1][1];
    dofs[22] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[23] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[24] = offset + 3*c.entity_indices[1][2];
    dofs[25] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[26] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[27] = offset + 3*c.entity_indices[2][0];
    dofs[28] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[29] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 16;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 19;
      dofs[9] = 20;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 15;
      dofs[6] = 17;
      dofs[7] = 21;
      dofs[8] = 22;
      dofs[9] = 23;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
      dofs[5] = 15;
      dofs[6] = 16;
      dofs[7] = 24;
      dofs[8] = 25;
      dofs[9] = 26;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 15;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 16;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 17;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
        dofs[3] = 18;
        dofs[4] = 19;
        dofs[5] = 20;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
        dofs[3] = 21;
        dofs[4] = 22;
        dofs[5] = 23;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
        dofs[3] = 24;
        dofs[4] = 25;
        dofs[5] = 26;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
      dofs[3] = 27;
      dofs[4] = 28;
      dofs[5] = 29;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[30] = vertex_coordinates[0];
    dof_coordinates[31] = vertex_coordinates[1];
    dof_coordinates[32] = vertex_coordinates[2];
    dof_coordinates[33] = vertex_coordinates[3];
    dof_coordinates[34] = vertex_coordinates[4];
    dof_coordinates[35] = vertex_coordinates[5];
    dof_coordinates[36] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[37] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[38] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[39] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[40] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[41] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[42] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[43] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[44] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[45] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[46] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[47] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[48] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[49] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[50] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[51] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[52] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[53] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[54] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[55] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[56] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[57] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[58] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[59] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_2: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + 2*num_global_entities[1] + num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 10;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 4;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[7] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[8] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[9] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[10] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[11] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[12] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[13] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[14] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[15] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[16] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[17] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[18] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[19] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[0] + 8*num_global_entities[1] + 7*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 40;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 14;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 8;
        break;
      }
    case 2:
      {
        return 7;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[15] = offset + c.entity_indices[0][0];
    dofs[16] = offset + c.entity_indices[0][1];
    dofs[17] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset + 3*c.entity_indices[1][0];
    dofs[19] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[20] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[21] = offset + 3*c.entity_indices[1][1];
    dofs[22] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[23] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[24] = offset + 3*c.entity_indices[1][2];
    dofs[25] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[26] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[27] = offset + 3*c.entity_indices[2][0];
    dofs[28] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[29] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[30] = offset + c.entity_indices[0][0];
    dofs[31] = offset + c.entity_indices[0][1];
    dofs[32] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[33] = offset + 2*c.entity_indices[1][0];
    dofs[34] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[35] = offset + 2*c.entity_indices[1][1];
    dofs[36] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[37] = offset + 2*c.entity_indices[1][2];
    dofs[38] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[39] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 16;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 19;
      dofs[9] = 20;
      dofs[10] = 31;
      dofs[11] = 32;
      dofs[12] = 33;
      dofs[13] = 34;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 15;
      dofs[6] = 17;
      dofs[7] = 21;
      dofs[8] = 22;
      dofs[9] = 23;
      dofs[10] = 30;
      dofs[11] = 32;
      dofs[12] = 35;
      dofs[13] = 36;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
      dofs[5] = 15;
      dofs[6] = 16;
      dofs[7] = 24;
      dofs[8] = 25;
      dofs[9] = 26;
      dofs[10] = 30;
      dofs[11] = 31;
      dofs[12] = 37;
      dofs[13] = 38;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 15;
        dofs[2] = 30;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 16;
        dofs[2] = 31;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 17;
        dofs[2] = 32;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
        dofs[3] = 18;
        dofs[4] = 19;
        dofs[5] = 20;
        dofs[6] = 33;
        dofs[7] = 34;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
        dofs[3] = 21;
        dofs[4] = 22;
        dofs[5] = 23;
        dofs[6] = 35;
        dofs[7] = 36;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
        dofs[3] = 24;
        dofs[4] = 25;
        dofs[5] = 26;
        dofs[6] = 37;
        dofs[7] = 38;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
      dofs[3] = 27;
      dofs[4] = 28;
      dofs[5] = 29;
      dofs[6] = 39;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[30] = vertex_coordinates[0];
    dof_coordinates[31] = vertex_coordinates[1];
    dof_coordinates[32] = vertex_coordinates[2];
    dof_coordinates[33] = vertex_coordinates[3];
    dof_coordinates[34] = vertex_coordinates[4];
    dof_coordinates[35] = vertex_coordinates[5];
    dof_coordinates[36] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[37] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[38] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[39] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[40] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[41] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[42] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[43] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[44] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[45] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[46] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[47] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[48] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[49] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[50] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[51] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[52] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[53] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[54] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[55] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[56] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[57] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[58] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[59] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[60] = vertex_coordinates[0];
    dof_coordinates[61] = vertex_coordinates[1];
    dof_coordinates[62] = vertex_coordinates[2];
    dof_coordinates[63] = vertex_coordinates[3];
    dof_coordinates[64] = vertex_coordinates[4];
    dof_coordinates[65] = vertex_coordinates[5];
    dof_coordinates[66] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[67] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[68] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[69] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[70] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[71] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[72] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[73] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[74] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[75] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[76] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[77] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[78] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[79] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_1();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_cell_integral_0_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_cell_integral_0_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    32
    // Number of operations (multiply-add pairs) for tensor contraction: 3303
    // Total number of operations (multiply-add pairs):                  3338
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*K[0]*K[0]*(1.0);
    const double G0_0_1 = det*K[0]*K[2]*(1.0);
    const double G0_1_0 = det*K[2]*K[0]*(1.0);
    const double G0_1_1 = det*K[2]*K[2]*(1.0);
    const double G1_0_0 = det*K[0]*K[0]*(1.0);
    const double G1_0_1 = det*K[0]*K[2]*(1.0);
    const double G1_1_0 = det*K[2]*K[0]*(1.0);
    const double G1_1_1 = det*K[2]*K[2]*(1.0);
    const double G2_0_0 = det*K[1]*K[1]*(1.0);
    const double G2_0_1 = det*K[1]*K[3]*(1.0);
    const double G2_1_0 = det*K[3]*K[1]*(1.0);
    const double G2_1_1 = det*K[3]*K[3]*(1.0);
    const double G3_0_0 = det*K[1]*K[1]*(1.0);
    const double G3_0_1 = det*K[1]*K[3]*(1.0);
    const double G3_1_0 = det*K[3]*K[1]*(1.0);
    const double G3_1_1 = det*K[3]*K[3]*(1.0);
    const double G4_0 = det*K[0]*(1.0);
    const double G4_1 = det*K[2]*(1.0);
    const double G5_0 = det*K[1]*(1.0);
    const double G5_1 = det*K[3]*(1.0);
    const double G6_ = det;
    const double G7_0 = det*K[0]*(1.0);
    const double G7_1 = det*K[2]*(1.0);
    const double G8_0 = det*K[1]*(1.0);
    const double G8_1 = det*K[3]*(1.0);
    
    // Compute element tensor
    A[0] = 0.373015873015873*G0_0_0 + 0.373015873015873*G0_0_1 + 0.373015873015873*G0_1_0 + 0.373015873015873*G0_1_1 + 0.373015873015873*G2_0_0 + 0.373015873015873*G2_0_1 + 0.373015873015873*G2_1_0 + 0.373015873015873*G2_1_1;
    A[1] = 0.0566137566137566*G0_0_0 + 0.0566137566137555*G0_1_0 + 0.0566137566137566*G2_0_0 + 0.0566137566137555*G2_1_0;
    A[2] = 0.0566137566137561*G0_0_1 + 0.0566137566137558*G0_1_1 + 0.0566137566137561*G2_0_1 + 0.0566137566137558*G2_1_1;
    A[3] = 0.0423280423280401*G0_0_0 + 0.0423280423280397*G0_0_1 + 0.0423280423280384*G0_1_0 + 0.0423280423280365*G0_1_1 + 0.0423280423280401*G2_0_0 + 0.0423280423280397*G2_0_1 + 0.0423280423280384*G2_1_0 + 0.0423280423280365*G2_1_1;
    A[4] = 0.0423280423280398*G0_0_0 + 0.0423280423280411*G0_0_1 + 0.042328042328041*G0_1_0 + 0.0423280423280429*G0_1_1 + 0.0423280423280398*G2_0_0 + 0.0423280423280411*G2_0_1 + 0.042328042328041*G2_1_0 + 0.0423280423280429*G2_1_1;
    A[5] = 0.0423280423280425*G0_0_0 + 0.0423280423280415*G0_0_1 + 0.042328042328041*G0_1_0 + 0.0423280423280402*G0_1_1 + 0.0423280423280425*G2_0_0 + 0.0423280423280415*G2_0_1 + 0.042328042328041*G2_1_0 + 0.0423280423280402*G2_1_1;
    A[6] = 0.126984126984129*G0_0_0 - 0.65185185185185*G0_0_1 + 0.126984126984129*G0_1_0 - 0.65185185185185*G0_1_1 + 0.126984126984129*G2_0_0 - 0.65185185185185*G2_0_1 + 0.126984126984129*G2_1_0 - 0.65185185185185*G2_1_1;
    A[7] = 0.0423280423280408*G0_0_0 + 0.467724867724864*G0_0_1 + 0.0423280423280424*G0_1_0 + 0.467724867724864*G0_1_1 + 0.0423280423280408*G2_0_0 + 0.467724867724864*G2_0_1 + 0.0423280423280424*G2_1_0 + 0.467724867724864*G2_1_1;
    A[8] = -0.0423280423280424*G0_0_0 - 0.245502645502644*G0_0_1 - 0.042328042328041*G0_1_0 - 0.245502645502644*G0_1_1 - 0.0423280423280424*G2_0_0 - 0.245502645502644*G2_0_1 - 0.042328042328041*G2_1_0 - 0.245502645502644*G2_1_1;
    A[9] = -0.651851851851853*G0_0_0 + 0.126984126984128*G0_0_1 - 0.651851851851852*G0_1_0 + 0.126984126984128*G0_1_1 - 0.651851851851853*G2_0_0 + 0.126984126984128*G2_0_1 - 0.651851851851852*G2_1_0 + 0.126984126984128*G2_1_1;
    A[10] = 0.467724867724868*G0_0_0 + 0.0423280423280411*G0_0_1 + 0.467724867724867*G0_1_0 + 0.0423280423280401*G0_1_1 + 0.467724867724868*G2_0_0 + 0.0423280423280411*G2_0_1 + 0.467724867724867*G2_1_0 + 0.0423280423280401*G2_1_1;
    A[11] = -0.245502645502645*G0_0_0 - 0.0423280423280423*G0_0_1 - 0.245502645502643*G0_1_0 - 0.042328042328039*G0_1_1 - 0.245502645502645*G2_0_0 - 0.0423280423280423*G2_0_1 - 0.245502645502643*G2_1_0 - 0.042328042328039*G2_1_1;
    A[12] = -0.0846560846560892*G0_0_0 - 0.0846560846560885*G0_0_1 - 0.0846560846560893*G0_1_0 - 0.0846560846560863*G0_1_1 - 0.0846560846560892*G2_0_0 - 0.0846560846560885*G2_0_1 - 0.0846560846560893*G2_1_0 - 0.0846560846560863*G2_1_1;
    A[13] = -0.0846560846560791*G0_0_0 - 0.0846560846560799*G0_0_1 - 0.0846560846560775*G0_1_0 - 0.0846560846560807*G0_1_1 - 0.0846560846560791*G2_0_0 - 0.0846560846560799*G2_0_1 - 0.0846560846560775*G2_1_0 - 0.0846560846560807*G2_1_1;
    A[14] = -0.0846560846560807*G0_0_0 - 0.0846560846560803*G0_0_1 - 0.0846560846560835*G0_1_0 - 0.0846560846560813*G0_1_1 - 0.0846560846560807*G2_0_0 - 0.0846560846560803*G2_0_1 - 0.0846560846560835*G2_1_0 - 0.0846560846560813*G2_1_1;
    A[15] = 0.0;
    A[16] = 0.0;
    A[17] = 0.0;
    A[18] = 0.0;
    A[19] = 0.0;
    A[20] = 0.0;
    A[21] = 0.0;
    A[22] = 0.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.0;
    A[28] = 0.0;
    A[29] = 0.0;
    A[30] = -0.042063492063492*G4_0 - 0.042063492063492*G4_1;
    A[31] = 0.0;
    A[32] = 0.0;
    A[33] = 0.00892857142857105*G4_0 + 0.00892857142857096*G4_1;
    A[34] = 0.00892857142857125*G4_0 + 0.00892857142857122*G4_1;
    A[35] = -0.0267857142857143*G4_0 - 0.0267857142857143*G4_1;
    A[36] = 0.00892857142857158*G4_0 + 0.00892857142857128*G4_1;
    A[37] = -0.0267857142857144*G4_0 - 0.0267857142857142*G4_1;
    A[38] = 0.00892857142857149*G4_0 + 0.00892857142857129*G4_1;
    A[39] = -0.017857142857143*G4_0 - 0.0178571428571434*G4_1;
    A[40] = 0.0566137566137566*G0_0_0 + 0.0566137566137555*G0_0_1 + 0.0566137566137566*G2_0_0 + 0.0566137566137555*G2_0_1;
    A[41] = 0.37301587301587*G0_0_0 + 0.37301587301587*G2_0_0;
    A[42] = -0.056613756613756*G0_0_1 - 0.056613756613756*G2_0_1;
    A[43] = 0.126984126984125*G0_0_0 + 0.778835978835973*G0_0_1 + 0.126984126984125*G2_0_0 + 0.778835978835973*G2_0_1;
    A[44] = 0.0423280423280426*G0_0_0 - 0.425396825396823*G0_0_1 + 0.0423280423280426*G2_0_0 - 0.425396825396823*G2_0_1;
    A[45] = -0.0423280423280421*G0_0_0 + 0.203174603174601*G0_0_1 - 0.0423280423280421*G2_0_0 + 0.203174603174601*G2_0_1;
    A[46] = 0.0423280423280416*G0_0_0 + 0.0423280423280416*G2_0_0;
    A[47] = 0.0423280423280419*G0_0_0 + 0.0423280423280419*G2_0_0;
    A[48] = 0.0423280423280421*G0_0_0 + 0.0423280423280421*G2_0_0;
    A[49] = -0.245502645502643*G0_0_0 - 0.203174603174602*G0_0_1 - 0.245502645502643*G2_0_0 - 0.203174603174602*G2_0_1;
    A[50] = 0.467724867724862*G0_0_0 + 0.425396825396821*G0_0_1 + 0.467724867724862*G2_0_0 + 0.425396825396821*G2_0_1;
    A[51] = -0.651851851851845*G0_0_0 - 0.778835978835972*G0_0_1 - 0.651851851851845*G2_0_0 - 0.778835978835972*G2_0_1;
    A[52] = -0.0846560846560834*G0_0_0 - 0.0846560846560834*G2_0_0;
    A[53] = -0.0846560846560834*G0_0_0 - 0.0846560846560834*G2_0_0;
    A[54] = -0.0846560846560845*G0_0_0 - 0.0846560846560845*G2_0_0;
    A[55] = 0.0;
    A[56] = 0.0;
    A[57] = 0.0;
    A[58] = 0.0;
    A[59] = 0.0;
    A[60] = 0.0;
    A[61] = 0.0;
    A[62] = 0.0;
    A[63] = 0.0;
    A[64] = 0.0;
    A[65] = 0.0;
    A[66] = 0.0;
    A[67] = 0.0;
    A[68] = 0.0;
    A[69] = 0.0;
    A[70] = 0.0;
    A[71] = 0.0420634920634918*G4_0;
    A[72] = 0.0;
    A[73] = 0.026785714285714*G4_0;
    A[74] = -0.00892857142857135*G4_0;
    A[75] = -0.00892857142857137*G4_0;
    A[76] = -0.00892857142857136*G4_0;
    A[77] = -0.00892857142857128*G4_0;
    A[78] = 0.026785714285714*G4_0;
    A[79] = 0.0178571428571429*G4_0;
    A[80] = 0.0566137566137562*G0_1_0 + 0.0566137566137558*G0_1_1 + 0.0566137566137562*G2_1_0 + 0.0566137566137558*G2_1_1;
    A[81] = -0.056613756613756*G0_1_0 - 0.056613756613756*G2_1_0;
    A[82] = 0.373015873015869*G0_1_1 + 0.373015873015869*G2_1_1;
    A[83] = 0.203174603174603*G0_1_0 - 0.0423280423280404*G0_1_1 + 0.203174603174603*G2_1_0 - 0.0423280423280404*G2_1_1;
    A[84] = -0.425396825396824*G0_1_0 + 0.0423280423280395*G0_1_1 - 0.425396825396824*G2_1_0 + 0.0423280423280395*G2_1_1;
    A[85] = 0.778835978835974*G0_1_0 + 0.126984126984127*G0_1_1 + 0.778835978835974*G2_1_0 + 0.126984126984127*G2_1_1;
    A[86] = -0.203174603174603*G0_1_0 - 0.245502645502643*G0_1_1 - 0.203174603174603*G2_1_0 - 0.245502645502643*G2_1_1;
    A[87] = 0.425396825396824*G0_1_0 + 0.467724867724864*G0_1_1 + 0.425396825396824*G2_1_0 + 0.467724867724864*G2_1_1;
    A[88] = -0.778835978835974*G0_1_0 - 0.651851851851846*G0_1_1 - 0.778835978835974*G2_1_0 - 0.651851851851846*G2_1_1;
    A[89] = 0.0423280423280405*G0_1_1 + 0.0423280423280405*G2_1_1;
    A[90] = 0.0423280423280419*G0_1_1 + 0.0423280423280419*G2_1_1;
    A[91] = 0.0423280423280421*G0_1_1 + 0.0423280423280421*G2_1_1;
    A[92] = -0.0846560846560818*G0_1_1 - 0.0846560846560818*G2_1_1;
    A[93] = -0.0846560846560844*G0_1_1 - 0.0846560846560844*G2_1_1;
    A[94] = -0.0846560846560848*G0_1_1 - 0.0846560846560848*G2_1_1;
    A[95] = 0.0;
    A[96] = 0.0;
    A[97] = 0.0;
    A[98] = 0.0;
    A[99] = 0.0;
    A[100] = 0.0;
    A[101] = 0.0;
    A[102] = 0.0;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.0;
    A[106] = 0.0;
    A[107] = 0.0;
    A[108] = 0.0;
    A[109] = 0.0;
    A[110] = 0.0;
    A[111] = 0.0;
    A[112] = 0.0420634920634918*G4_1;
    A[113] = -0.00892857142857123*G4_1;
    A[114] = 0.0267857142857139*G4_1;
    A[115] = -0.00892857142857122*G4_1;
    A[116] = 0.0267857142857139*G4_1;
    A[117] = -0.00892857142857123*G4_1;
    A[118] = -0.00892857142857126*G4_1;
    A[119] = 0.0178571428571428*G4_1;
    A[120] = 0.0423280423280401*G0_0_0 + 0.0423280423280384*G0_0_1 + 0.0423280423280398*G0_1_0 + 0.0423280423280365*G0_1_1 + 0.0423280423280401*G2_0_0 + 0.0423280423280384*G2_0_1 + 0.0423280423280398*G2_1_0 + 0.0423280423280365*G2_1_1;
    A[121] = 0.126984126984125*G0_0_0 + 0.778835978835973*G0_1_0 + 0.126984126984125*G2_0_0 + 0.778835978835973*G2_1_0;
    A[122] = 0.203174603174603*G0_0_1 - 0.0423280423280404*G0_1_1 + 0.203174603174603*G2_0_1 - 0.0423280423280404*G2_1_1;
    A[123] = 1.82857142857142*G0_0_0 + 1.04973544973544*G0_0_1 + 1.04973544973544*G0_1_0 + 2.09947089947089*G0_1_1 + 1.82857142857142*G2_0_0 + 1.04973544973544*G2_0_1 + 1.04973544973544*G2_1_0 + 2.09947089947089*G2_1_1;
    A[124] = -0.660317460317456*G0_0_0 + 0.821164021164016*G0_0_1 - 0.296296296296292*G0_1_0 - 0.761904761904758*G0_1_1 - 0.660317460317456*G2_0_0 + 0.821164021164016*G2_0_1 - 0.296296296296292*G2_1_0 - 0.761904761904758*G2_1_1;
    A[125] = 0.338624338624339*G0_0_0 - 0.440211640211639*G0_0_1 + 0.101587301587305*G0_1_0 + 0.338624338624338*G0_1_1 + 0.338624338624339*G2_0_0 - 0.440211640211639*G2_0_1 + 0.101587301587305*G2_1_0 + 0.338624338624338*G2_1_1;
    A[126] = -0.2031746031746*G0_0_0 - 0.101587301587295*G0_0_1 - 0.101587301587307*G0_1_0 - 0.2031746031746*G2_0_0 - 0.101587301587295*G2_0_1 - 0.101587301587307*G2_1_0;
    A[127] = -0.152380952380952*G0_0_0 - 0.0423280423280417*G0_0_1 - 0.0423280423280382*G0_1_0 - 0.152380952380952*G2_0_0 - 0.0423280423280417*G2_0_1 - 0.0423280423280382*G2_1_0;
    A[128] = -0.338624338624338*G0_0_0 - 0.101587301587297*G0_0_1 - 0.101587301587305*G0_1_0 - 0.338624338624338*G2_0_0 - 0.101587301587297*G2_0_1 - 0.101587301587305*G2_1_0;
    A[129] = -0.135449735449728*G0_0_0 - 0.237037037037036*G0_0_1 - 0.237037037037028*G0_1_0 - 0.338624338624342*G0_1_1 - 0.135449735449728*G2_0_0 - 0.237037037037036*G2_0_1 - 0.237037037037028*G2_1_0 - 0.338624338624342*G2_1_1;
    A[130] = 0.101587301587291*G0_0_0 + 0.46560846560846*G0_0_1 + 0.46560846560845*G0_1_0 + 0.761904761904754*G0_1_1 + 0.101587301587291*G2_0_0 + 0.46560846560846*G2_0_1 + 0.46560846560845*G2_1_0 + 0.761904761904754*G2_1_1;
    A[131] = -0.135449735449728*G0_0_0 - 1.04973544973544*G0_0_1 - 1.04973544973543*G0_1_0 - 2.09947089947088*G0_1_1 - 0.135449735449728*G2_0_0 - 1.04973544973544*G2_0_1 - 1.04973544973543*G2_1_0 - 2.09947089947088*G2_1_1;
    A[132] = 0.812698412698404*G0_0_0 + 0.338624338624331*G0_0_1 + 0.338624338624345*G0_1_0 + 0.812698412698404*G2_0_0 + 0.338624338624331*G2_0_1 + 0.338624338624345*G2_1_0;
    A[133] = -2.43809523809522*G0_0_0 - 1.28677248677248*G0_0_1 - 1.28677248677248*G0_1_0 - 2.43809523809522*G2_0_0 - 1.28677248677248*G2_0_1 - 1.28677248677248*G2_1_0;
    A[134] = 0.812698412698408*G0_0_0 + 0.338624338624331*G0_0_1 + 0.33862433862433*G0_1_0 - 1.48405593369816e-14*G0_1_1 + 0.812698412698408*G2_0_0 + 0.338624338624331*G2_0_1 + 0.33862433862433*G2_1_0 - 1.48405593369816e-14*G2_1_1;
    A[135] = 0.0;
    A[136] = 0.0;
    A[137] = 0.0;
    A[138] = 0.0;
    A[139] = 0.0;
    A[140] = 0.0;
    A[141] = 0.0;
    A[142] = 0.0;
    A[143] = 0.0;
    A[144] = 0.0;
    A[145] = 0.0;
    A[146] = 0.0;
    A[147] = 0.0;
    A[148] = 0.0;
    A[149] = 0.0;
    A[150] = 0.0158730158730159*G4_0 + 0.0158730158730161*G4_1;
    A[151] = 0.0222222222222221*G4_0 + 0.0952380952380947*G4_1;
    A[152] = 0.0317460317460316*G4_0 + 0.015873015873016*G4_1;
    A[153] = 0.228571428571427*G4_0 + 0.142857142857142*G4_1;
    A[154] = -0.0857142857142851*G4_0 - 0.0571428571428564*G4_1;
    A[155] = 0.0;
    A[156] = 0.0285714285714285*G4_0;
    A[157] = -0.0571428571428567*G4_0 - 0.0571428571428562*G4_1;
    A[158] = 0.114285714285714*G4_0 + 0.142857142857142*G4_1;
    A[159] = 0.057142857142857*G4_0 + 0.0571428571428573*G4_1;
    A[160] = 0.0423280423280398*G0_0_0 + 0.042328042328041*G0_0_1 + 0.0423280423280411*G0_1_0 + 0.0423280423280429*G0_1_1 + 0.0423280423280398*G2_0_0 + 0.042328042328041*G2_0_1 + 0.0423280423280411*G2_1_0 + 0.0423280423280429*G2_1_1;
    A[161] = 0.0423280423280426*G0_0_0 - 0.425396825396823*G0_1_0 + 0.0423280423280426*G2_0_0 - 0.425396825396823*G2_1_0;
    A[162] = -0.425396825396824*G0_0_1 + 0.0423280423280395*G0_1_1 - 0.425396825396824*G2_0_1 + 0.0423280423280395*G2_1_1;
    A[163] = -0.660317460317456*G0_0_0 - 0.296296296296292*G0_0_1 + 0.821164021164016*G0_1_0 - 0.761904761904758*G0_1_1 - 0.660317460317456*G2_0_0 - 0.296296296296292*G2_0_1 + 0.821164021164016*G2_1_0 - 0.761904761904758*G2_1_1;
    A[164] = 2.45079365079364*G0_0_0 + 0.971428571428565*G0_0_1 + 0.971428571428565*G0_1_0 + 2.45079365079364*G0_1_1 + 2.45079365079364*G2_0_0 + 0.971428571428565*G2_0_1 + 0.971428571428565*G2_1_0 + 2.45079365079364*G2_1_1;
    A[165] = -0.761904761904762*G0_0_0 + 0.821164021164015*G0_0_1 - 0.296296296296303*G0_1_0 - 0.660317460317464*G0_1_1 - 0.761904761904762*G2_0_0 + 0.821164021164015*G2_0_1 - 0.296296296296303*G2_1_0 - 0.660317460317464*G2_1_1;
    A[166] = -0.152380952380945*G0_0_0 - 0.110052910052907*G0_0_1 - 0.110052910052895*G0_1_0 - 0.0677248677248659*G0_1_1 - 0.152380952380945*G2_0_0 - 0.110052910052907*G2_0_1 - 0.110052910052895*G2_1_0 - 0.0677248677248659*G2_1_1;
    A[167] = 0.393650793650787*G0_0_0 + 0.196825396825396*G0_0_1 + 0.196825396825387*G0_1_0 + 0.0507936507936494*G0_1_1 + 0.393650793650787*G2_0_0 + 0.196825396825396*G2_0_1 + 0.196825396825387*G2_1_0 + 0.0507936507936494*G2_1_1;
    A[168] = 0.761904761904762*G0_0_0 + 0.296296296296296*G0_0_1 + 0.296296296296303*G0_1_0 - 0.0677248677248643*G0_1_1 + 0.761904761904762*G2_0_0 + 0.296296296296296*G2_0_1 + 0.296296296296303*G2_1_0 - 0.0677248677248643*G2_1_1;
    A[169] = -0.0677248677248635*G0_0_0 - 0.110052910052907*G0_0_1 - 0.110052910052907*G0_1_0 - 0.152380952380943*G0_1_1 - 0.0677248677248635*G2_0_0 - 0.110052910052907*G2_0_1 - 0.110052910052907*G2_1_0 - 0.152380952380943*G2_1_1;
    A[170] = 0.0507936507936499*G0_0_0 + 0.196825396825395*G0_0_1 + 0.196825396825395*G0_1_0 + 0.393650793650789*G0_1_1 + 0.0507936507936499*G2_0_0 + 0.196825396825395*G2_0_1 + 0.196825396825395*G2_1_0 + 0.393650793650789*G2_1_1;
    A[171] = -0.0677248677248686*G0_0_0 + 0.296296296296293*G0_0_1 + 0.296296296296294*G0_1_0 + 0.761904761904758*G0_1_1 - 0.0677248677248686*G2_0_0 + 0.296296296296293*G2_0_1 + 0.296296296296294*G2_1_0 + 0.761904761904758*G2_1_1;
    A[172] = 0.406349206349191*G0_0_0 + 0.45714285714284*G0_0_1 + 0.457142857142831*G0_1_0 + 0.40634920634918*G0_1_1 + 0.406349206349191*G2_0_0 + 0.45714285714284*G2_0_1 + 0.457142857142831*G2_1_0 + 0.40634920634918*G2_1_1;
    A[173] = 0.40634920634921*G0_0_0 - 1.16825396825396*G0_0_1 - 1.16825396825395*G0_1_0 - 2.84444444444442*G0_1_1 + 0.40634920634921*G2_0_0 - 1.16825396825396*G2_0_1 - 1.16825396825395*G2_1_0 - 2.84444444444442*G2_1_1;
    A[174] = -2.84444444444442*G0_0_0 - 1.16825396825395*G0_0_1 - 1.16825396825395*G0_1_0 + 0.406349206349223*G0_1_1 - 2.84444444444442*G2_0_0 - 1.16825396825395*G2_0_1 - 1.16825396825395*G2_1_0 + 0.406349206349223*G2_1_1;
    A[175] = 0.0;
    A[176] = 0.0;
    A[177] = 0.0;
    A[178] = 0.0;
    A[179] = 0.0;
    A[180] = 0.0;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.0;
    A[184] = 0.0;
    A[185] = 0.0;
    A[186] = 0.0;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.0;
    A[190] = 0.0103174603174602*G4_0 + 0.0103174603174599*G4_1;
    A[191] = -0.0150793650793649*G4_0 - 0.0619047619047617*G4_1;
    A[192] = -0.0619047619047617*G4_0 - 0.0150793650793653*G4_1;
    A[193] = 0.0285714285714287*G4_0 + 0.178571428571428*G4_1;
    A[194] = 0.178571428571427*G4_0 + 0.0285714285714275*G4_1;
    A[195] = -0.0285714285714281*G4_0 - 0.0285714285714287*G4_1;
    A[196] = -0.0500000000000002*G4_0 - 0.0285714285714289*G4_1;
    A[197] = -0.0285714285714284*G4_0 - 0.028571428571429*G4_1;
    A[198] = -0.0285714285714282*G4_0 - 0.0499999999999994*G4_1;
    A[199] = 0.128571428571428*G4_0 + 0.128571428571427*G4_1;
    A[200] = 0.0423280423280425*G0_0_0 + 0.0423280423280411*G0_0_1 + 0.0423280423280415*G0_1_0 + 0.0423280423280402*G0_1_1 + 0.0423280423280425*G2_0_0 + 0.0423280423280411*G2_0_1 + 0.0423280423280415*G2_1_0 + 0.0423280423280402*G2_1_1;
    A[201] = -0.0423280423280421*G0_0_0 + 0.203174603174601*G0_1_0 - 0.0423280423280421*G2_0_0 + 0.203174603174601*G2_1_0;
    A[202] = 0.778835978835974*G0_0_1 + 0.126984126984127*G0_1_1 + 0.778835978835974*G2_0_1 + 0.126984126984127*G2_1_1;
    A[203] = 0.338624338624339*G0_0_0 + 0.101587301587305*G0_0_1 - 0.440211640211639*G0_1_0 + 0.338624338624338*G0_1_1 + 0.338624338624339*G2_0_0 + 0.101587301587305*G2_0_1 - 0.440211640211639*G2_1_0 + 0.338624338624338*G2_1_1;
    A[204] = -0.761904761904762*G0_0_0 - 0.296296296296303*G0_0_1 + 0.821164021164014*G0_1_0 - 0.660317460317464*G0_1_1 - 0.761904761904762*G2_0_0 - 0.296296296296303*G2_0_1 + 0.821164021164014*G2_1_0 - 0.660317460317464*G2_1_1;
    A[205] = 2.0994708994709*G0_0_0 + 1.04973544973545*G0_0_1 + 1.04973544973545*G0_1_0 + 1.82857142857143*G0_1_1 + 2.0994708994709*G2_0_0 + 1.04973544973545*G2_0_1 + 1.04973544973545*G2_1_0 + 1.82857142857143*G2_1_1;
    A[206] = -0.338624338624339*G0_0_0 - 0.237037037037035*G0_0_1 - 0.237037037037037*G0_1_0 - 0.135449735449732*G0_1_1 - 0.338624338624339*G2_0_0 - 0.237037037037035*G2_0_1 - 0.237037037037037*G2_1_0 - 0.135449735449732*G2_1_1;
    A[207] = 0.761904761904763*G0_0_0 + 0.465608465608463*G0_0_1 + 0.465608465608471*G0_1_0 + 0.101587301587302*G0_1_1 + 0.761904761904763*G2_0_0 + 0.465608465608463*G2_0_1 + 0.465608465608471*G2_1_0 + 0.101587301587302*G2_1_1;
    A[208] = -2.0994708994709*G0_0_0 - 1.04973544973544*G0_0_1 - 1.04973544973545*G0_1_0 - 0.135449735449733*G0_1_1 - 2.0994708994709*G2_0_0 - 1.04973544973544*G2_0_1 - 1.04973544973545*G2_1_0 - 0.135449735449733*G2_1_1;
    A[209] = -0.101587301587304*G0_0_1 - 0.101587301587299*G0_1_0 - 0.203174603174605*G0_1_1 - 0.101587301587304*G2_0_1 - 0.101587301587299*G2_1_0 - 0.203174603174605*G2_1_1;
    A[210] = -0.0423280423280409*G0_0_1 - 0.0423280423280437*G0_1_0 - 0.15238095238095*G0_1_1 - 0.0423280423280409*G2_0_1 - 0.0423280423280437*G2_1_0 - 0.15238095238095*G2_1_1;
    A[211] = -0.101587301587297*G0_0_1 - 0.1015873015873*G0_1_0 - 0.338624338624331*G0_1_1 - 0.101587301587297*G2_0_1 - 0.1015873015873*G2_1_0 - 0.338624338624331*G2_1_1;
    A[212] = 0.338624338624343*G0_0_1 + 0.338624338624341*G0_1_0 + 0.812698412698416*G0_1_1 + 0.338624338624343*G2_0_1 + 0.338624338624341*G2_1_0 + 0.812698412698416*G2_1_1;
    A[213] = 0.338624338624334*G0_0_1 + 0.338624338624335*G0_1_0 + 0.812698412698405*G0_1_1 + 0.338624338624334*G2_0_1 + 0.338624338624335*G2_1_0 + 0.812698412698405*G2_1_1;
    A[214] = -1.28677248677249*G0_0_1 - 1.28677248677249*G0_1_0 - 2.43809523809524*G0_1_1 - 1.28677248677249*G2_0_1 - 1.28677248677249*G2_1_0 - 2.43809523809524*G2_1_1;
    A[215] = 0.0;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.0;
    A[219] = 0.0;
    A[220] = 0.0;
    A[221] = 0.0;
    A[222] = 0.0;
    A[223] = 0.0;
    A[224] = 0.0;
    A[225] = 0.0;
    A[226] = 0.0;
    A[227] = 0.0;
    A[228] = 0.0;
    A[229] = 0.0;
    A[230] = 0.0158730158730158*G4_0 + 0.0158730158730159*G4_1;
    A[231] = 0.0158730158730158*G4_0 + 0.0317460317460316*G4_1;
    A[232] = 0.0952380952380949*G4_0 + 0.0222222222222223*G4_1;
    A[233] = -0.057142857142857*G4_0 - 0.0857142857142858*G4_1;
    A[234] = 0.142857142857143*G4_0 + 0.228571428571428*G4_1;
    A[235] = -0.0571428571428571*G4_0 - 0.0571428571428572*G4_1;
    A[236] = 0.142857142857142*G4_0 + 0.114285714285714*G4_1;
    A[237] = 0.0;
    A[238] = 0.028571428571428*G4_1;
    A[239] = 0.0571428571428569*G4_0 + 0.0571428571428559*G4_1;
    A[240] = 0.126984126984129*G0_0_0 + 0.126984126984129*G0_0_1 - 0.65185185185185*G0_1_0 - 0.65185185185185*G0_1_1 + 0.126984126984129*G2_0_0 + 0.126984126984129*G2_0_1 - 0.65185185185185*G2_1_0 - 0.65185185185185*G2_1_1;
    A[241] = 0.0423280423280417*G0_0_0 + 0.0423280423280417*G2_0_0;
    A[242] = -0.203174603174603*G0_0_1 - 0.245502645502643*G0_1_1 - 0.203174603174603*G2_0_1 - 0.245502645502643*G2_1_1;
    A[243] = -0.2031746031746*G0_0_0 - 0.101587301587307*G0_0_1 - 0.101587301587295*G0_1_0 - 0.2031746031746*G2_0_0 - 0.101587301587307*G2_0_1 - 0.101587301587295*G2_1_0;
    A[244] = -0.152380952380945*G0_0_0 - 0.110052910052895*G0_0_1 - 0.110052910052907*G0_1_0 - 0.0677248677248659*G0_1_1 - 0.152380952380945*G2_0_0 - 0.110052910052895*G2_0_1 - 0.110052910052907*G2_1_0 - 0.0677248677248659*G2_1_1;
    A[245] = -0.338624338624339*G0_0_0 - 0.237037037037037*G0_0_1 - 0.237037037037035*G0_1_0 - 0.135449735449732*G0_1_1 - 0.338624338624339*G2_0_0 - 0.237037037037037*G2_0_1 - 0.237037037037035*G2_1_0 - 0.135449735449732*G2_1_1;
    A[246] = 1.82857142857142*G0_0_0 + 0.778835978835975*G0_0_1 + 0.778835978835975*G0_1_0 + 1.82857142857142*G0_1_1 + 1.82857142857142*G2_0_0 + 0.778835978835975*G2_0_1 + 0.778835978835975*G2_1_0 + 1.82857142857142*G2_1_1;
    A[247] = -0.660317460317451*G0_0_0 - 1.48148148148148*G0_0_1 - 0.364021164021161*G0_1_0 - 1.94708994708993*G0_1_1 - 0.660317460317451*G2_0_0 - 1.48148148148148*G2_0_1 - 0.364021164021161*G2_1_0 - 1.94708994708993*G2_1_1;
    A[248] = 0.338624338624339*G0_0_0 + 0.778835978835972*G0_0_1 + 0.237037037037035*G0_1_0 + 1.01587301587301*G0_1_1 + 0.338624338624339*G2_0_0 + 0.778835978835972*G2_0_1 + 0.237037037037035*G2_1_0 + 1.01587301587301*G2_1_1;
    A[249] = -0.135449735449741*G0_0_0 + 0.91428571428571*G0_0_1 + 0.914285714285714*G0_1_0 - 0.135449735449734*G0_1_1 - 0.135449735449741*G2_0_0 + 0.91428571428571*G2_0_1 + 0.914285714285714*G2_1_0 - 0.135449735449734*G2_1_1;
    A[250] = 0.101587301587306*G0_0_0 - 0.364021164021163*G0_0_1 - 0.364021164021164*G0_1_0 - 0.0677248677248649*G0_1_1 + 0.101587301587306*G2_0_0 - 0.364021164021163*G2_0_1 - 0.364021164021164*G2_1_0 - 0.0677248677248649*G2_1_1;
    A[251] = -0.135449735449735*G0_0_0 + 0.1015873015873*G0_0_1 + 0.1015873015873*G0_1_0 - 0.135449735449735*G2_0_0 + 0.1015873015873*G2_0_1 + 0.1015873015873*G2_1_0;
    A[252] = -2.43809523809524*G0_0_0 - 1.15132275132274*G0_0_1 - 1.15132275132274*G0_1_0 + 0.135449735449735*G0_1_1 - 2.43809523809524*G2_0_0 - 1.15132275132274*G2_0_1 - 1.15132275132274*G2_1_0 + 0.135449735449735*G2_1_1;
    A[253] = 0.812698412698413*G0_0_0 + 0.474074074074065*G0_0_1 + 0.474074074074063*G0_1_0 + 0.13544973544973*G0_1_1 + 0.812698412698413*G2_0_0 + 0.474074074074065*G2_0_1 + 0.474074074074063*G2_1_0 + 0.13544973544973*G2_1_1;
    A[254] = 0.812698412698396*G0_0_0 + 0.474074074074073*G0_0_1 + 0.474074074074068*G0_1_0 + 0.13544973544973*G0_1_1 + 0.812698412698396*G2_0_0 + 0.474074074074073*G2_0_1 + 0.474074074074068*G2_1_0 + 0.13544973544973*G2_1_1;
    A[255] = 0.0;
    A[256] = 0.0;
    A[257] = 0.0;
    A[258] = 0.0;
    A[259] = 0.0;
    A[260] = 0.0;
    A[261] = 0.0;
    A[262] = 0.0;
    A[263] = 0.0;
    A[264] = 0.0;
    A[265] = 0.0;
    A[266] = 0.0;
    A[267] = 0.0;
    A[268] = 0.0;
    A[269] = 0.0;
    A[270] = -0.022222222222222*G4_0 + 0.0730158730158728*G4_1;
    A[271] = -0.015873015873016*G4_0;
    A[272] = -0.0317460317460317*G4_0 - 0.0158730158730158*G4_1;
    A[273] = 0.0;
    A[274] = -0.0285714285714281*G4_0 - 0.0285714285714281*G4_1;
    A[275] = -0.228571428571428*G4_0 - 0.0857142857142856*G4_1;
    A[276] = 0.0857142857142849*G4_0 + 0.0285714285714285*G4_1;
    A[277] = -0.114285714285714*G4_0 + 0.028571428571428*G4_1;
    A[278] = 0.0571428571428573*G4_0;
    A[279] = -0.0571428571428568*G4_0;
    A[280] = 0.0423280423280408*G0_0_0 + 0.0423280423280424*G0_0_1 + 0.467724867724864*G0_1_0 + 0.467724867724864*G0_1_1 + 0.0423280423280408*G2_0_0 + 0.0423280423280424*G2_0_1 + 0.467724867724864*G2_1_0 + 0.467724867724864*G2_1_1;
    A[281] = 0.0423280423280418*G0_0_0 + 0.0423280423280418*G2_0_0;
    A[282] = 0.425396825396824*G0_0_1 + 0.467724867724864*G0_1_1 + 0.425396825396824*G2_0_1 + 0.467724867724864*G2_1_1;
    A[283] = -0.152380952380952*G0_0_0 - 0.0423280423280382*G0_0_1 - 0.0423280423280417*G0_1_0 - 0.152380952380952*G2_0_0 - 0.0423280423280382*G2_0_1 - 0.0423280423280417*G2_1_0;
    A[284] = 0.393650793650787*G0_0_0 + 0.196825396825387*G0_0_1 + 0.196825396825396*G0_1_0 + 0.0507936507936493*G0_1_1 + 0.393650793650787*G2_0_0 + 0.196825396825387*G2_0_1 + 0.196825396825396*G2_1_0 + 0.0507936507936493*G2_1_1;
    A[285] = 0.761904761904763*G0_0_0 + 0.465608465608471*G0_0_1 + 0.465608465608463*G0_1_0 + 0.101587301587302*G0_1_1 + 0.761904761904763*G2_0_0 + 0.465608465608471*G2_0_1 + 0.465608465608463*G2_1_0 + 0.101587301587302*G2_1_1;
    A[286] = -0.660317460317451*G0_0_0 - 0.364021164021161*G0_0_1 - 1.48148148148148*G0_1_0 - 1.94708994708993*G0_1_1 - 0.660317460317451*G2_0_0 - 0.364021164021161*G2_0_1 - 1.48148148148148*G2_1_0 - 1.94708994708993*G2_1_1;
    A[287] = 2.45079365079363*G0_0_0 + 1.47936507936507*G0_0_1 + 1.47936507936507*G0_1_0 + 2.95873015873014*G0_1_1 + 2.45079365079363*G2_0_0 + 1.47936507936507*G2_0_1 + 1.47936507936507*G2_1_0 + 2.95873015873014*G2_1_1;
    A[288] = -0.761904761904763*G0_0_0 - 1.58306878306878*G0_0_1 - 0.465608465608463*G0_1_0 - 1.94708994708993*G0_1_1 - 0.761904761904763*G2_0_0 - 1.58306878306878*G2_0_1 - 0.465608465608463*G2_1_0 - 1.94708994708993*G2_1_1;
    A[289] = -0.0677248677248641*G0_0_0 - 0.364021164021158*G0_0_1 - 0.364021164021163*G0_1_0 + 0.101587301587296*G0_1_1 - 0.0677248677248641*G2_0_0 - 0.364021164021158*G2_0_1 - 0.364021164021163*G2_1_0 + 0.101587301587296*G2_1_1;
    A[290] = 0.0507936507936485*G0_0_0 - 0.146031746031747*G0_0_1 - 0.146031746031744*G0_1_0 + 0.0507936507936494*G0_1_1 + 0.0507936507936485*G2_0_0 - 0.146031746031747*G2_0_1 - 0.146031746031744*G2_1_0 + 0.0507936507936494*G2_1_1;
    A[291] = -0.067724867724867*G0_0_0 + 0.0423280423280398*G0_0_1 + 0.042328042328042*G0_1_0 - 0.067724867724867*G2_0_0 + 0.0423280423280398*G2_0_1 + 0.042328042328042*G2_1_0;
    A[292] = 0.406349206349195*G0_0_0 + 1.57460317460316*G0_0_1 + 1.57460317460317*G0_1_0 - 0.101587301587297*G0_1_1 + 0.406349206349195*G2_0_0 + 1.57460317460316*G2_0_1 + 1.57460317460317*G2_1_0 - 0.101587301587297*G2_1_1;
    A[293] = 0.406349206349209*G0_0_0 - 0.0507936507936406*G0_0_1 - 0.0507936507936498*G0_1_0 - 0.1015873015873*G0_1_1 + 0.406349206349209*G2_0_0 - 0.0507936507936406*G2_0_1 - 0.0507936507936498*G2_1_0 - 0.1015873015873*G2_1_1;
    A[294] = -2.84444444444442*G0_0_0 - 1.67619047619047*G0_0_1 - 1.67619047619047*G0_1_0 - 0.101587301587299*G0_1_1 - 2.84444444444442*G2_0_0 - 1.67619047619047*G2_0_1 - 1.67619047619047*G2_1_0 - 0.101587301587299*G2_1_1;
    A[295] = 0.0;
    A[296] = 0.0;
    A[297] = 0.0;
    A[298] = 0.0;
    A[299] = 0.0;
    A[300] = 0.0;
    A[301] = 0.0;
    A[302] = 0.0;
    A[303] = 0.0;
    A[304] = 0.0;
    A[305] = 0.0;
    A[306] = 0.0;
    A[307] = 0.0;
    A[308] = 0.0;
    A[309] = 0.0;
    A[310] = 0.0150793650793649*G4_0 - 0.0468253968253965*G4_1;
    A[311] = -0.0103174603174602*G4_0;
    A[312] = 0.0619047619047617*G4_0 + 0.0468253968253966*G4_1;
    A[313] = 0.0285714285714279*G4_0;
    A[314] = 0.0499999999999999*G4_0 + 0.0214285714285709*G4_1;
    A[315] = -0.0285714285714284*G4_0 + 0.15*G4_1;
    A[316] = -0.178571428571427*G4_0 - 0.15*G4_1;
    A[317] = 0.0285714285714284*G4_0 - 0.0214285714285706*G4_1;
    A[318] = 0.0285714285714283*G4_0;
    A[319] = -0.128571428571428*G4_0;
    A[320] = -0.0423280423280424*G0_0_0 - 0.042328042328041*G0_0_1 - 0.245502645502644*G0_1_0 - 0.245502645502644*G0_1_1 - 0.0423280423280424*G2_0_0 - 0.042328042328041*G2_0_1 - 0.245502645502644*G2_1_0 - 0.245502645502644*G2_1_1;
    A[321] = 0.0423280423280421*G0_0_0 + 0.0423280423280421*G2_0_0;
    A[322] = -0.778835978835974*G0_0_1 - 0.651851851851846*G0_1_1 - 0.778835978835974*G2_0_1 - 0.651851851851846*G2_1_1;
    A[323] = -0.338624338624338*G0_0_0 - 0.101587301587305*G0_0_1 - 0.101587301587297*G0_1_0 - 0.338624338624338*G2_0_0 - 0.101587301587305*G2_0_1 - 0.101587301587297*G2_1_0;
    A[324] = 0.761904761904762*G0_0_0 + 0.296296296296303*G0_0_1 + 0.296296296296296*G0_1_0 - 0.0677248677248643*G0_1_1 + 0.761904761904762*G2_0_0 + 0.296296296296303*G2_0_1 + 0.296296296296296*G2_1_0 - 0.0677248677248643*G2_1_1;
    A[325] = -2.0994708994709*G0_0_0 - 1.04973544973545*G0_0_1 - 1.04973544973544*G0_1_0 - 0.135449735449733*G0_1_1 - 2.0994708994709*G2_0_0 - 1.04973544973545*G2_0_1 - 1.04973544973544*G2_1_0 - 0.135449735449733*G2_1_1;
    A[326] = 0.338624338624339*G0_0_0 + 0.237037037037035*G0_0_1 + 0.778835978835972*G0_1_0 + 1.01587301587301*G0_1_1 + 0.338624338624339*G2_0_0 + 0.237037037037035*G2_0_1 + 0.778835978835972*G2_1_0 + 1.01587301587301*G2_1_1;
    A[327] = -0.761904761904763*G0_0_0 - 0.465608465608463*G0_0_1 - 1.58306878306878*G0_1_0 - 1.94708994708993*G0_1_1 - 0.761904761904763*G2_0_0 - 0.465608465608463*G2_0_1 - 1.58306878306878*G2_1_0 - 1.94708994708993*G2_1_1;
    A[328] = 2.0994708994709*G0_0_0 + 1.04973544973544*G0_0_1 + 1.04973544973544*G0_1_0 + 1.82857142857142*G0_1_1 + 2.0994708994709*G2_0_0 + 1.04973544973544*G2_0_1 + 1.04973544973544*G2_1_0 + 1.82857142857142*G2_1_1;
    A[329] = 0.101587301587304*G0_0_1 + 0.101587301587301*G0_1_0 - 0.135449735449736*G0_1_1 + 0.101587301587304*G2_0_1 + 0.101587301587301*G2_1_0 - 0.135449735449736*G2_1_1;
    A[330] = 0.0423280423280408*G0_0_1 + 0.0423280423280422*G0_1_0 - 0.0677248677248679*G0_1_1 + 0.0423280423280408*G2_0_1 + 0.0423280423280422*G2_1_0 - 0.0677248677248679*G2_1_1;
    A[331] = 0.101587301587297*G0_0_1 + 0.1015873015873*G0_1_0 + 0.101587301587297*G2_0_1 + 0.1015873015873*G2_1_0;
    A[332] = -0.338624338624344*G0_0_1 - 0.338624338624336*G0_1_0 + 0.135449735449733*G0_1_1 - 0.338624338624344*G2_0_1 - 0.338624338624336*G2_1_0 + 0.135449735449733*G2_1_1;
    A[333] = -0.338624338624334*G0_0_1 - 0.338624338624339*G0_1_0 + 0.135449735449735*G0_1_1 - 0.338624338624334*G2_0_1 - 0.338624338624339*G2_1_0 + 0.135449735449735*G2_1_1;
    A[334] = 1.28677248677249*G0_0_1 + 1.28677248677248*G0_1_0 + 0.135449735449734*G0_1_1 + 1.28677248677249*G2_0_1 + 1.28677248677248*G2_1_0 + 0.135449735449734*G2_1_1;
    A[335] = 0.0;
    A[336] = 0.0;
    A[337] = 0.0;
    A[338] = 0.0;
    A[339] = 0.0;
    A[340] = 0.0;
    A[341] = 0.0;
    A[342] = 0.0;
    A[343] = 0.0;
    A[344] = 0.0;
    A[345] = 0.0;
    A[346] = 0.0;
    A[347] = 0.0;
    A[348] = 0.0;
    A[349] = 0.0;
    A[350] = -0.0158730158730158*G4_0 + 0.0158730158730159*G4_1;
    A[351] = -0.0158730158730158*G4_0;
    A[352] = -0.0952380952380949*G4_0 - 0.0730158730158724*G4_1;
    A[353] = 0.0571428571428571*G4_0;
    A[354] = -0.142857142857143*G4_0 - 0.0285714285714277*G4_1;
    A[355] = 0.057142857142857*G4_0 - 0.0285714285714286*G4_1;
    A[356] = -0.142857142857142*G4_0 + 0.0857142857142862*G4_1;
    A[357] = 0.0285714285714283*G4_1;
    A[358] = 0.0;
    A[359] = -0.0571428571428567*G4_0;
    A[360] = -0.651851851851853*G0_0_0 - 0.651851851851852*G0_0_1 + 0.126984126984128*G0_1_0 + 0.126984126984128*G0_1_1 - 0.651851851851853*G2_0_0 - 0.651851851851852*G2_0_1 + 0.126984126984128*G2_1_0 + 0.126984126984128*G2_1_1;
    A[361] = -0.245502645502643*G0_0_0 - 0.203174603174602*G0_1_0 - 0.245502645502643*G2_0_0 - 0.203174603174602*G2_1_0;
    A[362] = 0.0423280423280404*G0_1_1 + 0.0423280423280404*G2_1_1;
    A[363] = -0.135449735449728*G0_0_0 - 0.237037037037028*G0_0_1 - 0.237037037037036*G0_1_0 - 0.338624338624342*G0_1_1 - 0.135449735449728*G2_0_0 - 0.237037037037028*G2_0_1 - 0.237037037037036*G2_1_0 - 0.338624338624342*G2_1_1;
    A[364] = -0.0677248677248635*G0_0_0 - 0.110052910052907*G0_0_1 - 0.110052910052907*G0_1_0 - 0.152380952380943*G0_1_1 - 0.0677248677248635*G2_0_0 - 0.110052910052907*G2_0_1 - 0.110052910052907*G2_1_0 - 0.152380952380943*G2_1_1;
    A[365] = -0.101587301587299*G0_0_1 - 0.101587301587304*G0_1_0 - 0.203174603174605*G0_1_1 - 0.101587301587299*G2_0_1 - 0.101587301587304*G2_1_0 - 0.203174603174605*G2_1_1;
    A[366] = -0.135449735449741*G0_0_0 + 0.914285714285714*G0_0_1 + 0.91428571428571*G0_1_0 - 0.135449735449734*G0_1_1 - 0.135449735449741*G2_0_0 + 0.914285714285714*G2_0_1 + 0.91428571428571*G2_1_0 - 0.135449735449734*G2_1_1;
    A[367] = -0.0677248677248641*G0_0_0 - 0.364021164021163*G0_0_1 - 0.364021164021158*G0_1_0 + 0.101587301587296*G0_1_1 - 0.0677248677248641*G2_0_0 - 0.364021164021163*G2_0_1 - 0.364021164021158*G2_1_0 + 0.101587301587296*G2_1_1;
    A[368] = 0.101587301587301*G0_0_1 + 0.101587301587304*G0_1_0 - 0.135449735449736*G0_1_1 + 0.101587301587301*G2_0_1 + 0.101587301587304*G2_1_0 - 0.135449735449736*G2_1_1;
    A[369] = 1.82857142857142*G0_0_0 + 0.778835978835969*G0_0_1 + 0.778835978835969*G0_1_0 + 1.82857142857142*G0_1_1 + 1.82857142857142*G2_0_0 + 0.778835978835969*G2_0_1 + 0.778835978835969*G2_1_0 + 1.82857142857142*G2_1_1;
    A[370] = -1.94708994708994*G0_0_0 - 0.364021164021158*G0_0_1 - 1.48148148148147*G0_1_0 - 0.660317460317451*G0_1_1 - 1.94708994708994*G2_0_0 - 0.364021164021158*G2_0_1 - 1.48148148148147*G2_1_0 - 0.660317460317451*G2_1_1;
    A[371] = 1.01587301587301*G0_0_0 + 0.23703703703703*G0_0_1 + 0.778835978835972*G0_1_0 + 0.338624338624335*G0_1_1 + 1.01587301587301*G2_0_0 + 0.23703703703703*G2_0_1 + 0.778835978835972*G2_1_0 + 0.338624338624335*G2_1_1;
    A[372] = 0.135449735449745*G0_0_0 - 1.15132275132274*G0_0_1 - 1.15132275132275*G0_1_0 - 2.43809523809522*G0_1_1 + 0.135449735449745*G2_0_0 - 1.15132275132274*G2_0_1 - 1.15132275132275*G2_1_0 - 2.43809523809522*G2_1_1;
    A[373] = 0.135449735449723*G0_0_0 + 0.474074074074061*G0_0_1 + 0.474074074074071*G0_1_0 + 0.812698412698398*G0_1_1 + 0.135449735449723*G2_0_0 + 0.474074074074061*G2_0_1 + 0.474074074074071*G2_1_0 + 0.812698412698398*G2_1_1;
    A[374] = 0.135449735449728*G0_0_0 + 0.474074074074069*G0_0_1 + 0.474074074074065*G0_1_0 + 0.812698412698416*G0_1_1 + 0.135449735449728*G2_0_0 + 0.474074074074069*G2_0_1 + 0.474074074074065*G2_1_0 + 0.812698412698416*G2_1_1;
    A[375] = 0.0;
    A[376] = 0.0;
    A[377] = 0.0;
    A[378] = 0.0;
    A[379] = 0.0;
    A[380] = 0.0;
    A[381] = 0.0;
    A[382] = 0.0;
    A[383] = 0.0;
    A[384] = 0.0;
    A[385] = 0.0;
    A[386] = 0.0;
    A[387] = 0.0;
    A[388] = 0.0;
    A[389] = 0.0;
    A[390] = 0.0730158730158731*G4_0 - 0.0222222222222219*G4_1;
    A[391] = -0.0158730158730156*G4_0 - 0.0317460317460316*G4_1;
    A[392] = -0.0158730158730159*G4_1;
    A[393] = -0.0285714285714273*G4_0 - 0.028571428571428*G4_1;
    A[394] = 0.0;
    A[395] = 0.0285714285714288*G4_0 - 0.114285714285714*G4_1;
    A[396] = 0.0571428571428565*G4_1;
    A[397] = -0.0857142857142849*G4_0 - 0.228571428571428*G4_1;
    A[398] = 0.0285714285714286*G4_0 + 0.0857142857142849*G4_1;
    A[399] = -0.0571428571428582*G4_1;
    A[400] = 0.467724867724868*G0_0_0 + 0.467724867724867*G0_0_1 + 0.0423280423280411*G0_1_0 + 0.0423280423280401*G0_1_1 + 0.467724867724868*G2_0_0 + 0.467724867724867*G2_0_1 + 0.0423280423280411*G2_1_0 + 0.0423280423280401*G2_1_1;
    A[401] = 0.467724867724862*G0_0_0 + 0.425396825396821*G0_1_0 + 0.467724867724862*G2_0_0 + 0.425396825396821*G2_1_0;
    A[402] = 0.0423280423280419*G0_1_1 + 0.0423280423280419*G2_1_1;
    A[403] = 0.101587301587291*G0_0_0 + 0.46560846560845*G0_0_1 + 0.46560846560846*G0_1_0 + 0.761904761904754*G0_1_1 + 0.101587301587291*G2_0_0 + 0.46560846560845*G2_0_1 + 0.46560846560846*G2_1_0 + 0.761904761904754*G2_1_1;
    A[404] = 0.0507936507936499*G0_0_0 + 0.196825396825395*G0_0_1 + 0.196825396825395*G0_1_0 + 0.393650793650789*G0_1_1 + 0.0507936507936499*G2_0_0 + 0.196825396825395*G2_0_1 + 0.196825396825395*G2_1_0 + 0.393650793650789*G2_1_1;
    A[405] = -0.0423280423280437*G0_0_1 - 0.0423280423280409*G0_1_0 - 0.15238095238095*G0_1_1 - 0.0423280423280437*G2_0_1 - 0.0423280423280409*G2_1_0 - 0.15238095238095*G2_1_1;
    A[406] = 0.101587301587306*G0_0_0 - 0.364021164021164*G0_0_1 - 0.364021164021163*G0_1_0 - 0.0677248677248649*G0_1_1 + 0.101587301587306*G2_0_0 - 0.364021164021164*G2_0_1 - 0.364021164021163*G2_1_0 - 0.0677248677248649*G2_1_1;
    A[407] = 0.0507936507936485*G0_0_0 - 0.146031746031744*G0_0_1 - 0.146031746031747*G0_1_0 + 0.0507936507936494*G0_1_1 + 0.0507936507936485*G2_0_0 - 0.146031746031744*G2_0_1 - 0.146031746031747*G2_1_0 + 0.0507936507936494*G2_1_1;
    A[408] = 0.0423280423280423*G0_0_1 + 0.0423280423280408*G0_1_0 - 0.067724867724868*G0_1_1 + 0.0423280423280423*G2_0_1 + 0.0423280423280408*G2_1_0 - 0.067724867724868*G2_1_1;
    A[409] = -1.94708994708994*G0_0_0 - 1.48148148148147*G0_0_1 - 0.364021164021158*G0_1_0 - 0.660317460317451*G0_1_1 - 1.94708994708994*G2_0_0 - 1.48148148148147*G2_0_1 - 0.364021164021158*G2_1_0 - 0.660317460317451*G2_1_1;
    A[410] = 2.95873015873014*G0_0_0 + 1.47936507936507*G0_0_1 + 1.47936507936507*G0_1_0 + 2.45079365079364*G0_1_1 + 2.95873015873014*G2_0_0 + 1.47936507936507*G2_0_1 + 1.47936507936507*G2_1_0 + 2.45079365079364*G2_1_1;
    A[411] = -1.94708994708993*G0_0_0 - 0.465608465608452*G0_0_1 - 1.58306878306877*G0_1_0 - 0.761904761904755*G0_1_1 - 1.94708994708993*G2_0_0 - 0.465608465608452*G2_0_1 - 1.58306878306877*G2_1_0 - 0.761904761904755*G2_1_1;
    A[412] = -0.10158730158731*G0_0_0 + 1.57460317460316*G0_0_1 + 1.57460317460317*G0_1_0 + 0.406349206349191*G0_1_1 - 0.10158730158731*G2_0_0 + 1.57460317460316*G2_0_1 + 1.57460317460317*G2_1_0 + 0.406349206349191*G2_1_1;
    A[413] = -0.101587301587287*G0_0_0 - 1.67619047619046*G0_0_1 - 1.67619047619047*G0_1_0 - 2.84444444444443*G0_1_1 - 0.101587301587287*G2_0_0 - 1.67619047619046*G2_0_1 - 1.67619047619047*G2_1_0 - 2.84444444444443*G2_1_1;
    A[414] = -0.101587301587299*G0_0_0 - 0.0507936507936495*G0_0_1 - 0.0507936507936477*G0_1_0 + 0.40634920634921*G0_1_1 - 0.101587301587299*G2_0_0 - 0.0507936507936495*G2_0_1 - 0.0507936507936477*G2_1_0 + 0.40634920634921*G2_1_1;
    A[415] = 0.0;
    A[416] = 0.0;
    A[417] = 0.0;
    A[418] = 0.0;
    A[419] = 0.0;
    A[420] = 0.0;
    A[421] = 0.0;
    A[422] = 0.0;
    A[423] = 0.0;
    A[424] = 0.0;
    A[425] = 0.0;
    A[426] = 0.0;
    A[427] = 0.0;
    A[428] = 0.0;
    A[429] = 0.0;
    A[430] = -0.0468253968253971*G4_0 + 0.0150793650793649*G4_1;
    A[431] = 0.0468253968253961*G4_0 + 0.0619047619047615*G4_1;
    A[432] = -0.0103174603174603*G4_1;
    A[433] = 0.0214285714285699*G4_0 + 0.0499999999999991*G4_1;
    A[434] = 0.0285714285714287*G4_1;
    A[435] = -0.0214285714285716*G4_0 + 0.0285714285714285*G4_1;
    A[436] = 0.0285714285714287*G4_1;
    A[437] = 0.149999999999999*G4_0 - 0.0285714285714283*G4_1;
    A[438] = -0.15*G4_0 - 0.178571428571428*G4_1;
    A[439] = -0.128571428571428*G4_1;
    A[440] = -0.245502645502645*G0_0_0 - 0.245502645502644*G0_0_1 - 0.0423280423280423*G0_1_0 - 0.042328042328039*G0_1_1 - 0.245502645502645*G2_0_0 - 0.245502645502644*G2_0_1 - 0.0423280423280423*G2_1_0 - 0.042328042328039*G2_1_1;
    A[441] = -0.651851851851845*G0_0_0 - 0.778835978835971*G0_1_0 - 0.651851851851845*G2_0_0 - 0.778835978835971*G2_1_0;
    A[442] = 0.0423280423280421*G0_1_1 + 0.0423280423280421*G2_1_1;
    A[443] = -0.135449735449728*G0_0_0 - 1.04973544973543*G0_0_1 - 1.04973544973544*G0_1_0 - 2.09947089947088*G0_1_1 - 0.135449735449728*G2_0_0 - 1.04973544973543*G2_0_1 - 1.04973544973544*G2_1_0 - 2.09947089947088*G2_1_1;
    A[444] = -0.0677248677248686*G0_0_0 + 0.296296296296294*G0_0_1 + 0.296296296296293*G0_1_0 + 0.761904761904758*G0_1_1 - 0.0677248677248686*G2_0_0 + 0.296296296296294*G2_0_1 + 0.296296296296293*G2_1_0 + 0.761904761904758*G2_1_1;
    A[445] = -0.1015873015873*G0_0_1 - 0.101587301587297*G0_1_0 - 0.338624338624331*G0_1_1 - 0.1015873015873*G2_0_1 - 0.101587301587297*G2_1_0 - 0.338624338624331*G2_1_1;
    A[446] = -0.135449735449735*G0_0_0 + 0.1015873015873*G0_0_1 + 0.1015873015873*G0_1_0 - 0.135449735449735*G2_0_0 + 0.1015873015873*G2_0_1 + 0.1015873015873*G2_1_0;
    A[447] = -0.067724867724867*G0_0_0 + 0.0423280423280421*G0_0_1 + 0.0423280423280398*G0_1_0 - 0.067724867724867*G2_0_0 + 0.0423280423280421*G2_0_1 + 0.0423280423280398*G2_1_0;
    A[448] = 0.1015873015873*G0_0_1 + 0.101587301587297*G0_1_0 + 0.1015873015873*G2_0_1 + 0.101587301587297*G2_1_0;
    A[449] = 1.01587301587301*G0_0_0 + 0.778835978835972*G0_0_1 + 0.23703703703703*G0_1_0 + 0.338624338624335*G0_1_1 + 1.01587301587301*G2_0_0 + 0.778835978835972*G2_0_1 + 0.23703703703703*G2_1_0 + 0.338624338624335*G2_1_1;
    A[450] = -1.94708994708993*G0_0_0 - 1.58306878306877*G0_0_1 - 0.465608465608452*G0_1_0 - 0.761904761904755*G0_1_1 - 1.94708994708993*G2_0_0 - 1.58306878306877*G2_0_1 - 0.465608465608452*G2_1_0 - 0.761904761904755*G2_1_1;
    A[451] = 1.82857142857141*G0_0_0 + 1.04973544973543*G0_0_1 + 1.04973544973543*G0_1_0 + 2.09947089947087*G0_1_1 + 1.82857142857141*G2_0_0 + 1.04973544973543*G2_0_1 + 1.04973544973543*G2_1_0 + 2.09947089947087*G2_1_1;
    A[452] = 0.135449735449738*G0_0_0 - 0.33862433862433*G0_0_1 - 0.338624338624342*G0_1_0 + 0.135449735449738*G2_0_0 - 0.33862433862433*G2_0_1 - 0.338624338624342*G2_1_0;
    A[453] = 0.135449735449726*G0_0_0 + 1.28677248677247*G0_0_1 + 1.28677248677248*G0_1_0 + 0.135449735449726*G2_0_0 + 1.28677248677247*G2_0_1 + 1.28677248677248*G2_1_0;
    A[454] = 0.135449735449736*G0_0_0 - 0.338624338624337*G0_0_1 - 0.338624338624333*G0_1_0 + 1.024484316825e-14*G0_1_1 + 0.135449735449736*G2_0_0 - 0.338624338624337*G2_0_1 - 0.338624338624333*G2_1_0 + 1.024484316825e-14*G2_1_1;
    A[455] = 0.0;
    A[456] = 0.0;
    A[457] = 0.0;
    A[458] = 0.0;
    A[459] = 0.0;
    A[460] = 0.0;
    A[461] = 0.0;
    A[462] = 0.0;
    A[463] = 0.0;
    A[464] = 0.0;
    A[465] = 0.0;
    A[466] = 0.0;
    A[467] = 0.0;
    A[468] = 0.0;
    A[469] = 0.0;
    A[470] = 0.015873015873016*G4_0 - 0.0158730158730157*G4_1;
    A[471] = -0.0730158730158723*G4_0 - 0.0952380952380944*G4_1;
    A[472] = -0.0158730158730156*G4_1;
    A[473] = -0.0285714285714276*G4_0 - 0.142857142857141*G4_1;
    A[474] = 0.0571428571428571*G4_1;
    A[475] = 0.0285714285714285*G4_0;
    A[476] = 0.0;
    A[477] = -0.0285714285714288*G4_0 + 0.0571428571428568*G4_1;
    A[478] = 0.0857142857142859*G4_0 - 0.142857142857141*G4_1;
    A[479] = -0.0571428571428546*G4_1;
    A[480] = -0.0846560846560892*G0_0_0 - 0.0846560846560894*G0_0_1 - 0.0846560846560886*G0_1_0 - 0.0846560846560862*G0_1_1 - 0.0846560846560892*G2_0_0 - 0.0846560846560894*G2_0_1 - 0.0846560846560886*G2_1_0 - 0.0846560846560862*G2_1_1;
    A[481] = -0.0846560846560834*G0_0_0 - 0.0846560846560834*G2_0_0;
    A[482] = -0.0846560846560818*G0_1_1 - 0.0846560846560818*G2_1_1;
    A[483] = 0.812698412698404*G0_0_0 + 0.338624338624345*G0_0_1 + 0.338624338624331*G0_1_0 + 0.812698412698404*G2_0_0 + 0.338624338624345*G2_0_1 + 0.338624338624331*G2_1_0;
    A[484] = 0.406349206349191*G0_0_0 + 0.457142857142831*G0_0_1 + 0.45714285714284*G0_1_0 + 0.40634920634918*G0_1_1 + 0.406349206349191*G2_0_0 + 0.457142857142831*G2_0_1 + 0.45714285714284*G2_1_0 + 0.40634920634918*G2_1_1;
    A[485] = 0.338624338624341*G0_0_1 + 0.338624338624343*G0_1_0 + 0.812698412698417*G0_1_1 + 0.338624338624341*G2_0_1 + 0.338624338624343*G2_1_0 + 0.812698412698417*G2_1_1;
    A[486] = -2.43809523809524*G0_0_0 - 1.15132275132274*G0_0_1 - 1.15132275132274*G0_1_0 + 0.135449735449735*G0_1_1 - 2.43809523809524*G2_0_0 - 1.15132275132274*G2_0_1 - 1.15132275132274*G2_1_0 + 0.135449735449735*G2_1_1;
    A[487] = 0.406349206349195*G0_0_0 + 1.57460317460317*G0_0_1 + 1.57460317460316*G0_1_0 - 0.101587301587297*G0_1_1 + 0.406349206349195*G2_0_0 + 1.57460317460317*G2_0_1 + 1.57460317460316*G2_1_0 - 0.101587301587297*G2_1_1;
    A[488] = -0.338624338624336*G0_0_1 - 0.338624338624344*G0_1_0 + 0.135449735449733*G0_1_1 - 0.338624338624336*G2_0_1 - 0.338624338624344*G2_1_0 + 0.135449735449733*G2_1_1;
    A[489] = 0.135449735449745*G0_0_0 - 1.15132275132274*G0_0_1 - 1.15132275132274*G0_1_0 - 2.43809523809522*G0_1_1 + 0.135449735449745*G2_0_0 - 1.15132275132274*G2_0_1 - 1.15132275132274*G2_1_0 - 2.43809523809522*G2_1_1;
    A[490] = -0.10158730158731*G0_0_0 + 1.57460317460317*G0_0_1 + 1.57460317460316*G0_1_0 + 0.406349206349191*G0_1_1 - 0.10158730158731*G2_0_0 + 1.57460317460317*G2_0_1 + 1.57460317460316*G2_1_0 + 0.406349206349191*G2_1_1;
    A[491] = 0.135449735449738*G0_0_0 - 0.338624338624342*G0_0_1 - 0.33862433862433*G0_1_0 + 0.135449735449738*G2_0_0 - 0.338624338624342*G2_0_1 - 0.33862433862433*G2_1_0;
    A[492] = 5.68888888888888*G0_0_0 + 2.84444444444442*G0_0_1 + 2.84444444444442*G0_1_0 + 5.68888888888886*G0_1_1 + 5.68888888888888*G2_0_0 + 2.84444444444442*G2_0_1 + 2.84444444444442*G2_1_0 + 5.68888888888886*G2_1_1;
    A[493] = -4.06349206349205*G0_0_0 - 2.031746031746*G0_0_1 - 2.03174603174601*G0_1_0 - 0.812698412698373*G0_1_1 - 4.06349206349205*G2_0_0 - 2.031746031746*G2_0_1 - 2.03174603174601*G2_1_0 - 0.812698412698373*G2_1_1;
    A[494] = -0.812698412698384*G0_0_0 - 2.03174603174601*G0_0_1 - 2.031746031746*G0_1_0 - 4.06349206349205*G0_1_1 - 0.812698412698384*G2_0_0 - 2.03174603174601*G2_0_1 - 2.031746031746*G2_1_0 - 4.06349206349205*G2_1_1;
    A[495] = 0.0;
    A[496] = 0.0;
    A[497] = 0.0;
    A[498] = 0.0;
    A[499] = 0.0;
    A[500] = 0.0;
    A[501] = 0.0;
    A[502] = 0.0;
    A[503] = 0.0;
    A[504] = 0.0;
    A[505] = 0.0;
    A[506] = 0.0;
    A[507] = 0.0;
    A[508] = 0.0;
    A[509] = 0.0;
    A[510] = 0.0317460317460316*G4_0 + 0.0317460317460313*G4_1;
    A[511] = 0.0253968253968259*G4_0;
    A[512] = 0.0253968253968256*G4_1;
    A[513] = 0.057142857142855*G4_0 + 0.0571428571428549*G4_1;
    A[514] = 0.0571428571428563*G4_0 + 0.0571428571428564*G4_1;
    A[515] = 0.285714285714287*G4_0 + 0.0571428571428578*G4_1;
    A[516] = -0.0571428571428562*G4_0 - 0.114285714285713*G4_1;
    A[517] = 0.0571428571428582*G4_0 + 0.285714285714286*G4_1;
    A[518] = -0.114285714285714*G4_0 - 0.0571428571428567*G4_1;
    A[519] = -0.342857142857141*G4_0 - 0.342857142857141*G4_1;
    A[520] = -0.0846560846560791*G0_0_0 - 0.0846560846560775*G0_0_1 - 0.0846560846560799*G0_1_0 - 0.0846560846560807*G0_1_1 - 0.0846560846560791*G2_0_0 - 0.0846560846560775*G2_0_1 - 0.0846560846560799*G2_1_0 - 0.0846560846560807*G2_1_1;
    A[521] = -0.0846560846560834*G0_0_0 - 0.0846560846560834*G2_0_0;
    A[522] = -0.0846560846560844*G0_1_1 - 0.0846560846560844*G2_1_1;
    A[523] = -2.43809523809522*G0_0_0 - 1.28677248677248*G0_0_1 - 1.28677248677248*G0_1_0 - 2.43809523809522*G2_0_0 - 1.28677248677248*G2_0_1 - 1.28677248677248*G2_1_0;
    A[524] = 0.40634920634921*G0_0_0 - 1.16825396825395*G0_0_1 - 1.16825396825396*G0_1_0 - 2.84444444444442*G0_1_1 + 0.40634920634921*G2_0_0 - 1.16825396825395*G2_0_1 - 1.16825396825396*G2_1_0 - 2.84444444444442*G2_1_1;
    A[525] = 0.338624338624335*G0_0_1 + 0.338624338624334*G0_1_0 + 0.812698412698406*G0_1_1 + 0.338624338624335*G2_0_1 + 0.338624338624334*G2_1_0 + 0.812698412698406*G2_1_1;
    A[526] = 0.812698412698413*G0_0_0 + 0.474074074074063*G0_0_1 + 0.474074074074065*G0_1_0 + 0.13544973544973*G0_1_1 + 0.812698412698413*G2_0_0 + 0.474074074074063*G2_0_1 + 0.474074074074065*G2_1_0 + 0.13544973544973*G2_1_1;
    A[527] = 0.406349206349209*G0_0_0 - 0.0507936507936498*G0_0_1 - 0.0507936507936406*G0_1_0 - 0.1015873015873*G0_1_1 + 0.406349206349209*G2_0_0 - 0.0507936507936498*G2_0_1 - 0.0507936507936406*G2_1_0 - 0.1015873015873*G2_1_1;
    A[528] = -0.338624338624339*G0_0_1 - 0.338624338624334*G0_1_0 + 0.135449735449735*G0_1_1 - 0.338624338624339*G2_0_1 - 0.338624338624334*G2_1_0 + 0.135449735449735*G2_1_1;
    A[529] = 0.135449735449723*G0_0_0 + 0.474074074074071*G0_0_1 + 0.474074074074061*G0_1_0 + 0.812698412698398*G0_1_1 + 0.135449735449723*G2_0_0 + 0.474074074074071*G2_0_1 + 0.474074074074061*G2_1_0 + 0.812698412698398*G2_1_1;
    A[530] = -0.101587301587287*G0_0_0 - 1.67619047619047*G0_0_1 - 1.67619047619046*G0_1_0 - 2.84444444444443*G0_1_1 - 0.101587301587287*G2_0_0 - 1.67619047619047*G2_0_1 - 1.67619047619046*G2_1_0 - 2.84444444444443*G2_1_1;
    A[531] = 0.135449735449726*G0_0_0 + 1.28677248677248*G0_0_1 + 1.28677248677247*G0_1_0 + 0.135449735449726*G2_0_0 + 1.28677248677248*G2_0_1 + 1.28677248677247*G2_1_0;
    A[532] = -4.06349206349205*G0_0_0 - 2.03174603174601*G0_0_1 - 2.031746031746*G0_1_0 - 0.812698412698373*G0_1_1 - 4.06349206349205*G2_0_0 - 2.03174603174601*G2_0_1 - 2.031746031746*G2_1_0 - 0.812698412698373*G2_1_1;
    A[533] = 5.68888888888886*G0_0_0 + 2.84444444444442*G0_0_1 + 2.84444444444442*G0_1_0 + 5.68888888888885*G0_1_1 + 5.68888888888886*G2_0_0 + 2.84444444444442*G2_0_1 + 2.84444444444442*G2_1_0 + 5.68888888888885*G2_1_1;
    A[534] = -0.812698412698419*G0_0_0 + 1.21904761904761*G0_0_1 + 1.2190476190476*G0_1_0 - 0.812698412698428*G0_1_1 - 0.812698412698419*G2_0_0 + 1.21904761904761*G2_0_1 + 1.2190476190476*G2_1_0 - 0.812698412698428*G2_1_1;
    A[535] = 0.0;
    A[536] = 0.0;
    A[537] = 0.0;
    A[538] = 0.0;
    A[539] = 0.0;
    A[540] = 0.0;
    A[541] = 0.0;
    A[542] = 0.0;
    A[543] = 0.0;
    A[544] = 0.0;
    A[545] = 0.0;
    A[546] = 0.0;
    A[547] = 0.0;
    A[548] = 0.0;
    A[549] = 0.0;
    A[550] = -0.0253968253968255*G4_0 - 0.0253968253968251*G4_1;
    A[551] = -0.031746031746032*G4_0;
    A[552] = 0.0253968253968252*G4_1;
    A[553] = -0.285714285714283*G4_0 - 0.228571428571427*G4_1;
    A[554] = 0.0571428571428569*G4_0 - 0.0571428571428575*G4_1;
    A[555] = -0.0571428571428583*G4_0;
    A[556] = -0.0571428571428571*G4_0;
    A[557] = 0.114285714285713*G4_0 + 0.0571428571428566*G4_1;
    A[558] = -0.0571428571428564*G4_0 + 0.228571428571428*G4_1;
    A[559] = 0.342857142857141*G4_0;
    A[560] = -0.0846560846560807*G0_0_0 - 0.0846560846560836*G0_0_1 - 0.0846560846560803*G0_1_0 - 0.0846560846560813*G0_1_1 - 0.0846560846560807*G2_0_0 - 0.0846560846560836*G2_0_1 - 0.0846560846560803*G2_1_0 - 0.0846560846560813*G2_1_1;
    A[561] = -0.0846560846560844*G0_0_0 - 0.0846560846560844*G2_0_0;
    A[562] = -0.0846560846560848*G0_1_1 - 0.0846560846560848*G2_1_1;
    A[563] = 0.812698412698408*G0_0_0 + 0.33862433862433*G0_0_1 + 0.338624338624331*G0_1_0 - 1.48713506786802e-14*G0_1_1 + 0.812698412698408*G2_0_0 + 0.33862433862433*G2_0_1 + 0.338624338624331*G2_1_0 - 1.48713506786802e-14*G2_1_1;
    A[564] = -2.84444444444442*G0_0_0 - 1.16825396825395*G0_0_1 - 1.16825396825395*G0_1_0 + 0.406349206349223*G0_1_1 - 2.84444444444442*G2_0_0 - 1.16825396825395*G2_0_1 - 1.16825396825395*G2_1_0 + 0.406349206349223*G2_1_1;
    A[565] = -1.28677248677248*G0_0_1 - 1.28677248677249*G0_1_0 - 2.43809523809524*G0_1_1 - 1.28677248677248*G2_0_1 - 1.28677248677249*G2_1_0 - 2.43809523809524*G2_1_1;
    A[566] = 0.812698412698396*G0_0_0 + 0.474074074074068*G0_0_1 + 0.474074074074073*G0_1_0 + 0.13544973544973*G0_1_1 + 0.812698412698396*G2_0_0 + 0.474074074074068*G2_0_1 + 0.474074074074073*G2_1_0 + 0.13544973544973*G2_1_1;
    A[567] = -2.84444444444442*G0_0_0 - 1.67619047619047*G0_0_1 - 1.67619047619047*G0_1_0 - 0.101587301587299*G0_1_1 - 2.84444444444442*G2_0_0 - 1.67619047619047*G2_0_1 - 1.67619047619047*G2_1_0 - 0.101587301587299*G2_1_1;
    A[568] = 1.28677248677248*G0_0_1 + 1.28677248677249*G0_1_0 + 0.135449735449734*G0_1_1 + 1.28677248677248*G2_0_1 + 1.28677248677249*G2_1_0 + 0.135449735449734*G2_1_1;
    A[569] = 0.135449735449728*G0_0_0 + 0.474074074074065*G0_0_1 + 0.474074074074069*G0_1_0 + 0.812698412698416*G0_1_1 + 0.135449735449728*G2_0_0 + 0.474074074074065*G2_0_1 + 0.474074074074069*G2_1_0 + 0.812698412698416*G2_1_1;
    A[570] = -0.101587301587299*G0_0_0 - 0.0507936507936477*G0_0_1 - 0.0507936507936494*G0_1_0 + 0.40634920634921*G0_1_1 - 0.101587301587299*G2_0_0 - 0.0507936507936477*G2_0_1 - 0.0507936507936494*G2_1_0 + 0.40634920634921*G2_1_1;
    A[571] = 0.135449735449736*G0_0_0 - 0.338624338624333*G0_0_1 - 0.338624338624338*G0_1_0 + 1.0248312615202e-14*G0_1_1 + 0.135449735449736*G2_0_0 - 0.338624338624333*G2_0_1 - 0.338624338624338*G2_1_0 + 1.0248312615202e-14*G2_1_1;
    A[572] = -0.812698412698384*G0_0_0 - 2.031746031746*G0_0_1 - 2.03174603174601*G0_1_0 - 4.06349206349205*G0_1_1 - 0.812698412698384*G2_0_0 - 2.031746031746*G2_0_1 - 2.03174603174601*G2_1_0 - 4.06349206349205*G2_1_1;
    A[573] = -0.812698412698419*G0_0_0 + 1.2190476190476*G0_0_1 + 1.21904761904761*G0_1_0 - 0.812698412698428*G0_1_1 - 0.812698412698419*G2_0_0 + 1.2190476190476*G2_0_1 + 1.21904761904761*G2_1_0 - 0.812698412698428*G2_1_1;
    A[574] = 5.68888888888885*G0_0_0 + 2.84444444444442*G0_0_1 + 2.84444444444442*G0_1_0 + 5.68888888888888*G0_1_1 + 5.68888888888885*G2_0_0 + 2.84444444444442*G2_0_1 + 2.84444444444442*G2_1_0 + 5.68888888888888*G2_1_1;
    A[575] = 0.0;
    A[576] = 0.0;
    A[577] = 0.0;
    A[578] = 0.0;
    A[579] = 0.0;
    A[580] = 0.0;
    A[581] = 0.0;
    A[582] = 0.0;
    A[583] = 0.0;
    A[584] = 0.0;
    A[585] = 0.0;
    A[586] = 0.0;
    A[587] = 0.0;
    A[588] = 0.0;
    A[589] = 0.0;
    A[590] = -0.0253968253968251*G4_0 - 0.0253968253968256*G4_1;
    A[591] = 0.0253968253968252*G4_0;
    A[592] = -0.0317460317460321*G4_1;
    A[593] = -0.0571428571428566*G4_0 + 0.057142857142857*G4_1;
    A[594] = -0.228571428571427*G4_0 - 0.285714285714284*G4_1;
    A[595] = 0.0571428571428566*G4_0 + 0.114285714285713*G4_1;
    A[596] = 0.228571428571427*G4_0 - 0.057142857142857*G4_1;
    A[597] = -0.0571428571428582*G4_1;
    A[598] = -0.0571428571428579*G4_1;
    A[599] = 0.34285714285714*G4_1;
    A[600] = 0.0;
    A[601] = 0.0;
    A[602] = 0.0;
    A[603] = 0.0;
    A[604] = 0.0;
    A[605] = 0.0;
    A[606] = 0.0;
    A[607] = 0.0;
    A[608] = 0.0;
    A[609] = 0.0;
    A[610] = 0.0;
    A[611] = 0.0;
    A[612] = 0.0;
    A[613] = 0.0;
    A[614] = 0.0;
    A[615] = 0.373015873015873*G1_0_0 + 0.373015873015873*G1_0_1 + 0.373015873015873*G1_1_0 + 0.373015873015873*G1_1_1 + 0.373015873015873*G3_0_0 + 0.373015873015873*G3_0_1 + 0.373015873015873*G3_1_0 + 0.373015873015873*G3_1_1;
    A[616] = 0.0566137566137566*G1_0_0 + 0.0566137566137555*G1_1_0 + 0.0566137566137566*G3_0_0 + 0.0566137566137555*G3_1_0;
    A[617] = 0.0566137566137561*G1_0_1 + 0.0566137566137558*G1_1_1 + 0.0566137566137561*G3_0_1 + 0.0566137566137558*G3_1_1;
    A[618] = 0.0423280423280401*G1_0_0 + 0.0423280423280397*G1_0_1 + 0.0423280423280384*G1_1_0 + 0.0423280423280365*G1_1_1 + 0.0423280423280401*G3_0_0 + 0.0423280423280397*G3_0_1 + 0.0423280423280384*G3_1_0 + 0.0423280423280365*G3_1_1;
    A[619] = 0.0423280423280398*G1_0_0 + 0.0423280423280411*G1_0_1 + 0.042328042328041*G1_1_0 + 0.0423280423280429*G1_1_1 + 0.0423280423280398*G3_0_0 + 0.0423280423280411*G3_0_1 + 0.042328042328041*G3_1_0 + 0.0423280423280429*G3_1_1;
    A[620] = 0.0423280423280425*G1_0_0 + 0.0423280423280415*G1_0_1 + 0.042328042328041*G1_1_0 + 0.0423280423280402*G1_1_1 + 0.0423280423280425*G3_0_0 + 0.0423280423280415*G3_0_1 + 0.042328042328041*G3_1_0 + 0.0423280423280402*G3_1_1;
    A[621] = 0.126984126984129*G1_0_0 - 0.65185185185185*G1_0_1 + 0.126984126984129*G1_1_0 - 0.65185185185185*G1_1_1 + 0.126984126984129*G3_0_0 - 0.65185185185185*G3_0_1 + 0.126984126984129*G3_1_0 - 0.65185185185185*G3_1_1;
    A[622] = 0.0423280423280408*G1_0_0 + 0.467724867724864*G1_0_1 + 0.0423280423280424*G1_1_0 + 0.467724867724864*G1_1_1 + 0.0423280423280408*G3_0_0 + 0.467724867724864*G3_0_1 + 0.0423280423280424*G3_1_0 + 0.467724867724864*G3_1_1;
    A[623] = -0.0423280423280424*G1_0_0 - 0.245502645502644*G1_0_1 - 0.042328042328041*G1_1_0 - 0.245502645502644*G1_1_1 - 0.0423280423280424*G3_0_0 - 0.245502645502644*G3_0_1 - 0.042328042328041*G3_1_0 - 0.245502645502644*G3_1_1;
    A[624] = -0.651851851851853*G1_0_0 + 0.126984126984128*G1_0_1 - 0.651851851851852*G1_1_0 + 0.126984126984128*G1_1_1 - 0.651851851851853*G3_0_0 + 0.126984126984128*G3_0_1 - 0.651851851851852*G3_1_0 + 0.126984126984128*G3_1_1;
    A[625] = 0.467724867724868*G1_0_0 + 0.0423280423280411*G1_0_1 + 0.467724867724867*G1_1_0 + 0.0423280423280401*G1_1_1 + 0.467724867724868*G3_0_0 + 0.0423280423280411*G3_0_1 + 0.467724867724867*G3_1_0 + 0.0423280423280401*G3_1_1;
    A[626] = -0.245502645502645*G1_0_0 - 0.0423280423280423*G1_0_1 - 0.245502645502643*G1_1_0 - 0.042328042328039*G1_1_1 - 0.245502645502645*G3_0_0 - 0.0423280423280423*G3_0_1 - 0.245502645502643*G3_1_0 - 0.042328042328039*G3_1_1;
    A[627] = -0.0846560846560892*G1_0_0 - 0.0846560846560885*G1_0_1 - 0.0846560846560893*G1_1_0 - 0.0846560846560863*G1_1_1 - 0.0846560846560892*G3_0_0 - 0.0846560846560885*G3_0_1 - 0.0846560846560893*G3_1_0 - 0.0846560846560863*G3_1_1;
    A[628] = -0.0846560846560791*G1_0_0 - 0.0846560846560799*G1_0_1 - 0.0846560846560775*G1_1_0 - 0.0846560846560807*G1_1_1 - 0.0846560846560791*G3_0_0 - 0.0846560846560799*G3_0_1 - 0.0846560846560775*G3_1_0 - 0.0846560846560807*G3_1_1;
    A[629] = -0.0846560846560807*G1_0_0 - 0.0846560846560803*G1_0_1 - 0.0846560846560835*G1_1_0 - 0.0846560846560813*G1_1_1 - 0.0846560846560807*G3_0_0 - 0.0846560846560803*G3_0_1 - 0.0846560846560835*G3_1_0 - 0.0846560846560813*G3_1_1;
    A[630] = -0.042063492063492*G5_0 - 0.042063492063492*G5_1;
    A[631] = 0.0;
    A[632] = 0.0;
    A[633] = 0.00892857142857105*G5_0 + 0.00892857142857096*G5_1;
    A[634] = 0.00892857142857125*G5_0 + 0.00892857142857122*G5_1;
    A[635] = -0.0267857142857143*G5_0 - 0.0267857142857143*G5_1;
    A[636] = 0.00892857142857158*G5_0 + 0.00892857142857128*G5_1;
    A[637] = -0.0267857142857144*G5_0 - 0.0267857142857142*G5_1;
    A[638] = 0.00892857142857149*G5_0 + 0.00892857142857129*G5_1;
    A[639] = -0.017857142857143*G5_0 - 0.0178571428571434*G5_1;
    A[640] = 0.0;
    A[641] = 0.0;
    A[642] = 0.0;
    A[643] = 0.0;
    A[644] = 0.0;
    A[645] = 0.0;
    A[646] = 0.0;
    A[647] = 0.0;
    A[648] = 0.0;
    A[649] = 0.0;
    A[650] = 0.0;
    A[651] = 0.0;
    A[652] = 0.0;
    A[653] = 0.0;
    A[654] = 0.0;
    A[655] = 0.0566137566137566*G1_0_0 + 0.0566137566137555*G1_0_1 + 0.0566137566137566*G3_0_0 + 0.0566137566137555*G3_0_1;
    A[656] = 0.37301587301587*G1_0_0 + 0.37301587301587*G3_0_0;
    A[657] = -0.056613756613756*G1_0_1 - 0.056613756613756*G3_0_1;
    A[658] = 0.126984126984125*G1_0_0 + 0.778835978835973*G1_0_1 + 0.126984126984125*G3_0_0 + 0.778835978835973*G3_0_1;
    A[659] = 0.0423280423280426*G1_0_0 - 0.425396825396823*G1_0_1 + 0.0423280423280426*G3_0_0 - 0.425396825396823*G3_0_1;
    A[660] = -0.0423280423280421*G1_0_0 + 0.203174603174601*G1_0_1 - 0.0423280423280421*G3_0_0 + 0.203174603174601*G3_0_1;
    A[661] = 0.0423280423280416*G1_0_0 + 0.0423280423280416*G3_0_0;
    A[662] = 0.0423280423280419*G1_0_0 + 0.0423280423280419*G3_0_0;
    A[663] = 0.0423280423280421*G1_0_0 + 0.0423280423280421*G3_0_0;
    A[664] = -0.245502645502643*G1_0_0 - 0.203174603174602*G1_0_1 - 0.245502645502643*G3_0_0 - 0.203174603174602*G3_0_1;
    A[665] = 0.467724867724862*G1_0_0 + 0.425396825396821*G1_0_1 + 0.467724867724862*G3_0_0 + 0.425396825396821*G3_0_1;
    A[666] = -0.651851851851845*G1_0_0 - 0.778835978835972*G1_0_1 - 0.651851851851845*G3_0_0 - 0.778835978835972*G3_0_1;
    A[667] = -0.0846560846560834*G1_0_0 - 0.0846560846560834*G3_0_0;
    A[668] = -0.0846560846560834*G1_0_0 - 0.0846560846560834*G3_0_0;
    A[669] = -0.0846560846560845*G1_0_0 - 0.0846560846560845*G3_0_0;
    A[670] = 0.0;
    A[671] = 0.0420634920634918*G5_0;
    A[672] = 0.0;
    A[673] = 0.026785714285714*G5_0;
    A[674] = -0.00892857142857135*G5_0;
    A[675] = -0.00892857142857137*G5_0;
    A[676] = -0.00892857142857136*G5_0;
    A[677] = -0.00892857142857128*G5_0;
    A[678] = 0.026785714285714*G5_0;
    A[679] = 0.0178571428571429*G5_0;
    A[680] = 0.0;
    A[681] = 0.0;
    A[682] = 0.0;
    A[683] = 0.0;
    A[684] = 0.0;
    A[685] = 0.0;
    A[686] = 0.0;
    A[687] = 0.0;
    A[688] = 0.0;
    A[689] = 0.0;
    A[690] = 0.0;
    A[691] = 0.0;
    A[692] = 0.0;
    A[693] = 0.0;
    A[694] = 0.0;
    A[695] = 0.0566137566137562*G1_1_0 + 0.0566137566137558*G1_1_1 + 0.0566137566137562*G3_1_0 + 0.0566137566137558*G3_1_1;
    A[696] = -0.056613756613756*G1_1_0 - 0.056613756613756*G3_1_0;
    A[697] = 0.373015873015869*G1_1_1 + 0.373015873015869*G3_1_1;
    A[698] = 0.203174603174603*G1_1_0 - 0.0423280423280404*G1_1_1 + 0.203174603174603*G3_1_0 - 0.0423280423280404*G3_1_1;
    A[699] = -0.425396825396824*G1_1_0 + 0.0423280423280395*G1_1_1 - 0.425396825396824*G3_1_0 + 0.0423280423280395*G3_1_1;
    A[700] = 0.778835978835974*G1_1_0 + 0.126984126984127*G1_1_1 + 0.778835978835974*G3_1_0 + 0.126984126984127*G3_1_1;
    A[701] = -0.203174603174603*G1_1_0 - 0.245502645502643*G1_1_1 - 0.203174603174603*G3_1_0 - 0.245502645502643*G3_1_1;
    A[702] = 0.425396825396824*G1_1_0 + 0.467724867724864*G1_1_1 + 0.425396825396824*G3_1_0 + 0.467724867724864*G3_1_1;
    A[703] = -0.778835978835974*G1_1_0 - 0.651851851851846*G1_1_1 - 0.778835978835974*G3_1_0 - 0.651851851851846*G3_1_1;
    A[704] = 0.0423280423280405*G1_1_1 + 0.0423280423280405*G3_1_1;
    A[705] = 0.0423280423280419*G1_1_1 + 0.0423280423280419*G3_1_1;
    A[706] = 0.0423280423280421*G1_1_1 + 0.0423280423280421*G3_1_1;
    A[707] = -0.0846560846560818*G1_1_1 - 0.0846560846560818*G3_1_1;
    A[708] = -0.0846560846560844*G1_1_1 - 0.0846560846560844*G3_1_1;
    A[709] = -0.0846560846560848*G1_1_1 - 0.0846560846560848*G3_1_1;
    A[710] = 0.0;
    A[711] = 0.0;
    A[712] = 0.0420634920634918*G5_1;
    A[713] = -0.00892857142857123*G5_1;
    A[714] = 0.0267857142857139*G5_1;
    A[715] = -0.00892857142857122*G5_1;
    A[716] = 0.0267857142857139*G5_1;
    A[717] = -0.00892857142857123*G5_1;
    A[718] = -0.00892857142857126*G5_1;
    A[719] = 0.0178571428571428*G5_1;
    A[720] = 0.0;
    A[721] = 0.0;
    A[722] = 0.0;
    A[723] = 0.0;
    A[724] = 0.0;
    A[725] = 0.0;
    A[726] = 0.0;
    A[727] = 0.0;
    A[728] = 0.0;
    A[729] = 0.0;
    A[730] = 0.0;
    A[731] = 0.0;
    A[732] = 0.0;
    A[733] = 0.0;
    A[734] = 0.0;
    A[735] = 0.0423280423280401*G1_0_0 + 0.0423280423280384*G1_0_1 + 0.0423280423280398*G1_1_0 + 0.0423280423280365*G1_1_1 + 0.0423280423280401*G3_0_0 + 0.0423280423280384*G3_0_1 + 0.0423280423280398*G3_1_0 + 0.0423280423280365*G3_1_1;
    A[736] = 0.126984126984125*G1_0_0 + 0.778835978835973*G1_1_0 + 0.126984126984125*G3_0_0 + 0.778835978835973*G3_1_0;
    A[737] = 0.203174603174603*G1_0_1 - 0.0423280423280404*G1_1_1 + 0.203174603174603*G3_0_1 - 0.0423280423280404*G3_1_1;
    A[738] = 1.82857142857142*G1_0_0 + 1.04973544973544*G1_0_1 + 1.04973544973544*G1_1_0 + 2.09947089947089*G1_1_1 + 1.82857142857142*G3_0_0 + 1.04973544973544*G3_0_1 + 1.04973544973544*G3_1_0 + 2.09947089947089*G3_1_1;
    A[739] = -0.660317460317456*G1_0_0 + 0.821164021164016*G1_0_1 - 0.296296296296292*G1_1_0 - 0.761904761904758*G1_1_1 - 0.660317460317456*G3_0_0 + 0.821164021164016*G3_0_1 - 0.296296296296292*G3_1_0 - 0.761904761904758*G3_1_1;
    A[740] = 0.338624338624339*G1_0_0 - 0.440211640211639*G1_0_1 + 0.101587301587305*G1_1_0 + 0.338624338624338*G1_1_1 + 0.338624338624339*G3_0_0 - 0.440211640211639*G3_0_1 + 0.101587301587305*G3_1_0 + 0.338624338624338*G3_1_1;
    A[741] = -0.2031746031746*G1_0_0 - 0.101587301587295*G1_0_1 - 0.101587301587307*G1_1_0 - 0.2031746031746*G3_0_0 - 0.101587301587295*G3_0_1 - 0.101587301587307*G3_1_0;
    A[742] = -0.152380952380952*G1_0_0 - 0.0423280423280417*G1_0_1 - 0.0423280423280382*G1_1_0 - 0.152380952380952*G3_0_0 - 0.0423280423280417*G3_0_1 - 0.0423280423280382*G3_1_0;
    A[743] = -0.338624338624338*G1_0_0 - 0.101587301587297*G1_0_1 - 0.101587301587305*G1_1_0 - 0.338624338624338*G3_0_0 - 0.101587301587297*G3_0_1 - 0.101587301587305*G3_1_0;
    A[744] = -0.135449735449728*G1_0_0 - 0.237037037037036*G1_0_1 - 0.237037037037028*G1_1_0 - 0.338624338624342*G1_1_1 - 0.135449735449728*G3_0_0 - 0.237037037037036*G3_0_1 - 0.237037037037028*G3_1_0 - 0.338624338624342*G3_1_1;
    A[745] = 0.101587301587291*G1_0_0 + 0.46560846560846*G1_0_1 + 0.46560846560845*G1_1_0 + 0.761904761904754*G1_1_1 + 0.101587301587291*G3_0_0 + 0.46560846560846*G3_0_1 + 0.46560846560845*G3_1_0 + 0.761904761904754*G3_1_1;
    A[746] = -0.135449735449728*G1_0_0 - 1.04973544973544*G1_0_1 - 1.04973544973543*G1_1_0 - 2.09947089947088*G1_1_1 - 0.135449735449728*G3_0_0 - 1.04973544973544*G3_0_1 - 1.04973544973543*G3_1_0 - 2.09947089947088*G3_1_1;
    A[747] = 0.812698412698404*G1_0_0 + 0.338624338624331*G1_0_1 + 0.338624338624345*G1_1_0 + 0.812698412698404*G3_0_0 + 0.338624338624331*G3_0_1 + 0.338624338624345*G3_1_0;
    A[748] = -2.43809523809522*G1_0_0 - 1.28677248677248*G1_0_1 - 1.28677248677248*G1_1_0 - 2.43809523809522*G3_0_0 - 1.28677248677248*G3_0_1 - 1.28677248677248*G3_1_0;
    A[749] = 0.812698412698408*G1_0_0 + 0.338624338624331*G1_0_1 + 0.33862433862433*G1_1_0 - 1.48405593369816e-14*G1_1_1 + 0.812698412698408*G3_0_0 + 0.338624338624331*G3_0_1 + 0.33862433862433*G3_1_0 - 1.48405593369816e-14*G3_1_1;
    A[750] = 0.0158730158730159*G5_0 + 0.0158730158730161*G5_1;
    A[751] = 0.0222222222222221*G5_0 + 0.0952380952380947*G5_1;
    A[752] = 0.0317460317460316*G5_0 + 0.015873015873016*G5_1;
    A[753] = 0.228571428571427*G5_0 + 0.142857142857142*G5_1;
    A[754] = -0.0857142857142851*G5_0 - 0.0571428571428564*G5_1;
    A[755] = 0.0;
    A[756] = 0.0285714285714285*G5_0;
    A[757] = -0.0571428571428567*G5_0 - 0.0571428571428562*G5_1;
    A[758] = 0.114285714285714*G5_0 + 0.142857142857142*G5_1;
    A[759] = 0.057142857142857*G5_0 + 0.0571428571428573*G5_1;
    A[760] = 0.0;
    A[761] = 0.0;
    A[762] = 0.0;
    A[763] = 0.0;
    A[764] = 0.0;
    A[765] = 0.0;
    A[766] = 0.0;
    A[767] = 0.0;
    A[768] = 0.0;
    A[769] = 0.0;
    A[770] = 0.0;
    A[771] = 0.0;
    A[772] = 0.0;
    A[773] = 0.0;
    A[774] = 0.0;
    A[775] = 0.0423280423280398*G1_0_0 + 0.042328042328041*G1_0_1 + 0.0423280423280411*G1_1_0 + 0.0423280423280429*G1_1_1 + 0.0423280423280398*G3_0_0 + 0.042328042328041*G3_0_1 + 0.0423280423280411*G3_1_0 + 0.0423280423280429*G3_1_1;
    A[776] = 0.0423280423280426*G1_0_0 - 0.425396825396823*G1_1_0 + 0.0423280423280426*G3_0_0 - 0.425396825396823*G3_1_0;
    A[777] = -0.425396825396824*G1_0_1 + 0.0423280423280395*G1_1_1 - 0.425396825396824*G3_0_1 + 0.0423280423280395*G3_1_1;
    A[778] = -0.660317460317456*G1_0_0 - 0.296296296296292*G1_0_1 + 0.821164021164016*G1_1_0 - 0.761904761904758*G1_1_1 - 0.660317460317456*G3_0_0 - 0.296296296296292*G3_0_1 + 0.821164021164016*G3_1_0 - 0.761904761904758*G3_1_1;
    A[779] = 2.45079365079364*G1_0_0 + 0.971428571428565*G1_0_1 + 0.971428571428565*G1_1_0 + 2.45079365079364*G1_1_1 + 2.45079365079364*G3_0_0 + 0.971428571428565*G3_0_1 + 0.971428571428565*G3_1_0 + 2.45079365079364*G3_1_1;
    A[780] = -0.761904761904762*G1_0_0 + 0.821164021164015*G1_0_1 - 0.296296296296303*G1_1_0 - 0.660317460317464*G1_1_1 - 0.761904761904762*G3_0_0 + 0.821164021164015*G3_0_1 - 0.296296296296303*G3_1_0 - 0.660317460317464*G3_1_1;
    A[781] = -0.152380952380945*G1_0_0 - 0.110052910052907*G1_0_1 - 0.110052910052895*G1_1_0 - 0.0677248677248659*G1_1_1 - 0.152380952380945*G3_0_0 - 0.110052910052907*G3_0_1 - 0.110052910052895*G3_1_0 - 0.0677248677248659*G3_1_1;
    A[782] = 0.393650793650787*G1_0_0 + 0.196825396825396*G1_0_1 + 0.196825396825387*G1_1_0 + 0.0507936507936494*G1_1_1 + 0.393650793650787*G3_0_0 + 0.196825396825396*G3_0_1 + 0.196825396825387*G3_1_0 + 0.0507936507936494*G3_1_1;
    A[783] = 0.761904761904762*G1_0_0 + 0.296296296296296*G1_0_1 + 0.296296296296303*G1_1_0 - 0.0677248677248643*G1_1_1 + 0.761904761904762*G3_0_0 + 0.296296296296296*G3_0_1 + 0.296296296296303*G3_1_0 - 0.0677248677248643*G3_1_1;
    A[784] = -0.0677248677248635*G1_0_0 - 0.110052910052907*G1_0_1 - 0.110052910052907*G1_1_0 - 0.152380952380943*G1_1_1 - 0.0677248677248635*G3_0_0 - 0.110052910052907*G3_0_1 - 0.110052910052907*G3_1_0 - 0.152380952380943*G3_1_1;
    A[785] = 0.0507936507936499*G1_0_0 + 0.196825396825395*G1_0_1 + 0.196825396825395*G1_1_0 + 0.393650793650789*G1_1_1 + 0.0507936507936499*G3_0_0 + 0.196825396825395*G3_0_1 + 0.196825396825395*G3_1_0 + 0.393650793650789*G3_1_1;
    A[786] = -0.0677248677248686*G1_0_0 + 0.296296296296293*G1_0_1 + 0.296296296296294*G1_1_0 + 0.761904761904758*G1_1_1 - 0.0677248677248686*G3_0_0 + 0.296296296296293*G3_0_1 + 0.296296296296294*G3_1_0 + 0.761904761904758*G3_1_1;
    A[787] = 0.406349206349191*G1_0_0 + 0.45714285714284*G1_0_1 + 0.457142857142831*G1_1_0 + 0.40634920634918*G1_1_1 + 0.406349206349191*G3_0_0 + 0.45714285714284*G3_0_1 + 0.457142857142831*G3_1_0 + 0.40634920634918*G3_1_1;
    A[788] = 0.40634920634921*G1_0_0 - 1.16825396825396*G1_0_1 - 1.16825396825395*G1_1_0 - 2.84444444444442*G1_1_1 + 0.40634920634921*G3_0_0 - 1.16825396825396*G3_0_1 - 1.16825396825395*G3_1_0 - 2.84444444444442*G3_1_1;
    A[789] = -2.84444444444442*G1_0_0 - 1.16825396825395*G1_0_1 - 1.16825396825395*G1_1_0 + 0.406349206349223*G1_1_1 - 2.84444444444442*G3_0_0 - 1.16825396825395*G3_0_1 - 1.16825396825395*G3_1_0 + 0.406349206349223*G3_1_1;
    A[790] = 0.0103174603174602*G5_0 + 0.0103174603174599*G5_1;
    A[791] = -0.0150793650793649*G5_0 - 0.0619047619047617*G5_1;
    A[792] = -0.0619047619047617*G5_0 - 0.0150793650793653*G5_1;
    A[793] = 0.0285714285714287*G5_0 + 0.178571428571428*G5_1;
    A[794] = 0.178571428571427*G5_0 + 0.0285714285714275*G5_1;
    A[795] = -0.0285714285714281*G5_0 - 0.0285714285714287*G5_1;
    A[796] = -0.0500000000000002*G5_0 - 0.0285714285714289*G5_1;
    A[797] = -0.0285714285714284*G5_0 - 0.028571428571429*G5_1;
    A[798] = -0.0285714285714282*G5_0 - 0.0499999999999994*G5_1;
    A[799] = 0.128571428571428*G5_0 + 0.128571428571427*G5_1;
    A[800] = 0.0;
    A[801] = 0.0;
    A[802] = 0.0;
    A[803] = 0.0;
    A[804] = 0.0;
    A[805] = 0.0;
    A[806] = 0.0;
    A[807] = 0.0;
    A[808] = 0.0;
    A[809] = 0.0;
    A[810] = 0.0;
    A[811] = 0.0;
    A[812] = 0.0;
    A[813] = 0.0;
    A[814] = 0.0;
    A[815] = 0.0423280423280425*G1_0_0 + 0.0423280423280411*G1_0_1 + 0.0423280423280415*G1_1_0 + 0.0423280423280402*G1_1_1 + 0.0423280423280425*G3_0_0 + 0.0423280423280411*G3_0_1 + 0.0423280423280415*G3_1_0 + 0.0423280423280402*G3_1_1;
    A[816] = -0.0423280423280421*G1_0_0 + 0.203174603174601*G1_1_0 - 0.0423280423280421*G3_0_0 + 0.203174603174601*G3_1_0;
    A[817] = 0.778835978835974*G1_0_1 + 0.126984126984127*G1_1_1 + 0.778835978835974*G3_0_1 + 0.126984126984127*G3_1_1;
    A[818] = 0.338624338624339*G1_0_0 + 0.101587301587305*G1_0_1 - 0.440211640211639*G1_1_0 + 0.338624338624338*G1_1_1 + 0.338624338624339*G3_0_0 + 0.101587301587305*G3_0_1 - 0.440211640211639*G3_1_0 + 0.338624338624338*G3_1_1;
    A[819] = -0.761904761904762*G1_0_0 - 0.296296296296303*G1_0_1 + 0.821164021164014*G1_1_0 - 0.660317460317464*G1_1_1 - 0.761904761904762*G3_0_0 - 0.296296296296303*G3_0_1 + 0.821164021164014*G3_1_0 - 0.660317460317464*G3_1_1;
    A[820] = 2.0994708994709*G1_0_0 + 1.04973544973545*G1_0_1 + 1.04973544973545*G1_1_0 + 1.82857142857143*G1_1_1 + 2.0994708994709*G3_0_0 + 1.04973544973545*G3_0_1 + 1.04973544973545*G3_1_0 + 1.82857142857143*G3_1_1;
    A[821] = -0.338624338624339*G1_0_0 - 0.237037037037035*G1_0_1 - 0.237037037037037*G1_1_0 - 0.135449735449732*G1_1_1 - 0.338624338624339*G3_0_0 - 0.237037037037035*G3_0_1 - 0.237037037037037*G3_1_0 - 0.135449735449732*G3_1_1;
    A[822] = 0.761904761904763*G1_0_0 + 0.465608465608463*G1_0_1 + 0.465608465608471*G1_1_0 + 0.101587301587302*G1_1_1 + 0.761904761904763*G3_0_0 + 0.465608465608463*G3_0_1 + 0.465608465608471*G3_1_0 + 0.101587301587302*G3_1_1;
    A[823] = -2.0994708994709*G1_0_0 - 1.04973544973544*G1_0_1 - 1.04973544973545*G1_1_0 - 0.135449735449733*G1_1_1 - 2.0994708994709*G3_0_0 - 1.04973544973544*G3_0_1 - 1.04973544973545*G3_1_0 - 0.135449735449733*G3_1_1;
    A[824] = -0.101587301587304*G1_0_1 - 0.101587301587299*G1_1_0 - 0.203174603174605*G1_1_1 - 0.101587301587304*G3_0_1 - 0.101587301587299*G3_1_0 - 0.203174603174605*G3_1_1;
    A[825] = -0.0423280423280409*G1_0_1 - 0.0423280423280437*G1_1_0 - 0.15238095238095*G1_1_1 - 0.0423280423280409*G3_0_1 - 0.0423280423280437*G3_1_0 - 0.15238095238095*G3_1_1;
    A[826] = -0.101587301587297*G1_0_1 - 0.1015873015873*G1_1_0 - 0.338624338624331*G1_1_1 - 0.101587301587297*G3_0_1 - 0.1015873015873*G3_1_0 - 0.338624338624331*G3_1_1;
    A[827] = 0.338624338624343*G1_0_1 + 0.338624338624341*G1_1_0 + 0.812698412698416*G1_1_1 + 0.338624338624343*G3_0_1 + 0.338624338624341*G3_1_0 + 0.812698412698416*G3_1_1;
    A[828] = 0.338624338624334*G1_0_1 + 0.338624338624335*G1_1_0 + 0.812698412698405*G1_1_1 + 0.338624338624334*G3_0_1 + 0.338624338624335*G3_1_0 + 0.812698412698405*G3_1_1;
    A[829] = -1.28677248677249*G1_0_1 - 1.28677248677249*G1_1_0 - 2.43809523809524*G1_1_1 - 1.28677248677249*G3_0_1 - 1.28677248677249*G3_1_0 - 2.43809523809524*G3_1_1;
    A[830] = 0.0158730158730158*G5_0 + 0.0158730158730159*G5_1;
    A[831] = 0.0158730158730158*G5_0 + 0.0317460317460316*G5_1;
    A[832] = 0.0952380952380949*G5_0 + 0.0222222222222223*G5_1;
    A[833] = -0.057142857142857*G5_0 - 0.0857142857142858*G5_1;
    A[834] = 0.142857142857143*G5_0 + 0.228571428571428*G5_1;
    A[835] = -0.0571428571428571*G5_0 - 0.0571428571428572*G5_1;
    A[836] = 0.142857142857142*G5_0 + 0.114285714285714*G5_1;
    A[837] = 0.0;
    A[838] = 0.028571428571428*G5_1;
    A[839] = 0.0571428571428569*G5_0 + 0.0571428571428559*G5_1;
    A[840] = 0.0;
    A[841] = 0.0;
    A[842] = 0.0;
    A[843] = 0.0;
    A[844] = 0.0;
    A[845] = 0.0;
    A[846] = 0.0;
    A[847] = 0.0;
    A[848] = 0.0;
    A[849] = 0.0;
    A[850] = 0.0;
    A[851] = 0.0;
    A[852] = 0.0;
    A[853] = 0.0;
    A[854] = 0.0;
    A[855] = 0.126984126984129*G1_0_0 + 0.126984126984129*G1_0_1 - 0.65185185185185*G1_1_0 - 0.65185185185185*G1_1_1 + 0.126984126984129*G3_0_0 + 0.126984126984129*G3_0_1 - 0.65185185185185*G3_1_0 - 0.65185185185185*G3_1_1;
    A[856] = 0.0423280423280417*G1_0_0 + 0.0423280423280417*G3_0_0;
    A[857] = -0.203174603174603*G1_0_1 - 0.245502645502643*G1_1_1 - 0.203174603174603*G3_0_1 - 0.245502645502643*G3_1_1;
    A[858] = -0.2031746031746*G1_0_0 - 0.101587301587307*G1_0_1 - 0.101587301587295*G1_1_0 - 0.2031746031746*G3_0_0 - 0.101587301587307*G3_0_1 - 0.101587301587295*G3_1_0;
    A[859] = -0.152380952380945*G1_0_0 - 0.110052910052895*G1_0_1 - 0.110052910052907*G1_1_0 - 0.0677248677248659*G1_1_1 - 0.152380952380945*G3_0_0 - 0.110052910052895*G3_0_1 - 0.110052910052907*G3_1_0 - 0.0677248677248659*G3_1_1;
    A[860] = -0.338624338624339*G1_0_0 - 0.237037037037037*G1_0_1 - 0.237037037037035*G1_1_0 - 0.135449735449732*G1_1_1 - 0.338624338624339*G3_0_0 - 0.237037037037037*G3_0_1 - 0.237037037037035*G3_1_0 - 0.135449735449732*G3_1_1;
    A[861] = 1.82857142857142*G1_0_0 + 0.778835978835975*G1_0_1 + 0.778835978835975*G1_1_0 + 1.82857142857142*G1_1_1 + 1.82857142857142*G3_0_0 + 0.778835978835975*G3_0_1 + 0.778835978835975*G3_1_0 + 1.82857142857142*G3_1_1;
    A[862] = -0.660317460317451*G1_0_0 - 1.48148148148148*G1_0_1 - 0.364021164021161*G1_1_0 - 1.94708994708993*G1_1_1 - 0.660317460317451*G3_0_0 - 1.48148148148148*G3_0_1 - 0.364021164021161*G3_1_0 - 1.94708994708993*G3_1_1;
    A[863] = 0.338624338624339*G1_0_0 + 0.778835978835972*G1_0_1 + 0.237037037037035*G1_1_0 + 1.01587301587301*G1_1_1 + 0.338624338624339*G3_0_0 + 0.778835978835972*G3_0_1 + 0.237037037037035*G3_1_0 + 1.01587301587301*G3_1_1;
    A[864] = -0.135449735449741*G1_0_0 + 0.91428571428571*G1_0_1 + 0.914285714285714*G1_1_0 - 0.135449735449734*G1_1_1 - 0.135449735449741*G3_0_0 + 0.91428571428571*G3_0_1 + 0.914285714285714*G3_1_0 - 0.135449735449734*G3_1_1;
    A[865] = 0.101587301587306*G1_0_0 - 0.364021164021163*G1_0_1 - 0.364021164021164*G1_1_0 - 0.0677248677248649*G1_1_1 + 0.101587301587306*G3_0_0 - 0.364021164021163*G3_0_1 - 0.364021164021164*G3_1_0 - 0.0677248677248649*G3_1_1;
    A[866] = -0.135449735449735*G1_0_0 + 0.1015873015873*G1_0_1 + 0.1015873015873*G1_1_0 - 0.135449735449735*G3_0_0 + 0.1015873015873*G3_0_1 + 0.1015873015873*G3_1_0;
    A[867] = -2.43809523809524*G1_0_0 - 1.15132275132274*G1_0_1 - 1.15132275132274*G1_1_0 + 0.135449735449735*G1_1_1 - 2.43809523809524*G3_0_0 - 1.15132275132274*G3_0_1 - 1.15132275132274*G3_1_0 + 0.135449735449735*G3_1_1;
    A[868] = 0.812698412698413*G1_0_0 + 0.474074074074065*G1_0_1 + 0.474074074074063*G1_1_0 + 0.13544973544973*G1_1_1 + 0.812698412698413*G3_0_0 + 0.474074074074065*G3_0_1 + 0.474074074074063*G3_1_0 + 0.13544973544973*G3_1_1;
    A[869] = 0.812698412698396*G1_0_0 + 0.474074074074073*G1_0_1 + 0.474074074074068*G1_1_0 + 0.13544973544973*G1_1_1 + 0.812698412698396*G3_0_0 + 0.474074074074073*G3_0_1 + 0.474074074074068*G3_1_0 + 0.13544973544973*G3_1_1;
    A[870] = -0.022222222222222*G5_0 + 0.0730158730158728*G5_1;
    A[871] = -0.015873015873016*G5_0;
    A[872] = -0.0317460317460317*G5_0 - 0.0158730158730158*G5_1;
    A[873] = 0.0;
    A[874] = -0.0285714285714281*G5_0 - 0.0285714285714281*G5_1;
    A[875] = -0.228571428571428*G5_0 - 0.0857142857142856*G5_1;
    A[876] = 0.0857142857142849*G5_0 + 0.0285714285714285*G5_1;
    A[877] = -0.114285714285714*G5_0 + 0.028571428571428*G5_1;
    A[878] = 0.0571428571428573*G5_0;
    A[879] = -0.0571428571428568*G5_0;
    A[880] = 0.0;
    A[881] = 0.0;
    A[882] = 0.0;
    A[883] = 0.0;
    A[884] = 0.0;
    A[885] = 0.0;
    A[886] = 0.0;
    A[887] = 0.0;
    A[888] = 0.0;
    A[889] = 0.0;
    A[890] = 0.0;
    A[891] = 0.0;
    A[892] = 0.0;
    A[893] = 0.0;
    A[894] = 0.0;
    A[895] = 0.0423280423280408*G1_0_0 + 0.0423280423280424*G1_0_1 + 0.467724867724864*G1_1_0 + 0.467724867724864*G1_1_1 + 0.0423280423280408*G3_0_0 + 0.0423280423280424*G3_0_1 + 0.467724867724864*G3_1_0 + 0.467724867724864*G3_1_1;
    A[896] = 0.0423280423280418*G1_0_0 + 0.0423280423280418*G3_0_0;
    A[897] = 0.425396825396824*G1_0_1 + 0.467724867724864*G1_1_1 + 0.425396825396824*G3_0_1 + 0.467724867724864*G3_1_1;
    A[898] = -0.152380952380952*G1_0_0 - 0.0423280423280382*G1_0_1 - 0.0423280423280417*G1_1_0 - 0.152380952380952*G3_0_0 - 0.0423280423280382*G3_0_1 - 0.0423280423280417*G3_1_0;
    A[899] = 0.393650793650787*G1_0_0 + 0.196825396825387*G1_0_1 + 0.196825396825396*G1_1_0 + 0.0507936507936493*G1_1_1 + 0.393650793650787*G3_0_0 + 0.196825396825387*G3_0_1 + 0.196825396825396*G3_1_0 + 0.0507936507936493*G3_1_1;
    A[900] = 0.761904761904763*G1_0_0 + 0.465608465608471*G1_0_1 + 0.465608465608463*G1_1_0 + 0.101587301587302*G1_1_1 + 0.761904761904763*G3_0_0 + 0.465608465608471*G3_0_1 + 0.465608465608463*G3_1_0 + 0.101587301587302*G3_1_1;
    A[901] = -0.660317460317451*G1_0_0 - 0.364021164021161*G1_0_1 - 1.48148148148148*G1_1_0 - 1.94708994708993*G1_1_1 - 0.660317460317451*G3_0_0 - 0.364021164021161*G3_0_1 - 1.48148148148148*G3_1_0 - 1.94708994708993*G3_1_1;
    A[902] = 2.45079365079363*G1_0_0 + 1.47936507936507*G1_0_1 + 1.47936507936507*G1_1_0 + 2.95873015873014*G1_1_1 + 2.45079365079363*G3_0_0 + 1.47936507936507*G3_0_1 + 1.47936507936507*G3_1_0 + 2.95873015873014*G3_1_1;
    A[903] = -0.761904761904763*G1_0_0 - 1.58306878306878*G1_0_1 - 0.465608465608463*G1_1_0 - 1.94708994708993*G1_1_1 - 0.761904761904763*G3_0_0 - 1.58306878306878*G3_0_1 - 0.465608465608463*G3_1_0 - 1.94708994708993*G3_1_1;
    A[904] = -0.0677248677248641*G1_0_0 - 0.364021164021158*G1_0_1 - 0.364021164021163*G1_1_0 + 0.101587301587296*G1_1_1 - 0.0677248677248641*G3_0_0 - 0.364021164021158*G3_0_1 - 0.364021164021163*G3_1_0 + 0.101587301587296*G3_1_1;
    A[905] = 0.0507936507936485*G1_0_0 - 0.146031746031747*G1_0_1 - 0.146031746031744*G1_1_0 + 0.0507936507936494*G1_1_1 + 0.0507936507936485*G3_0_0 - 0.146031746031747*G3_0_1 - 0.146031746031744*G3_1_0 + 0.0507936507936494*G3_1_1;
    A[906] = -0.067724867724867*G1_0_0 + 0.0423280423280398*G1_0_1 + 0.042328042328042*G1_1_0 - 0.067724867724867*G3_0_0 + 0.0423280423280398*G3_0_1 + 0.042328042328042*G3_1_0;
    A[907] = 0.406349206349195*G1_0_0 + 1.57460317460316*G1_0_1 + 1.57460317460317*G1_1_0 - 0.101587301587297*G1_1_1 + 0.406349206349195*G3_0_0 + 1.57460317460316*G3_0_1 + 1.57460317460317*G3_1_0 - 0.101587301587297*G3_1_1;
    A[908] = 0.406349206349209*G1_0_0 - 0.0507936507936406*G1_0_1 - 0.0507936507936498*G1_1_0 - 0.1015873015873*G1_1_1 + 0.406349206349209*G3_0_0 - 0.0507936507936406*G3_0_1 - 0.0507936507936498*G3_1_0 - 0.1015873015873*G3_1_1;
    A[909] = -2.84444444444442*G1_0_0 - 1.67619047619047*G1_0_1 - 1.67619047619047*G1_1_0 - 0.101587301587299*G1_1_1 - 2.84444444444442*G3_0_0 - 1.67619047619047*G3_0_1 - 1.67619047619047*G3_1_0 - 0.101587301587299*G3_1_1;
    A[910] = 0.0150793650793649*G5_0 - 0.0468253968253965*G5_1;
    A[911] = -0.0103174603174602*G5_0;
    A[912] = 0.0619047619047617*G5_0 + 0.0468253968253966*G5_1;
    A[913] = 0.0285714285714279*G5_0;
    A[914] = 0.0499999999999999*G5_0 + 0.0214285714285709*G5_1;
    A[915] = -0.0285714285714284*G5_0 + 0.15*G5_1;
    A[916] = -0.178571428571427*G5_0 - 0.15*G5_1;
    A[917] = 0.0285714285714284*G5_0 - 0.0214285714285706*G5_1;
    A[918] = 0.0285714285714283*G5_0;
    A[919] = -0.128571428571428*G5_0;
    A[920] = 0.0;
    A[921] = 0.0;
    A[922] = 0.0;
    A[923] = 0.0;
    A[924] = 0.0;
    A[925] = 0.0;
    A[926] = 0.0;
    A[927] = 0.0;
    A[928] = 0.0;
    A[929] = 0.0;
    A[930] = 0.0;
    A[931] = 0.0;
    A[932] = 0.0;
    A[933] = 0.0;
    A[934] = 0.0;
    A[935] = -0.0423280423280424*G1_0_0 - 0.042328042328041*G1_0_1 - 0.245502645502644*G1_1_0 - 0.245502645502644*G1_1_1 - 0.0423280423280424*G3_0_0 - 0.042328042328041*G3_0_1 - 0.245502645502644*G3_1_0 - 0.245502645502644*G3_1_1;
    A[936] = 0.0423280423280421*G1_0_0 + 0.0423280423280421*G3_0_0;
    A[937] = -0.778835978835974*G1_0_1 - 0.651851851851846*G1_1_1 - 0.778835978835974*G3_0_1 - 0.651851851851846*G3_1_1;
    A[938] = -0.338624338624338*G1_0_0 - 0.101587301587305*G1_0_1 - 0.101587301587297*G1_1_0 - 0.338624338624338*G3_0_0 - 0.101587301587305*G3_0_1 - 0.101587301587297*G3_1_0;
    A[939] = 0.761904761904762*G1_0_0 + 0.296296296296303*G1_0_1 + 0.296296296296296*G1_1_0 - 0.0677248677248643*G1_1_1 + 0.761904761904762*G3_0_0 + 0.296296296296303*G3_0_1 + 0.296296296296296*G3_1_0 - 0.0677248677248643*G3_1_1;
    A[940] = -2.0994708994709*G1_0_0 - 1.04973544973545*G1_0_1 - 1.04973544973544*G1_1_0 - 0.135449735449733*G1_1_1 - 2.0994708994709*G3_0_0 - 1.04973544973545*G3_0_1 - 1.04973544973544*G3_1_0 - 0.135449735449733*G3_1_1;
    A[941] = 0.338624338624339*G1_0_0 + 0.237037037037035*G1_0_1 + 0.778835978835972*G1_1_0 + 1.01587301587301*G1_1_1 + 0.338624338624339*G3_0_0 + 0.237037037037035*G3_0_1 + 0.778835978835972*G3_1_0 + 1.01587301587301*G3_1_1;
    A[942] = -0.761904761904763*G1_0_0 - 0.465608465608463*G1_0_1 - 1.58306878306878*G1_1_0 - 1.94708994708993*G1_1_1 - 0.761904761904763*G3_0_0 - 0.465608465608463*G3_0_1 - 1.58306878306878*G3_1_0 - 1.94708994708993*G3_1_1;
    A[943] = 2.0994708994709*G1_0_0 + 1.04973544973544*G1_0_1 + 1.04973544973544*G1_1_0 + 1.82857142857142*G1_1_1 + 2.0994708994709*G3_0_0 + 1.04973544973544*G3_0_1 + 1.04973544973544*G3_1_0 + 1.82857142857142*G3_1_1;
    A[944] = 0.101587301587304*G1_0_1 + 0.101587301587301*G1_1_0 - 0.135449735449736*G1_1_1 + 0.101587301587304*G3_0_1 + 0.101587301587301*G3_1_0 - 0.135449735449736*G3_1_1;
    A[945] = 0.0423280423280408*G1_0_1 + 0.0423280423280422*G1_1_0 - 0.0677248677248679*G1_1_1 + 0.0423280423280408*G3_0_1 + 0.0423280423280422*G3_1_0 - 0.0677248677248679*G3_1_1;
    A[946] = 0.101587301587297*G1_0_1 + 0.1015873015873*G1_1_0 + 0.101587301587297*G3_0_1 + 0.1015873015873*G3_1_0;
    A[947] = -0.338624338624344*G1_0_1 - 0.338624338624336*G1_1_0 + 0.135449735449733*G1_1_1 - 0.338624338624344*G3_0_1 - 0.338624338624336*G3_1_0 + 0.135449735449733*G3_1_1;
    A[948] = -0.338624338624334*G1_0_1 - 0.338624338624339*G1_1_0 + 0.135449735449735*G1_1_1 - 0.338624338624334*G3_0_1 - 0.338624338624339*G3_1_0 + 0.135449735449735*G3_1_1;
    A[949] = 1.28677248677249*G1_0_1 + 1.28677248677248*G1_1_0 + 0.135449735449734*G1_1_1 + 1.28677248677249*G3_0_1 + 1.28677248677248*G3_1_0 + 0.135449735449734*G3_1_1;
    A[950] = -0.0158730158730158*G5_0 + 0.0158730158730159*G5_1;
    A[951] = -0.0158730158730158*G5_0;
    A[952] = -0.0952380952380949*G5_0 - 0.0730158730158724*G5_1;
    A[953] = 0.0571428571428571*G5_0;
    A[954] = -0.142857142857143*G5_0 - 0.0285714285714277*G5_1;
    A[955] = 0.057142857142857*G5_0 - 0.0285714285714286*G5_1;
    A[956] = -0.142857142857142*G5_0 + 0.0857142857142862*G5_1;
    A[957] = 0.0285714285714283*G5_1;
    A[958] = 0.0;
    A[959] = -0.0571428571428567*G5_0;
    A[960] = 0.0;
    A[961] = 0.0;
    A[962] = 0.0;
    A[963] = 0.0;
    A[964] = 0.0;
    A[965] = 0.0;
    A[966] = 0.0;
    A[967] = 0.0;
    A[968] = 0.0;
    A[969] = 0.0;
    A[970] = 0.0;
    A[971] = 0.0;
    A[972] = 0.0;
    A[973] = 0.0;
    A[974] = 0.0;
    A[975] = -0.651851851851853*G1_0_0 - 0.651851851851852*G1_0_1 + 0.126984126984128*G1_1_0 + 0.126984126984128*G1_1_1 - 0.651851851851853*G3_0_0 - 0.651851851851852*G3_0_1 + 0.126984126984128*G3_1_0 + 0.126984126984128*G3_1_1;
    A[976] = -0.245502645502643*G1_0_0 - 0.203174603174602*G1_1_0 - 0.245502645502643*G3_0_0 - 0.203174603174602*G3_1_0;
    A[977] = 0.0423280423280404*G1_1_1 + 0.0423280423280404*G3_1_1;
    A[978] = -0.135449735449728*G1_0_0 - 0.237037037037028*G1_0_1 - 0.237037037037036*G1_1_0 - 0.338624338624342*G1_1_1 - 0.135449735449728*G3_0_0 - 0.237037037037028*G3_0_1 - 0.237037037037036*G3_1_0 - 0.338624338624342*G3_1_1;
    A[979] = -0.0677248677248635*G1_0_0 - 0.110052910052907*G1_0_1 - 0.110052910052907*G1_1_0 - 0.152380952380943*G1_1_1 - 0.0677248677248635*G3_0_0 - 0.110052910052907*G3_0_1 - 0.110052910052907*G3_1_0 - 0.152380952380943*G3_1_1;
    A[980] = -0.101587301587299*G1_0_1 - 0.101587301587304*G1_1_0 - 0.203174603174605*G1_1_1 - 0.101587301587299*G3_0_1 - 0.101587301587304*G3_1_0 - 0.203174603174605*G3_1_1;
    A[981] = -0.135449735449741*G1_0_0 + 0.914285714285714*G1_0_1 + 0.91428571428571*G1_1_0 - 0.135449735449734*G1_1_1 - 0.135449735449741*G3_0_0 + 0.914285714285714*G3_0_1 + 0.91428571428571*G3_1_0 - 0.135449735449734*G3_1_1;
    A[982] = -0.0677248677248641*G1_0_0 - 0.364021164021163*G1_0_1 - 0.364021164021158*G1_1_0 + 0.101587301587296*G1_1_1 - 0.0677248677248641*G3_0_0 - 0.364021164021163*G3_0_1 - 0.364021164021158*G3_1_0 + 0.101587301587296*G3_1_1;
    A[983] = 0.101587301587301*G1_0_1 + 0.101587301587304*G1_1_0 - 0.135449735449736*G1_1_1 + 0.101587301587301*G3_0_1 + 0.101587301587304*G3_1_0 - 0.135449735449736*G3_1_1;
    A[984] = 1.82857142857142*G1_0_0 + 0.778835978835969*G1_0_1 + 0.778835978835969*G1_1_0 + 1.82857142857142*G1_1_1 + 1.82857142857142*G3_0_0 + 0.778835978835969*G3_0_1 + 0.778835978835969*G3_1_0 + 1.82857142857142*G3_1_1;
    A[985] = -1.94708994708994*G1_0_0 - 0.364021164021158*G1_0_1 - 1.48148148148147*G1_1_0 - 0.660317460317451*G1_1_1 - 1.94708994708994*G3_0_0 - 0.364021164021158*G3_0_1 - 1.48148148148147*G3_1_0 - 0.660317460317451*G3_1_1;
    A[986] = 1.01587301587301*G1_0_0 + 0.23703703703703*G1_0_1 + 0.778835978835972*G1_1_0 + 0.338624338624335*G1_1_1 + 1.01587301587301*G3_0_0 + 0.23703703703703*G3_0_1 + 0.778835978835972*G3_1_0 + 0.338624338624335*G3_1_1;
    A[987] = 0.135449735449745*G1_0_0 - 1.15132275132274*G1_0_1 - 1.15132275132275*G1_1_0 - 2.43809523809522*G1_1_1 + 0.135449735449745*G3_0_0 - 1.15132275132274*G3_0_1 - 1.15132275132275*G3_1_0 - 2.43809523809522*G3_1_1;
    A[988] = 0.135449735449723*G1_0_0 + 0.474074074074061*G1_0_1 + 0.474074074074071*G1_1_0 + 0.812698412698398*G1_1_1 + 0.135449735449723*G3_0_0 + 0.474074074074061*G3_0_1 + 0.474074074074071*G3_1_0 + 0.812698412698398*G3_1_1;
    A[989] = 0.135449735449728*G1_0_0 + 0.474074074074069*G1_0_1 + 0.474074074074065*G1_1_0 + 0.812698412698416*G1_1_1 + 0.135449735449728*G3_0_0 + 0.474074074074069*G3_0_1 + 0.474074074074065*G3_1_0 + 0.812698412698416*G3_1_1;
    A[990] = 0.0730158730158731*G5_0 - 0.0222222222222219*G5_1;
    A[991] = -0.0158730158730156*G5_0 - 0.0317460317460316*G5_1;
    A[992] = -0.0158730158730159*G5_1;
    A[993] = -0.0285714285714273*G5_0 - 0.028571428571428*G5_1;
    A[994] = 0.0;
    A[995] = 0.0285714285714288*G5_0 - 0.114285714285714*G5_1;
    A[996] = 0.0571428571428565*G5_1;
    A[997] = -0.0857142857142849*G5_0 - 0.228571428571428*G5_1;
    A[998] = 0.0285714285714286*G5_0 + 0.0857142857142849*G5_1;
    A[999] = -0.0571428571428582*G5_1;
    A[1000] = 0.0;
    A[1001] = 0.0;
    A[1002] = 0.0;
    A[1003] = 0.0;
    A[1004] = 0.0;
    A[1005] = 0.0;
    A[1006] = 0.0;
    A[1007] = 0.0;
    A[1008] = 0.0;
    A[1009] = 0.0;
    A[1010] = 0.0;
    A[1011] = 0.0;
    A[1012] = 0.0;
    A[1013] = 0.0;
    A[1014] = 0.0;
    A[1015] = 0.467724867724868*G1_0_0 + 0.467724867724867*G1_0_1 + 0.0423280423280411*G1_1_0 + 0.0423280423280401*G1_1_1 + 0.467724867724868*G3_0_0 + 0.467724867724867*G3_0_1 + 0.0423280423280411*G3_1_0 + 0.0423280423280401*G3_1_1;
    A[1016] = 0.467724867724862*G1_0_0 + 0.425396825396821*G1_1_0 + 0.467724867724862*G3_0_0 + 0.425396825396821*G3_1_0;
    A[1017] = 0.0423280423280419*G1_1_1 + 0.0423280423280419*G3_1_1;
    A[1018] = 0.101587301587291*G1_0_0 + 0.46560846560845*G1_0_1 + 0.46560846560846*G1_1_0 + 0.761904761904754*G1_1_1 + 0.101587301587291*G3_0_0 + 0.46560846560845*G3_0_1 + 0.46560846560846*G3_1_0 + 0.761904761904754*G3_1_1;
    A[1019] = 0.0507936507936499*G1_0_0 + 0.196825396825395*G1_0_1 + 0.196825396825395*G1_1_0 + 0.393650793650789*G1_1_1 + 0.0507936507936499*G3_0_0 + 0.196825396825395*G3_0_1 + 0.196825396825395*G3_1_0 + 0.393650793650789*G3_1_1;
    A[1020] = -0.0423280423280437*G1_0_1 - 0.0423280423280409*G1_1_0 - 0.15238095238095*G1_1_1 - 0.0423280423280437*G3_0_1 - 0.0423280423280409*G3_1_0 - 0.15238095238095*G3_1_1;
    A[1021] = 0.101587301587306*G1_0_0 - 0.364021164021164*G1_0_1 - 0.364021164021163*G1_1_0 - 0.0677248677248649*G1_1_1 + 0.101587301587306*G3_0_0 - 0.364021164021164*G3_0_1 - 0.364021164021163*G3_1_0 - 0.0677248677248649*G3_1_1;
    A[1022] = 0.0507936507936485*G1_0_0 - 0.146031746031744*G1_0_1 - 0.146031746031747*G1_1_0 + 0.0507936507936494*G1_1_1 + 0.0507936507936485*G3_0_0 - 0.146031746031744*G3_0_1 - 0.146031746031747*G3_1_0 + 0.0507936507936494*G3_1_1;
    A[1023] = 0.0423280423280423*G1_0_1 + 0.0423280423280408*G1_1_0 - 0.067724867724868*G1_1_1 + 0.0423280423280423*G3_0_1 + 0.0423280423280408*G3_1_0 - 0.067724867724868*G3_1_1;
    A[1024] = -1.94708994708994*G1_0_0 - 1.48148148148147*G1_0_1 - 0.364021164021158*G1_1_0 - 0.660317460317451*G1_1_1 - 1.94708994708994*G3_0_0 - 1.48148148148147*G3_0_1 - 0.364021164021158*G3_1_0 - 0.660317460317451*G3_1_1;
    A[1025] = 2.95873015873014*G1_0_0 + 1.47936507936507*G1_0_1 + 1.47936507936507*G1_1_0 + 2.45079365079364*G1_1_1 + 2.95873015873014*G3_0_0 + 1.47936507936507*G3_0_1 + 1.47936507936507*G3_1_0 + 2.45079365079364*G3_1_1;
    A[1026] = -1.94708994708993*G1_0_0 - 0.465608465608452*G1_0_1 - 1.58306878306877*G1_1_0 - 0.761904761904755*G1_1_1 - 1.94708994708993*G3_0_0 - 0.465608465608452*G3_0_1 - 1.58306878306877*G3_1_0 - 0.761904761904755*G3_1_1;
    A[1027] = -0.10158730158731*G1_0_0 + 1.57460317460316*G1_0_1 + 1.57460317460317*G1_1_0 + 0.406349206349191*G1_1_1 - 0.10158730158731*G3_0_0 + 1.57460317460316*G3_0_1 + 1.57460317460317*G3_1_0 + 0.406349206349191*G3_1_1;
    A[1028] = -0.101587301587287*G1_0_0 - 1.67619047619046*G1_0_1 - 1.67619047619047*G1_1_0 - 2.84444444444443*G1_1_1 - 0.101587301587287*G3_0_0 - 1.67619047619046*G3_0_1 - 1.67619047619047*G3_1_0 - 2.84444444444443*G3_1_1;
    A[1029] = -0.101587301587299*G1_0_0 - 0.0507936507936495*G1_0_1 - 0.0507936507936477*G1_1_0 + 0.40634920634921*G1_1_1 - 0.101587301587299*G3_0_0 - 0.0507936507936495*G3_0_1 - 0.0507936507936477*G3_1_0 + 0.40634920634921*G3_1_1;
    A[1030] = -0.0468253968253971*G5_0 + 0.0150793650793649*G5_1;
    A[1031] = 0.0468253968253961*G5_0 + 0.0619047619047615*G5_1;
    A[1032] = -0.0103174603174603*G5_1;
    A[1033] = 0.0214285714285699*G5_0 + 0.0499999999999991*G5_1;
    A[1034] = 0.0285714285714287*G5_1;
    A[1035] = -0.0214285714285716*G5_0 + 0.0285714285714285*G5_1;
    A[1036] = 0.0285714285714287*G5_1;
    A[1037] = 0.149999999999999*G5_0 - 0.0285714285714283*G5_1;
    A[1038] = -0.15*G5_0 - 0.178571428571428*G5_1;
    A[1039] = -0.128571428571428*G5_1;
    A[1040] = 0.0;
    A[1041] = 0.0;
    A[1042] = 0.0;
    A[1043] = 0.0;
    A[1044] = 0.0;
    A[1045] = 0.0;
    A[1046] = 0.0;
    A[1047] = 0.0;
    A[1048] = 0.0;
    A[1049] = 0.0;
    A[1050] = 0.0;
    A[1051] = 0.0;
    A[1052] = 0.0;
    A[1053] = 0.0;
    A[1054] = 0.0;
    A[1055] = -0.245502645502645*G1_0_0 - 0.245502645502644*G1_0_1 - 0.0423280423280423*G1_1_0 - 0.042328042328039*G1_1_1 - 0.245502645502645*G3_0_0 - 0.245502645502644*G3_0_1 - 0.0423280423280423*G3_1_0 - 0.042328042328039*G3_1_1;
    A[1056] = -0.651851851851845*G1_0_0 - 0.778835978835971*G1_1_0 - 0.651851851851845*G3_0_0 - 0.778835978835971*G3_1_0;
    A[1057] = 0.0423280423280421*G1_1_1 + 0.0423280423280421*G3_1_1;
    A[1058] = -0.135449735449728*G1_0_0 - 1.04973544973543*G1_0_1 - 1.04973544973544*G1_1_0 - 2.09947089947088*G1_1_1 - 0.135449735449728*G3_0_0 - 1.04973544973543*G3_0_1 - 1.04973544973544*G3_1_0 - 2.09947089947088*G3_1_1;
    A[1059] = -0.0677248677248686*G1_0_0 + 0.296296296296294*G1_0_1 + 0.296296296296293*G1_1_0 + 0.761904761904758*G1_1_1 - 0.0677248677248686*G3_0_0 + 0.296296296296294*G3_0_1 + 0.296296296296293*G3_1_0 + 0.761904761904758*G3_1_1;
    A[1060] = -0.1015873015873*G1_0_1 - 0.101587301587297*G1_1_0 - 0.338624338624331*G1_1_1 - 0.1015873015873*G3_0_1 - 0.101587301587297*G3_1_0 - 0.338624338624331*G3_1_1;
    A[1061] = -0.135449735449735*G1_0_0 + 0.1015873015873*G1_0_1 + 0.1015873015873*G1_1_0 - 0.135449735449735*G3_0_0 + 0.1015873015873*G3_0_1 + 0.1015873015873*G3_1_0;
    A[1062] = -0.067724867724867*G1_0_0 + 0.0423280423280421*G1_0_1 + 0.0423280423280398*G1_1_0 - 0.067724867724867*G3_0_0 + 0.0423280423280421*G3_0_1 + 0.0423280423280398*G3_1_0;
    A[1063] = 0.1015873015873*G1_0_1 + 0.101587301587297*G1_1_0 + 0.1015873015873*G3_0_1 + 0.101587301587297*G3_1_0;
    A[1064] = 1.01587301587301*G1_0_0 + 0.778835978835972*G1_0_1 + 0.23703703703703*G1_1_0 + 0.338624338624335*G1_1_1 + 1.01587301587301*G3_0_0 + 0.778835978835972*G3_0_1 + 0.23703703703703*G3_1_0 + 0.338624338624335*G3_1_1;
    A[1065] = -1.94708994708993*G1_0_0 - 1.58306878306877*G1_0_1 - 0.465608465608452*G1_1_0 - 0.761904761904755*G1_1_1 - 1.94708994708993*G3_0_0 - 1.58306878306877*G3_0_1 - 0.465608465608452*G3_1_0 - 0.761904761904755*G3_1_1;
    A[1066] = 1.82857142857141*G1_0_0 + 1.04973544973543*G1_0_1 + 1.04973544973543*G1_1_0 + 2.09947089947087*G1_1_1 + 1.82857142857141*G3_0_0 + 1.04973544973543*G3_0_1 + 1.04973544973543*G3_1_0 + 2.09947089947087*G3_1_1;
    A[1067] = 0.135449735449738*G1_0_0 - 0.33862433862433*G1_0_1 - 0.338624338624342*G1_1_0 + 0.135449735449738*G3_0_0 - 0.33862433862433*G3_0_1 - 0.338624338624342*G3_1_0;
    A[1068] = 0.135449735449726*G1_0_0 + 1.28677248677247*G1_0_1 + 1.28677248677248*G1_1_0 + 0.135449735449726*G3_0_0 + 1.28677248677247*G3_0_1 + 1.28677248677248*G3_1_0;
    A[1069] = 0.135449735449736*G1_0_0 - 0.338624338624337*G1_0_1 - 0.338624338624333*G1_1_0 + 1.024484316825e-14*G1_1_1 + 0.135449735449736*G3_0_0 - 0.338624338624337*G3_0_1 - 0.338624338624333*G3_1_0 + 1.024484316825e-14*G3_1_1;
    A[1070] = 0.015873015873016*G5_0 - 0.0158730158730157*G5_1;
    A[1071] = -0.0730158730158723*G5_0 - 0.0952380952380944*G5_1;
    A[1072] = -0.0158730158730156*G5_1;
    A[1073] = -0.0285714285714276*G5_0 - 0.142857142857141*G5_1;
    A[1074] = 0.0571428571428571*G5_1;
    A[1075] = 0.0285714285714285*G5_0;
    A[1076] = 0.0;
    A[1077] = -0.0285714285714288*G5_0 + 0.0571428571428568*G5_1;
    A[1078] = 0.0857142857142859*G5_0 - 0.142857142857141*G5_1;
    A[1079] = -0.0571428571428546*G5_1;
    A[1080] = 0.0;
    A[1081] = 0.0;
    A[1082] = 0.0;
    A[1083] = 0.0;
    A[1084] = 0.0;
    A[1085] = 0.0;
    A[1086] = 0.0;
    A[1087] = 0.0;
    A[1088] = 0.0;
    A[1089] = 0.0;
    A[1090] = 0.0;
    A[1091] = 0.0;
    A[1092] = 0.0;
    A[1093] = 0.0;
    A[1094] = 0.0;
    A[1095] = -0.0846560846560892*G1_0_0 - 0.0846560846560894*G1_0_1 - 0.0846560846560886*G1_1_0 - 0.0846560846560862*G1_1_1 - 0.0846560846560892*G3_0_0 - 0.0846560846560894*G3_0_1 - 0.0846560846560886*G3_1_0 - 0.0846560846560862*G3_1_1;
    A[1096] = -0.0846560846560834*G1_0_0 - 0.0846560846560834*G3_0_0;
    A[1097] = -0.0846560846560818*G1_1_1 - 0.0846560846560818*G3_1_1;
    A[1098] = 0.812698412698404*G1_0_0 + 0.338624338624345*G1_0_1 + 0.338624338624331*G1_1_0 + 0.812698412698404*G3_0_0 + 0.338624338624345*G3_0_1 + 0.338624338624331*G3_1_0;
    A[1099] = 0.406349206349191*G1_0_0 + 0.457142857142831*G1_0_1 + 0.45714285714284*G1_1_0 + 0.40634920634918*G1_1_1 + 0.406349206349191*G3_0_0 + 0.457142857142831*G3_0_1 + 0.45714285714284*G3_1_0 + 0.40634920634918*G3_1_1;
    A[1100] = 0.338624338624341*G1_0_1 + 0.338624338624343*G1_1_0 + 0.812698412698417*G1_1_1 + 0.338624338624341*G3_0_1 + 0.338624338624343*G3_1_0 + 0.812698412698417*G3_1_1;
    A[1101] = -2.43809523809524*G1_0_0 - 1.15132275132274*G1_0_1 - 1.15132275132274*G1_1_0 + 0.135449735449735*G1_1_1 - 2.43809523809524*G3_0_0 - 1.15132275132274*G3_0_1 - 1.15132275132274*G3_1_0 + 0.135449735449735*G3_1_1;
    A[1102] = 0.406349206349195*G1_0_0 + 1.57460317460317*G1_0_1 + 1.57460317460316*G1_1_0 - 0.101587301587297*G1_1_1 + 0.406349206349195*G3_0_0 + 1.57460317460317*G3_0_1 + 1.57460317460316*G3_1_0 - 0.101587301587297*G3_1_1;
    A[1103] = -0.338624338624336*G1_0_1 - 0.338624338624344*G1_1_0 + 0.135449735449733*G1_1_1 - 0.338624338624336*G3_0_1 - 0.338624338624344*G3_1_0 + 0.135449735449733*G3_1_1;
    A[1104] = 0.135449735449745*G1_0_0 - 1.15132275132274*G1_0_1 - 1.15132275132274*G1_1_0 - 2.43809523809522*G1_1_1 + 0.135449735449745*G3_0_0 - 1.15132275132274*G3_0_1 - 1.15132275132274*G3_1_0 - 2.43809523809522*G3_1_1;
    A[1105] = -0.10158730158731*G1_0_0 + 1.57460317460317*G1_0_1 + 1.57460317460316*G1_1_0 + 0.406349206349191*G1_1_1 - 0.10158730158731*G3_0_0 + 1.57460317460317*G3_0_1 + 1.57460317460316*G3_1_0 + 0.406349206349191*G3_1_1;
    A[1106] = 0.135449735449738*G1_0_0 - 0.338624338624342*G1_0_1 - 0.33862433862433*G1_1_0 + 0.135449735449738*G3_0_0 - 0.338624338624342*G3_0_1 - 0.33862433862433*G3_1_0;
    A[1107] = 5.68888888888888*G1_0_0 + 2.84444444444442*G1_0_1 + 2.84444444444442*G1_1_0 + 5.68888888888886*G1_1_1 + 5.68888888888888*G3_0_0 + 2.84444444444442*G3_0_1 + 2.84444444444442*G3_1_0 + 5.68888888888886*G3_1_1;
    A[1108] = -4.06349206349205*G1_0_0 - 2.031746031746*G1_0_1 - 2.03174603174601*G1_1_0 - 0.812698412698373*G1_1_1 - 4.06349206349205*G3_0_0 - 2.031746031746*G3_0_1 - 2.03174603174601*G3_1_0 - 0.812698412698373*G3_1_1;
    A[1109] = -0.812698412698384*G1_0_0 - 2.03174603174601*G1_0_1 - 2.031746031746*G1_1_0 - 4.06349206349205*G1_1_1 - 0.812698412698384*G3_0_0 - 2.03174603174601*G3_0_1 - 2.031746031746*G3_1_0 - 4.06349206349205*G3_1_1;
    A[1110] = 0.0317460317460316*G5_0 + 0.0317460317460313*G5_1;
    A[1111] = 0.0253968253968259*G5_0;
    A[1112] = 0.0253968253968256*G5_1;
    A[1113] = 0.057142857142855*G5_0 + 0.0571428571428549*G5_1;
    A[1114] = 0.0571428571428563*G5_0 + 0.0571428571428564*G5_1;
    A[1115] = 0.285714285714287*G5_0 + 0.0571428571428578*G5_1;
    A[1116] = -0.0571428571428562*G5_0 - 0.114285714285713*G5_1;
    A[1117] = 0.0571428571428582*G5_0 + 0.285714285714286*G5_1;
    A[1118] = -0.114285714285714*G5_0 - 0.0571428571428567*G5_1;
    A[1119] = -0.342857142857141*G5_0 - 0.342857142857141*G5_1;
    A[1120] = 0.0;
    A[1121] = 0.0;
    A[1122] = 0.0;
    A[1123] = 0.0;
    A[1124] = 0.0;
    A[1125] = 0.0;
    A[1126] = 0.0;
    A[1127] = 0.0;
    A[1128] = 0.0;
    A[1129] = 0.0;
    A[1130] = 0.0;
    A[1131] = 0.0;
    A[1132] = 0.0;
    A[1133] = 0.0;
    A[1134] = 0.0;
    A[1135] = -0.0846560846560791*G1_0_0 - 0.0846560846560775*G1_0_1 - 0.0846560846560799*G1_1_0 - 0.0846560846560807*G1_1_1 - 0.0846560846560791*G3_0_0 - 0.0846560846560775*G3_0_1 - 0.0846560846560799*G3_1_0 - 0.0846560846560807*G3_1_1;
    A[1136] = -0.0846560846560834*G1_0_0 - 0.0846560846560834*G3_0_0;
    A[1137] = -0.0846560846560844*G1_1_1 - 0.0846560846560844*G3_1_1;
    A[1138] = -2.43809523809522*G1_0_0 - 1.28677248677248*G1_0_1 - 1.28677248677248*G1_1_0 - 2.43809523809522*G3_0_0 - 1.28677248677248*G3_0_1 - 1.28677248677248*G3_1_0;
    A[1139] = 0.40634920634921*G1_0_0 - 1.16825396825395*G1_0_1 - 1.16825396825396*G1_1_0 - 2.84444444444442*G1_1_1 + 0.40634920634921*G3_0_0 - 1.16825396825395*G3_0_1 - 1.16825396825396*G3_1_0 - 2.84444444444442*G3_1_1;
    A[1140] = 0.338624338624335*G1_0_1 + 0.338624338624334*G1_1_0 + 0.812698412698406*G1_1_1 + 0.338624338624335*G3_0_1 + 0.338624338624334*G3_1_0 + 0.812698412698406*G3_1_1;
    A[1141] = 0.812698412698413*G1_0_0 + 0.474074074074063*G1_0_1 + 0.474074074074065*G1_1_0 + 0.13544973544973*G1_1_1 + 0.812698412698413*G3_0_0 + 0.474074074074063*G3_0_1 + 0.474074074074065*G3_1_0 + 0.13544973544973*G3_1_1;
    A[1142] = 0.406349206349209*G1_0_0 - 0.0507936507936498*G1_0_1 - 0.0507936507936406*G1_1_0 - 0.1015873015873*G1_1_1 + 0.406349206349209*G3_0_0 - 0.0507936507936498*G3_0_1 - 0.0507936507936406*G3_1_0 - 0.1015873015873*G3_1_1;
    A[1143] = -0.338624338624339*G1_0_1 - 0.338624338624334*G1_1_0 + 0.135449735449735*G1_1_1 - 0.338624338624339*G3_0_1 - 0.338624338624334*G3_1_0 + 0.135449735449735*G3_1_1;
    A[1144] = 0.135449735449723*G1_0_0 + 0.474074074074071*G1_0_1 + 0.474074074074061*G1_1_0 + 0.812698412698398*G1_1_1 + 0.135449735449723*G3_0_0 + 0.474074074074071*G3_0_1 + 0.474074074074061*G3_1_0 + 0.812698412698398*G3_1_1;
    A[1145] = -0.101587301587287*G1_0_0 - 1.67619047619047*G1_0_1 - 1.67619047619046*G1_1_0 - 2.84444444444443*G1_1_1 - 0.101587301587287*G3_0_0 - 1.67619047619047*G3_0_1 - 1.67619047619046*G3_1_0 - 2.84444444444443*G3_1_1;
    A[1146] = 0.135449735449726*G1_0_0 + 1.28677248677248*G1_0_1 + 1.28677248677247*G1_1_0 + 0.135449735449726*G3_0_0 + 1.28677248677248*G3_0_1 + 1.28677248677247*G3_1_0;
    A[1147] = -4.06349206349205*G1_0_0 - 2.03174603174601*G1_0_1 - 2.031746031746*G1_1_0 - 0.812698412698373*G1_1_1 - 4.06349206349205*G3_0_0 - 2.03174603174601*G3_0_1 - 2.031746031746*G3_1_0 - 0.812698412698373*G3_1_1;
    A[1148] = 5.68888888888886*G1_0_0 + 2.84444444444442*G1_0_1 + 2.84444444444442*G1_1_0 + 5.68888888888885*G1_1_1 + 5.68888888888886*G3_0_0 + 2.84444444444442*G3_0_1 + 2.84444444444442*G3_1_0 + 5.68888888888885*G3_1_1;
    A[1149] = -0.812698412698419*G1_0_0 + 1.21904761904761*G1_0_1 + 1.2190476190476*G1_1_0 - 0.812698412698428*G1_1_1 - 0.812698412698419*G3_0_0 + 1.21904761904761*G3_0_1 + 1.2190476190476*G3_1_0 - 0.812698412698428*G3_1_1;
    A[1150] = -0.0253968253968255*G5_0 - 0.0253968253968251*G5_1;
    A[1151] = -0.031746031746032*G5_0;
    A[1152] = 0.0253968253968252*G5_1;
    A[1153] = -0.285714285714283*G5_0 - 0.228571428571427*G5_1;
    A[1154] = 0.0571428571428569*G5_0 - 0.0571428571428575*G5_1;
    A[1155] = -0.0571428571428583*G5_0;
    A[1156] = -0.0571428571428571*G5_0;
    A[1157] = 0.114285714285713*G5_0 + 0.0571428571428566*G5_1;
    A[1158] = -0.0571428571428564*G5_0 + 0.228571428571428*G5_1;
    A[1159] = 0.342857142857141*G5_0;
    A[1160] = 0.0;
    A[1161] = 0.0;
    A[1162] = 0.0;
    A[1163] = 0.0;
    A[1164] = 0.0;
    A[1165] = 0.0;
    A[1166] = 0.0;
    A[1167] = 0.0;
    A[1168] = 0.0;
    A[1169] = 0.0;
    A[1170] = 0.0;
    A[1171] = 0.0;
    A[1172] = 0.0;
    A[1173] = 0.0;
    A[1174] = 0.0;
    A[1175] = -0.0846560846560807*G1_0_0 - 0.0846560846560836*G1_0_1 - 0.0846560846560803*G1_1_0 - 0.0846560846560813*G1_1_1 - 0.0846560846560807*G3_0_0 - 0.0846560846560836*G3_0_1 - 0.0846560846560803*G3_1_0 - 0.0846560846560813*G3_1_1;
    A[1176] = -0.0846560846560844*G1_0_0 - 0.0846560846560844*G3_0_0;
    A[1177] = -0.0846560846560848*G1_1_1 - 0.0846560846560848*G3_1_1;
    A[1178] = 0.812698412698408*G1_0_0 + 0.33862433862433*G1_0_1 + 0.338624338624331*G1_1_0 - 1.48713506786802e-14*G1_1_1 + 0.812698412698408*G3_0_0 + 0.33862433862433*G3_0_1 + 0.338624338624331*G3_1_0 - 1.48713506786802e-14*G3_1_1;
    A[1179] = -2.84444444444442*G1_0_0 - 1.16825396825395*G1_0_1 - 1.16825396825395*G1_1_0 + 0.406349206349223*G1_1_1 - 2.84444444444442*G3_0_0 - 1.16825396825395*G3_0_1 - 1.16825396825395*G3_1_0 + 0.406349206349223*G3_1_1;
    A[1180] = -1.28677248677248*G1_0_1 - 1.28677248677249*G1_1_0 - 2.43809523809524*G1_1_1 - 1.28677248677248*G3_0_1 - 1.28677248677249*G3_1_0 - 2.43809523809524*G3_1_1;
    A[1181] = 0.812698412698396*G1_0_0 + 0.474074074074068*G1_0_1 + 0.474074074074073*G1_1_0 + 0.13544973544973*G1_1_1 + 0.812698412698396*G3_0_0 + 0.474074074074068*G3_0_1 + 0.474074074074073*G3_1_0 + 0.13544973544973*G3_1_1;
    A[1182] = -2.84444444444442*G1_0_0 - 1.67619047619047*G1_0_1 - 1.67619047619047*G1_1_0 - 0.101587301587299*G1_1_1 - 2.84444444444442*G3_0_0 - 1.67619047619047*G3_0_1 - 1.67619047619047*G3_1_0 - 0.101587301587299*G3_1_1;
    A[1183] = 1.28677248677248*G1_0_1 + 1.28677248677249*G1_1_0 + 0.135449735449734*G1_1_1 + 1.28677248677248*G3_0_1 + 1.28677248677249*G3_1_0 + 0.135449735449734*G3_1_1;
    A[1184] = 0.135449735449728*G1_0_0 + 0.474074074074065*G1_0_1 + 0.474074074074069*G1_1_0 + 0.812698412698416*G1_1_1 + 0.135449735449728*G3_0_0 + 0.474074074074065*G3_0_1 + 0.474074074074069*G3_1_0 + 0.812698412698416*G3_1_1;
    A[1185] = -0.101587301587299*G1_0_0 - 0.0507936507936477*G1_0_1 - 0.0507936507936494*G1_1_0 + 0.40634920634921*G1_1_1 - 0.101587301587299*G3_0_0 - 0.0507936507936477*G3_0_1 - 0.0507936507936494*G3_1_0 + 0.40634920634921*G3_1_1;
    A[1186] = 0.135449735449736*G1_0_0 - 0.338624338624333*G1_0_1 - 0.338624338624338*G1_1_0 + 1.0248312615202e-14*G1_1_1 + 0.135449735449736*G3_0_0 - 0.338624338624333*G3_0_1 - 0.338624338624338*G3_1_0 + 1.0248312615202e-14*G3_1_1;
    A[1187] = -0.812698412698384*G1_0_0 - 2.031746031746*G1_0_1 - 2.03174603174601*G1_1_0 - 4.06349206349205*G1_1_1 - 0.812698412698384*G3_0_0 - 2.031746031746*G3_0_1 - 2.03174603174601*G3_1_0 - 4.06349206349205*G3_1_1;
    A[1188] = -0.812698412698419*G1_0_0 + 1.2190476190476*G1_0_1 + 1.21904761904761*G1_1_0 - 0.812698412698428*G1_1_1 - 0.812698412698419*G3_0_0 + 1.2190476190476*G3_0_1 + 1.21904761904761*G3_1_0 - 0.812698412698428*G3_1_1;
    A[1189] = 5.68888888888885*G1_0_0 + 2.84444444444442*G1_0_1 + 2.84444444444442*G1_1_0 + 5.68888888888888*G1_1_1 + 5.68888888888885*G3_0_0 + 2.84444444444442*G3_0_1 + 2.84444444444442*G3_1_0 + 5.68888888888888*G3_1_1;
    A[1190] = -0.0253968253968251*G5_0 - 0.0253968253968256*G5_1;
    A[1191] = 0.0253968253968252*G5_0;
    A[1192] = -0.0317460317460321*G5_1;
    A[1193] = -0.0571428571428566*G5_0 + 0.057142857142857*G5_1;
    A[1194] = -0.228571428571427*G5_0 - 0.285714285714284*G5_1;
    A[1195] = 0.0571428571428566*G5_0 + 0.114285714285713*G5_1;
    A[1196] = 0.228571428571427*G5_0 - 0.057142857142857*G5_1;
    A[1197] = -0.0571428571428582*G5_1;
    A[1198] = -0.0571428571428579*G5_1;
    A[1199] = 0.34285714285714*G5_1;
    A[1200] = -0.042063492063492*G7_0 - 0.042063492063492*G7_1;
    A[1201] = 0.0;
    A[1202] = 0.0;
    A[1203] = 0.0158730158730159*G7_0 + 0.0158730158730161*G7_1;
    A[1204] = 0.0103174603174602*G7_0 + 0.0103174603174599*G7_1;
    A[1205] = 0.0158730158730158*G7_0 + 0.0158730158730159*G7_1;
    A[1206] = -0.022222222222222*G7_0 + 0.0730158730158728*G7_1;
    A[1207] = 0.0150793650793649*G7_0 - 0.0468253968253965*G7_1;
    A[1208] = -0.0158730158730158*G7_0 + 0.0158730158730159*G7_1;
    A[1209] = 0.0730158730158731*G7_0 - 0.0222222222222219*G7_1;
    A[1210] = -0.0468253968253971*G7_0 + 0.0150793650793649*G7_1;
    A[1211] = 0.015873015873016*G7_0 - 0.0158730158730157*G7_1;
    A[1212] = 0.0317460317460316*G7_0 + 0.0317460317460313*G7_1;
    A[1213] = -0.0253968253968255*G7_0 - 0.0253968253968251*G7_1;
    A[1214] = -0.0253968253968251*G7_0 - 0.0253968253968256*G7_1;
    A[1215] = -0.042063492063492*G8_0 - 0.042063492063492*G8_1;
    A[1216] = 0.0;
    A[1217] = 0.0;
    A[1218] = 0.0158730158730159*G8_0 + 0.0158730158730161*G8_1;
    A[1219] = 0.0103174603174602*G8_0 + 0.0103174603174599*G8_1;
    A[1220] = 0.0158730158730158*G8_0 + 0.0158730158730159*G8_1;
    A[1221] = -0.022222222222222*G8_0 + 0.0730158730158728*G8_1;
    A[1222] = 0.0150793650793649*G8_0 - 0.0468253968253965*G8_1;
    A[1223] = -0.0158730158730158*G8_0 + 0.0158730158730159*G8_1;
    A[1224] = 0.0730158730158731*G8_0 - 0.0222222222222219*G8_1;
    A[1225] = -0.0468253968253971*G8_0 + 0.0150793650793649*G8_1;
    A[1226] = 0.015873015873016*G8_0 - 0.0158730158730157*G8_1;
    A[1227] = 0.0317460317460316*G8_0 + 0.0317460317460313*G8_1;
    A[1228] = -0.0253968253968255*G8_0 - 0.0253968253968251*G8_1;
    A[1229] = -0.0253968253968251*G8_0 - 0.0253968253968256*G8_1;
    A[1230] = -5.65476190476188e-05*G6_;
    A[1231] = -8.18452380952377e-06*G6_;
    A[1232] = -8.18452380952376e-06*G6_;
    A[1233] = -2.00892857142856e-05*G6_;
    A[1234] = -2.00892857142857e-05*G6_;
    A[1235] = -1.3392857142857e-05*G6_;
    A[1236] = 0.0;
    A[1237] = -1.33928571428571e-05*G6_;
    A[1238] = 0.0;
    A[1239] = -2.67857142857143e-05*G6_;
    A[1240] = 0.0;
    A[1241] = 0.0420634920634918*G7_0;
    A[1242] = 0.0;
    A[1243] = 0.0222222222222221*G7_0 + 0.0952380952380947*G7_1;
    A[1244] = -0.0150793650793649*G7_0 - 0.0619047619047617*G7_1;
    A[1245] = 0.0158730158730158*G7_0 + 0.0317460317460316*G7_1;
    A[1246] = -0.015873015873016*G7_0;
    A[1247] = -0.0103174603174602*G7_0;
    A[1248] = -0.0158730158730158*G7_0;
    A[1249] = -0.0158730158730156*G7_0 - 0.0317460317460316*G7_1;
    A[1250] = 0.0468253968253961*G7_0 + 0.0619047619047615*G7_1;
    A[1251] = -0.0730158730158723*G7_0 - 0.0952380952380944*G7_1;
    A[1252] = 0.0253968253968259*G7_0;
    A[1253] = -0.031746031746032*G7_0;
    A[1254] = 0.0253968253968252*G7_0;
    A[1255] = 0.0;
    A[1256] = 0.0420634920634918*G8_0;
    A[1257] = 0.0;
    A[1258] = 0.0222222222222221*G8_0 + 0.0952380952380947*G8_1;
    A[1259] = -0.0150793650793649*G8_0 - 0.0619047619047617*G8_1;
    A[1260] = 0.0158730158730158*G8_0 + 0.0317460317460316*G8_1;
    A[1261] = -0.015873015873016*G8_0;
    A[1262] = -0.0103174603174602*G8_0;
    A[1263] = -0.0158730158730158*G8_0;
    A[1264] = -0.0158730158730156*G8_0 - 0.0317460317460316*G8_1;
    A[1265] = 0.0468253968253961*G8_0 + 0.0619047619047615*G8_1;
    A[1266] = -0.0730158730158723*G8_0 - 0.0952380952380944*G8_1;
    A[1267] = 0.0253968253968259*G8_0;
    A[1268] = -0.031746031746032*G8_0;
    A[1269] = 0.0253968253968252*G8_0;
    A[1270] = -8.18452380952377e-06*G6_;
    A[1271] = -5.65476190476188e-05*G6_;
    A[1272] = -8.18452380952376e-06*G6_;
    A[1273] = -1.3392857142857e-05*G6_;
    A[1274] = 0.0;
    A[1275] = -2.00892857142856e-05*G6_;
    A[1276] = -2.00892857142857e-05*G6_;
    A[1277] = 0.0;
    A[1278] = -1.3392857142857e-05*G6_;
    A[1279] = -2.67857142857142e-05*G6_;
    A[1280] = 0.0;
    A[1281] = 0.0;
    A[1282] = 0.0420634920634918*G7_1;
    A[1283] = 0.0317460317460316*G7_0 + 0.015873015873016*G7_1;
    A[1284] = -0.0619047619047617*G7_0 - 0.0150793650793653*G7_1;
    A[1285] = 0.0952380952380949*G7_0 + 0.0222222222222223*G7_1;
    A[1286] = -0.0317460317460317*G7_0 - 0.0158730158730158*G7_1;
    A[1287] = 0.0619047619047617*G7_0 + 0.0468253968253966*G7_1;
    A[1288] = -0.0952380952380949*G7_0 - 0.0730158730158724*G7_1;
    A[1289] = -0.0158730158730159*G7_1;
    A[1290] = -0.0103174603174603*G7_1;
    A[1291] = -0.0158730158730156*G7_1;
    A[1292] = 0.0253968253968256*G7_1;
    A[1293] = 0.0253968253968252*G7_1;
    A[1294] = -0.0317460317460321*G7_1;
    A[1295] = 0.0;
    A[1296] = 0.0;
    A[1297] = 0.0420634920634918*G8_1;
    A[1298] = 0.0317460317460316*G8_0 + 0.015873015873016*G8_1;
    A[1299] = -0.0619047619047617*G8_0 - 0.0150793650793653*G8_1;
    A[1300] = 0.0952380952380949*G8_0 + 0.0222222222222223*G8_1;
    A[1301] = -0.0317460317460317*G8_0 - 0.0158730158730158*G8_1;
    A[1302] = 0.0619047619047617*G8_0 + 0.0468253968253966*G8_1;
    A[1303] = -0.0952380952380949*G8_0 - 0.0730158730158724*G8_1;
    A[1304] = -0.0158730158730159*G8_1;
    A[1305] = -0.0103174603174603*G8_1;
    A[1306] = -0.0158730158730156*G8_1;
    A[1307] = 0.0253968253968256*G8_1;
    A[1308] = 0.0253968253968252*G8_1;
    A[1309] = -0.0317460317460321*G8_1;
    A[1310] = -8.18452380952376e-06*G6_;
    A[1311] = -8.18452380952376e-06*G6_;
    A[1312] = -5.65476190476187e-05*G6_;
    A[1313] = 0.0;
    A[1314] = -1.3392857142857e-05*G6_;
    A[1315] = 0.0;
    A[1316] = -1.3392857142857e-05*G6_;
    A[1317] = -2.00892857142856e-05*G6_;
    A[1318] = -2.00892857142856e-05*G6_;
    A[1319] = -2.67857142857142e-05*G6_;
    A[1320] = 0.00892857142857105*G7_0 + 0.00892857142857096*G7_1;
    A[1321] = 0.026785714285714*G7_0;
    A[1322] = -0.00892857142857123*G7_1;
    A[1323] = 0.228571428571427*G7_0 + 0.142857142857142*G7_1;
    A[1324] = 0.0285714285714287*G7_0 + 0.178571428571428*G7_1;
    A[1325] = -0.057142857142857*G7_0 - 0.0857142857142858*G7_1;
    A[1326] = 0.0;
    A[1327] = 0.0285714285714279*G7_0;
    A[1328] = 0.0571428571428571*G7_0;
    A[1329] = -0.0285714285714273*G7_0 - 0.028571428571428*G7_1;
    A[1330] = 0.0214285714285699*G7_0 + 0.0499999999999991*G7_1;
    A[1331] = -0.0285714285714276*G7_0 - 0.142857142857141*G7_1;
    A[1332] = 0.057142857142855*G7_0 + 0.0571428571428549*G7_1;
    A[1333] = -0.285714285714283*G7_0 - 0.228571428571427*G7_1;
    A[1334] = -0.0571428571428566*G7_0 + 0.057142857142857*G7_1;
    A[1335] = 0.00892857142857105*G8_0 + 0.00892857142857096*G8_1;
    A[1336] = 0.026785714285714*G8_0;
    A[1337] = -0.00892857142857123*G8_1;
    A[1338] = 0.228571428571427*G8_0 + 0.142857142857142*G8_1;
    A[1339] = 0.0285714285714287*G8_0 + 0.178571428571428*G8_1;
    A[1340] = -0.057142857142857*G8_0 - 0.0857142857142858*G8_1;
    A[1341] = 0.0;
    A[1342] = 0.0285714285714279*G8_0;
    A[1343] = 0.0571428571428571*G8_0;
    A[1344] = -0.0285714285714273*G8_0 - 0.028571428571428*G8_1;
    A[1345] = 0.0214285714285699*G8_0 + 0.0499999999999991*G8_1;
    A[1346] = -0.0285714285714276*G8_0 - 0.142857142857141*G8_1;
    A[1347] = 0.057142857142855*G8_0 + 0.0571428571428549*G8_1;
    A[1348] = -0.285714285714283*G8_0 - 0.228571428571427*G8_1;
    A[1349] = -0.0571428571428566*G8_0 + 0.057142857142857*G8_1;
    A[1350] = -2.00892857142856e-05*G6_;
    A[1351] = -1.3392857142857e-05*G6_;
    A[1352] = 0.0;
    A[1353] = -0.000401785714285713*G6_;
    A[1354] = 0.000140624999999999*G6_;
    A[1355] = 4.01785714285713e-05*G6_;
    A[1356] = 0.000100446428571428*G6_;
    A[1357] = 0.000100446428571428*G6_;
    A[1358] = -0.000200892857142856*G6_;
    A[1359] = -0.000120535714285714*G6_;
    A[1360] = 0.00892857142857125*G7_0 + 0.00892857142857122*G7_1;
    A[1361] = -0.00892857142857135*G7_0;
    A[1362] = 0.0267857142857139*G7_1;
    A[1363] = -0.0857142857142851*G7_0 - 0.0571428571428564*G7_1;
    A[1364] = 0.178571428571427*G7_0 + 0.0285714285714275*G7_1;
    A[1365] = 0.142857142857143*G7_0 + 0.228571428571428*G7_1;
    A[1366] = -0.0285714285714281*G7_0 - 0.0285714285714281*G7_1;
    A[1367] = 0.0499999999999999*G7_0 + 0.0214285714285709*G7_1;
    A[1368] = -0.142857142857143*G7_0 - 0.0285714285714277*G7_1;
    A[1369] = 0.0;
    A[1370] = 0.0285714285714287*G7_1;
    A[1371] = 0.0571428571428571*G7_1;
    A[1372] = 0.0571428571428563*G7_0 + 0.0571428571428564*G7_1;
    A[1373] = 0.0571428571428569*G7_0 - 0.0571428571428575*G7_1;
    A[1374] = -0.228571428571427*G7_0 - 0.285714285714284*G7_1;
    A[1375] = 0.00892857142857125*G8_0 + 0.00892857142857122*G8_1;
    A[1376] = -0.00892857142857135*G8_0;
    A[1377] = 0.0267857142857139*G8_1;
    A[1378] = -0.0857142857142851*G8_0 - 0.0571428571428564*G8_1;
    A[1379] = 0.178571428571427*G8_0 + 0.0285714285714275*G8_1;
    A[1380] = 0.142857142857143*G8_0 + 0.228571428571428*G8_1;
    A[1381] = -0.0285714285714281*G8_0 - 0.0285714285714281*G8_1;
    A[1382] = 0.0499999999999999*G8_0 + 0.0214285714285709*G8_1;
    A[1383] = -0.142857142857143*G8_0 - 0.0285714285714277*G8_1;
    A[1384] = 0.0;
    A[1385] = 0.0285714285714287*G8_1;
    A[1386] = 0.0571428571428571*G8_1;
    A[1387] = 0.0571428571428563*G8_0 + 0.0571428571428564*G8_1;
    A[1388] = 0.0571428571428569*G8_0 - 0.0571428571428575*G8_1;
    A[1389] = -0.228571428571427*G8_0 - 0.285714285714284*G8_1;
    A[1390] = -2.00892857142857e-05*G6_;
    A[1391] = 0.0;
    A[1392] = -1.3392857142857e-05*G6_;
    A[1393] = 0.000140624999999999*G6_;
    A[1394] = -0.000401785714285712*G6_;
    A[1395] = 0.000100446428571428*G6_;
    A[1396] = -0.000200892857142856*G6_;
    A[1397] = 4.01785714285713e-05*G6_;
    A[1398] = 0.000100446428571428*G6_;
    A[1399] = -0.000120535714285714*G6_;
    A[1400] = -0.0267857142857143*G7_0 - 0.0267857142857143*G7_1;
    A[1401] = -0.00892857142857137*G7_0;
    A[1402] = -0.00892857142857122*G7_1;
    A[1403] = 0.0;
    A[1404] = -0.0285714285714281*G7_0 - 0.0285714285714287*G7_1;
    A[1405] = -0.0571428571428571*G7_0 - 0.0571428571428572*G7_1;
    A[1406] = -0.228571428571428*G7_0 - 0.0857142857142856*G7_1;
    A[1407] = -0.0285714285714284*G7_0 + 0.15*G7_1;
    A[1408] = 0.057142857142857*G7_0 - 0.0285714285714286*G7_1;
    A[1409] = 0.0285714285714288*G7_0 - 0.114285714285714*G7_1;
    A[1410] = -0.0214285714285716*G7_0 + 0.0285714285714285*G7_1;
    A[1411] = 0.0285714285714285*G7_0;
    A[1412] = 0.285714285714287*G7_0 + 0.0571428571428578*G7_1;
    A[1413] = -0.0571428571428583*G7_0;
    A[1414] = 0.0571428571428566*G7_0 + 0.114285714285713*G7_1;
    A[1415] = -0.0267857142857143*G8_0 - 0.0267857142857143*G8_1;
    A[1416] = -0.00892857142857137*G8_0;
    A[1417] = -0.00892857142857122*G8_1;
    A[1418] = 0.0;
    A[1419] = -0.0285714285714281*G8_0 - 0.0285714285714287*G8_1;
    A[1420] = -0.0571428571428571*G8_0 - 0.0571428571428572*G8_1;
    A[1421] = -0.228571428571428*G8_0 - 0.0857142857142856*G8_1;
    A[1422] = -0.0285714285714284*G8_0 + 0.15*G8_1;
    A[1423] = 0.057142857142857*G8_0 - 0.0285714285714286*G8_1;
    A[1424] = 0.0285714285714288*G8_0 - 0.114285714285714*G8_1;
    A[1425] = -0.0214285714285716*G8_0 + 0.0285714285714285*G8_1;
    A[1426] = 0.0285714285714285*G8_0;
    A[1427] = 0.285714285714287*G8_0 + 0.0571428571428578*G8_1;
    A[1428] = -0.0571428571428583*G8_0;
    A[1429] = 0.0571428571428566*G8_0 + 0.114285714285713*G8_1;
    A[1430] = -1.3392857142857e-05*G6_;
    A[1431] = -2.00892857142856e-05*G6_;
    A[1432] = 0.0;
    A[1433] = 4.01785714285713e-05*G6_;
    A[1434] = 0.000100446428571428*G6_;
    A[1435] = -0.000401785714285712*G6_;
    A[1436] = 0.000140624999999999*G6_;
    A[1437] = -0.000200892857142856*G6_;
    A[1438] = 0.000100446428571428*G6_;
    A[1439] = -0.000120535714285714*G6_;
    A[1440] = 0.00892857142857158*G7_0 + 0.00892857142857128*G7_1;
    A[1441] = -0.00892857142857136*G7_0;
    A[1442] = 0.0267857142857139*G7_1;
    A[1443] = 0.0285714285714285*G7_0;
    A[1444] = -0.0500000000000002*G7_0 - 0.0285714285714289*G7_1;
    A[1445] = 0.142857142857142*G7_0 + 0.114285714285714*G7_1;
    A[1446] = 0.0857142857142849*G7_0 + 0.0285714285714285*G7_1;
    A[1447] = -0.178571428571427*G7_0 - 0.15*G7_1;
    A[1448] = -0.142857142857142*G7_0 + 0.0857142857142862*G7_1;
    A[1449] = 0.0571428571428565*G7_1;
    A[1450] = 0.0285714285714287*G7_1;
    A[1451] = 0.0;
    A[1452] = -0.0571428571428562*G7_0 - 0.114285714285713*G7_1;
    A[1453] = -0.0571428571428571*G7_0;
    A[1454] = 0.228571428571427*G7_0 - 0.057142857142857*G7_1;
    A[1455] = 0.00892857142857158*G8_0 + 0.00892857142857128*G8_1;
    A[1456] = -0.00892857142857136*G8_0;
    A[1457] = 0.0267857142857139*G8_1;
    A[1458] = 0.0285714285714285*G8_0;
    A[1459] = -0.0500000000000002*G8_0 - 0.0285714285714289*G8_1;
    A[1460] = 0.142857142857142*G8_0 + 0.114285714285714*G8_1;
    A[1461] = 0.0857142857142849*G8_0 + 0.0285714285714285*G8_1;
    A[1462] = -0.178571428571427*G8_0 - 0.15*G8_1;
    A[1463] = -0.142857142857142*G8_0 + 0.0857142857142862*G8_1;
    A[1464] = 0.0571428571428565*G8_1;
    A[1465] = 0.0285714285714287*G8_1;
    A[1466] = 0.0;
    A[1467] = -0.0571428571428562*G8_0 - 0.114285714285713*G8_1;
    A[1468] = -0.0571428571428571*G8_0;
    A[1469] = 0.228571428571427*G8_0 - 0.057142857142857*G8_1;
    A[1470] = 0.0;
    A[1471] = -2.00892857142857e-05*G6_;
    A[1472] = -1.3392857142857e-05*G6_;
    A[1473] = 0.000100446428571428*G6_;
    A[1474] = -0.000200892857142856*G6_;
    A[1475] = 0.000140624999999999*G6_;
    A[1476] = -0.000401785714285713*G6_;
    A[1477] = 0.000100446428571428*G6_;
    A[1478] = 4.01785714285712e-05*G6_;
    A[1479] = -0.000120535714285714*G6_;
    A[1480] = -0.0267857142857144*G7_0 - 0.0267857142857142*G7_1;
    A[1481] = -0.00892857142857128*G7_0;
    A[1482] = -0.00892857142857123*G7_1;
    A[1483] = -0.0571428571428567*G7_0 - 0.0571428571428562*G7_1;
    A[1484] = -0.0285714285714284*G7_0 - 0.028571428571429*G7_1;
    A[1485] = 0.0;
    A[1486] = -0.114285714285714*G7_0 + 0.028571428571428*G7_1;
    A[1487] = 0.0285714285714284*G7_0 - 0.0214285714285706*G7_1;
    A[1488] = 0.0285714285714283*G7_1;
    A[1489] = -0.0857142857142849*G7_0 - 0.228571428571428*G7_1;
    A[1490] = 0.149999999999999*G7_0 - 0.0285714285714283*G7_1;
    A[1491] = -0.0285714285714288*G7_0 + 0.0571428571428568*G7_1;
    A[1492] = 0.0571428571428582*G7_0 + 0.285714285714286*G7_1;
    A[1493] = 0.114285714285713*G7_0 + 0.0571428571428566*G7_1;
    A[1494] = -0.0571428571428582*G7_1;
    A[1495] = -0.0267857142857144*G8_0 - 0.0267857142857142*G8_1;
    A[1496] = -0.00892857142857128*G8_0;
    A[1497] = -0.00892857142857123*G8_1;
    A[1498] = -0.0571428571428567*G8_0 - 0.0571428571428562*G8_1;
    A[1499] = -0.0285714285714284*G8_0 - 0.028571428571429*G8_1;
    A[1500] = 0.0;
    A[1501] = -0.114285714285714*G8_0 + 0.028571428571428*G8_1;
    A[1502] = 0.0285714285714284*G8_0 - 0.0214285714285706*G8_1;
    A[1503] = 0.0285714285714283*G8_1;
    A[1504] = -0.0857142857142849*G8_0 - 0.228571428571428*G8_1;
    A[1505] = 0.149999999999999*G8_0 - 0.0285714285714283*G8_1;
    A[1506] = -0.0285714285714288*G8_0 + 0.0571428571428568*G8_1;
    A[1507] = 0.0571428571428582*G8_0 + 0.285714285714286*G8_1;
    A[1508] = 0.114285714285713*G8_0 + 0.0571428571428566*G8_1;
    A[1509] = -0.0571428571428582*G8_1;
    A[1510] = -1.33928571428571e-05*G6_;
    A[1511] = 0.0;
    A[1512] = -2.00892857142856e-05*G6_;
    A[1513] = 0.000100446428571428*G6_;
    A[1514] = 4.01785714285712e-05*G6_;
    A[1515] = -0.000200892857142856*G6_;
    A[1516] = 0.000100446428571428*G6_;
    A[1517] = -0.000401785714285712*G6_;
    A[1518] = 0.000140624999999999*G6_;
    A[1519] = -0.000120535714285714*G6_;
    A[1520] = 0.00892857142857149*G7_0 + 0.00892857142857129*G7_1;
    A[1521] = 0.026785714285714*G7_0;
    A[1522] = -0.00892857142857126*G7_1;
    A[1523] = 0.114285714285714*G7_0 + 0.142857142857142*G7_1;
    A[1524] = -0.0285714285714282*G7_0 - 0.0499999999999994*G7_1;
    A[1525] = 0.028571428571428*G7_1;
    A[1526] = 0.0571428571428573*G7_0;
    A[1527] = 0.0285714285714283*G7_0;
    A[1528] = 0.0;
    A[1529] = 0.0285714285714286*G7_0 + 0.0857142857142849*G7_1;
    A[1530] = -0.15*G7_0 - 0.178571428571428*G7_1;
    A[1531] = 0.0857142857142859*G7_0 - 0.142857142857141*G7_1;
    A[1532] = -0.114285714285714*G7_0 - 0.0571428571428567*G7_1;
    A[1533] = -0.0571428571428564*G7_0 + 0.228571428571428*G7_1;
    A[1534] = -0.0571428571428579*G7_1;
    A[1535] = 0.00892857142857149*G8_0 + 0.00892857142857129*G8_1;
    A[1536] = 0.026785714285714*G8_0;
    A[1537] = -0.00892857142857126*G8_1;
    A[1538] = 0.114285714285714*G8_0 + 0.142857142857142*G8_1;
    A[1539] = -0.0285714285714282*G8_0 - 0.0499999999999994*G8_1;
    A[1540] = 0.028571428571428*G8_1;
    A[1541] = 0.0571428571428573*G8_0;
    A[1542] = 0.0285714285714283*G8_0;
    A[1543] = 0.0;
    A[1544] = 0.0285714285714286*G8_0 + 0.0857142857142849*G8_1;
    A[1545] = -0.15*G8_0 - 0.178571428571428*G8_1;
    A[1546] = 0.0857142857142859*G8_0 - 0.142857142857141*G8_1;
    A[1547] = -0.114285714285714*G8_0 - 0.0571428571428567*G8_1;
    A[1548] = -0.0571428571428564*G8_0 + 0.228571428571428*G8_1;
    A[1549] = -0.0571428571428579*G8_1;
    A[1550] = 0.0;
    A[1551] = -1.3392857142857e-05*G6_;
    A[1552] = -2.00892857142856e-05*G6_;
    A[1553] = -0.000200892857142856*G6_;
    A[1554] = 0.000100446428571428*G6_;
    A[1555] = 0.000100446428571428*G6_;
    A[1556] = 4.01785714285712e-05*G6_;
    A[1557] = 0.000140624999999999*G6_;
    A[1558] = -0.000401785714285712*G6_;
    A[1559] = -0.000120535714285714*G6_;
    A[1560] = -0.017857142857143*G7_0 - 0.0178571428571434*G7_1;
    A[1561] = 0.0178571428571429*G7_0;
    A[1562] = 0.0178571428571428*G7_1;
    A[1563] = 0.057142857142857*G7_0 + 0.0571428571428573*G7_1;
    A[1564] = 0.128571428571428*G7_0 + 0.128571428571427*G7_1;
    A[1565] = 0.0571428571428569*G7_0 + 0.0571428571428559*G7_1;
    A[1566] = -0.0571428571428568*G7_0;
    A[1567] = -0.128571428571428*G7_0;
    A[1568] = -0.0571428571428567*G7_0;
    A[1569] = -0.0571428571428582*G7_1;
    A[1570] = -0.128571428571428*G7_1;
    A[1571] = -0.0571428571428546*G7_1;
    A[1572] = -0.342857142857141*G7_0 - 0.342857142857141*G7_1;
    A[1573] = 0.342857142857141*G7_0;
    A[1574] = 0.34285714285714*G7_1;
    A[1575] = -0.017857142857143*G8_0 - 0.0178571428571434*G8_1;
    A[1576] = 0.0178571428571429*G8_0;
    A[1577] = 0.0178571428571428*G8_1;
    A[1578] = 0.057142857142857*G8_0 + 0.0571428571428573*G8_1;
    A[1579] = 0.128571428571428*G8_0 + 0.128571428571427*G8_1;
    A[1580] = 0.0571428571428569*G8_0 + 0.0571428571428559*G8_1;
    A[1581] = -0.0571428571428568*G8_0;
    A[1582] = -0.128571428571428*G8_0;
    A[1583] = -0.0571428571428567*G8_0;
    A[1584] = -0.0571428571428582*G8_1;
    A[1585] = -0.128571428571428*G8_1;
    A[1586] = -0.0571428571428546*G8_1;
    A[1587] = -0.342857142857141*G8_0 - 0.342857142857141*G8_1;
    A[1588] = 0.342857142857141*G8_0;
    A[1589] = 0.34285714285714*G8_1;
    A[1590] = -2.67857142857143e-05*G6_;
    A[1591] = -2.67857142857142e-05*G6_;
    A[1592] = -2.67857142857142e-05*G6_;
    A[1593] = -0.000120535714285714*G6_;
    A[1594] = -0.000120535714285714*G6_;
    A[1595] = -0.000120535714285714*G6_;
    A[1596] = -0.000120535714285714*G6_;
    A[1597] = -0.000120535714285714*G6_;
    A[1598] = -0.000120535714285714*G6_;
    A[1599] = -0.00144642857142857*G6_;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_form_0: public ufc::form
{
public:

  /// Constructor
  ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "adf9b406210fd80b1292332091f32d43b57d275aa2f88589b2b708feff9492323257c671d115cc6c893e567f182bb0161dc9b22f4f9a367371c8ec52b41782a5";
  }


  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 0;
  }

  /// Return original coefficient position for each coefficient (0 <= i < n)
  virtual std::size_t original_coefficient_position(std::size_t i) const
  {
    static const std::vector<std::size_t> position({});
    return position[i];
  }


  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3();
        break;
      }
    case 1:
      {
        return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_dofmap_3();
        break;
      }
    }
    
    return 0;
  }


  /// Return the number of cell domains
  virtual std::size_t max_cell_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t max_exterior_facet_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t max_interior_facet_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of vertex domains
  virtual std::size_t max_vertex_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t max_custom_subdomain_id() const
  {
    return 0;
  }


  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any vertex integrals
  virtual bool has_vertex_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }


  /// Create a new cell integral on sub domain subdomain_id
  virtual ufc::cell_integral* create_cell_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain subdomain_id
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain subdomain_id
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new vertex integral on sub domain subdomain_id
  virtual ufc::vertex_integral* create_vertex_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain subdomain_id
  virtual ufc::custom_integral* create_custom_integral(std::size_t subdomain_id) const
  {
    return 0;
  }


  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new ffc_form_7e9988ab285a1ea11a6c9984a0d4284b654e659d_cell_integral_0_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new vertex integral on everywhere else
  virtual ufc::vertex_integral* create_default_vertex_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

#endif
