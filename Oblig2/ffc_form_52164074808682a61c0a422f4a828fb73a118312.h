// This code conforms with the UFC specification version 1.6.0
// and was automatically generated by FFC version 1.6.0.
// 
// This code was generated with the following parameters:
// 
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   name:                           'ffc'
//   no-evaluate_basis_derivatives:  True
//   optimize:                       False
//   precision:                      15
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   restrict_keyword:               ''
//   split:                          False

#ifndef __FFC_FORM_52164074808682A61C0A422F4A828FB73A118312_H
#define __FFC_FORM_52164074808682A61C0A422F4A828FB73A118312_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 15; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[16];
    for (unsigned int r = 0; r < 16; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 30;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 26:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 27:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 28:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 29:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 30; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 30; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[32];
    for (unsigned int r = 0; r < 32; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 30; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 15:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 21:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 22:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 23:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 24:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 25:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 26:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 27:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 28:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 29:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[20] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[21] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[22] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[23] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[24] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[25] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[26] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[27] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[28] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[29] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[15];
    vertex_values[3] = dof_values[16];
    vertex_values[5] = dof_values[17];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None), **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 45;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 26:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 27:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 28:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 29:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 30:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, -0.0412393049421161, -0.0238095238095238, 0.0289800294976278, 0.0224478343233824, 0.0129602631893289, -0.0395942580610999, -0.0334632556631574, -0.025920526378658, -0.014965222882255, 0.0321247254366312, 0.0283313448138523, 0.023944356611608, 0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 31:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0412393049421162, -0.0238095238095238, 0.0289800294976278, -0.0224478343233825, 0.012960263189329, 0.0395942580610999, -0.0334632556631574, 0.0259205263786579, -0.014965222882255, 0.0321247254366312, -0.0283313448138523, 0.023944356611608, -0.0185472188784818, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 32:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.0, 0.0, 0.0476190476190476, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 33:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.131965775814772, -0.0253968253968254, 0.139104141588614, -0.0718330698348238, 0.0311046316543896, 0.0633508128977598, 0.0267706045305259, -0.0622092633087791, 0.0478887132232159, 0.0, 0.0566626896277045, -0.0838052481406279, 0.0834624849531682, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 34:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527355, 0.0109971479845643, 0.00634920634920626, 0.0, 0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.0, 0.0, 0.0838052481406278, -0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 35:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0439885919382573, 0.126984126984127, 0.0, 0.035916534917412, 0.155523158271948, 0.0, 0.0, 0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, 0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 36:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.131965775814772, -0.0253968253968254, 0.139104141588614, 0.0718330698348239, 0.0311046316543895, -0.0633508128977598, 0.0267706045305259, 0.0622092633087792, 0.0478887132232159, 0.0, -0.0566626896277046, -0.0838052481406278, -0.0834624849531681, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 37:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527353, -0.0109971479845643, 0.00634920634920621, 0.0, -0.188561808316413, -0.163299316185545, 0.0, 0.0936971158568409, 0.0, -0.0419026240703138, 0.0, 0.0, 0.0838052481406278, 0.139104141588614, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 38:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0439885919382572, 0.126984126984127, 0.0, -0.0359165349174119, 0.155523158271948, 0.0, 0.0, -0.103682105514632, -0.011972178305804, 0.0, 0.0, 0.0, -0.0927360943924091, -0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 39:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, -0.0879771838765144, -0.101587301587302, 0.0927360943924091, 0.107749604752236, 0.0725774738602423, 0.0791885161221998, -0.013385302265263, -0.0518410527573159, -0.0419026240703139, -0.128498901746525, -0.0566626896277046, -0.011972178305804, 0.00927360943924089, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 40:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {-0.0314269680527352, 0.0, -0.0126984126984128, -0.243432247780074, 0.0, 0.0544331053951818, 0.0, 0.0936971158568409, 0.0, -0.0419026240703139, 0.192748352619787, 0.0, -0.0239443566116079, 0.0, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 41:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.125707872210942, 0.0879771838765144, -0.101587301587302, 0.0927360943924091, -0.107749604752236, 0.0725774738602423, -0.0791885161221998, -0.013385302265263, 0.051841052757316, -0.041902624070314, -0.128498901746525, 0.0566626896277046, -0.011972178305804, -0.00927360943924091, 0.0107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 42:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421884, -0.351908735506058, -0.203174603174603, -0.139104141588614, -0.107749604752236, -0.0622092633087791, 0.19005243869328, -0.0267706045305259, 0.124418526617558, 0.155638317975452, 0.0, 0.169988068883114, 0.0838052481406278, -0.0278208283177227, -0.053541209061052};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 43:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.351908735506058, -0.203174603174603, -0.139104141588614, 0.107749604752236, -0.0622092633087792, -0.19005243869328, -0.0267706045305259, -0.124418526617558, 0.155638317975452, 0.0, -0.169988068883114, 0.0838052481406278, 0.0278208283177227, -0.0535412090610519};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 44:
      {
        
      // Array of basisvalues
      double basisvalues[15] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[10] = basisvalues[6]*1.75*tmp0 - basisvalues[3]*0.75*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[11] = basisvalues[6]*(3.5 + 4.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[14] = basisvalues[9]*(0.0285714285714286 + Y*1.8) - basisvalues[5]*0.771428571428571;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[13] = basisvalues[8]*(0.285714285714286 + Y*2.0) - basisvalues[4]*0.714285714285714;
      basisvalues[12] = basisvalues[7]*(1.02040816326531 + Y*2.57142857142857) - basisvalues[3]*0.551020408163265;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[14] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[13] *= std::sqrt(7.5);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[12] *= std::sqrt(12.5);
      basisvalues[6] *= std::sqrt(14.0);
      basisvalues[11] *= std::sqrt(17.5);
      basisvalues[10] *= std::sqrt(22.5);
      
      // Table(s) of coefficients
      static const double coefficients0[15] = \
      {0.251415744421883, 0.0, 0.406349206349206, 0.0, 0.0, -0.186627789926337, 0.0, -0.187394231713682, 0.0, -0.203527031198668, 0.0, 0.0, -0.167610496281256, 0.0, 0.107082418122104};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 15; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 45; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 45; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[48];
    for (unsigned int r = 0; r < 48; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 45; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 11:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 12:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 13:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 14:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 15:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 21:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 22:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 23:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 24:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 25:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 26:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 27:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 28:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 29:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 30:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 31:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 32:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 33:
      {
        y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 34:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 35:
      {
        y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 36:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 37:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 38:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 39:
      {
        y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
      y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 40:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 41:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
      y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 42:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 43:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 44:
      {
        y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[20] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[21] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[22] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[23] = vals[1];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[24] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[25] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[26] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[27] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[28] = vals[1];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[29] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[30] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[31] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[32] = vals[2];
    y[0] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[33] = vals[2];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[34] = vals[2];
    y[0] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[35] = vals[2];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[36] = vals[2];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[37] = vals[2];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[38] = vals[2];
    y[0] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    y[1] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[39] = vals[2];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[40] = vals[2];
    y[0] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    y[1] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[41] = vals[2];
    y[0] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[42] = vals[2];
    y[0] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[43] = vals[2];
    y[0] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[44] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[15];
    vertex_values[4] = dof_values[16];
    vertex_values[7] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[30];
    vertex_values[5] = dof_values[31];
    vertex_values[8] = dof_values[32];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_1();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + 3*num_global_entities[1] + 3*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 5;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 3;
        break;
      }
    case 2:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_1: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 2*num_global_entities[0] + 6*num_global_entities[1] + 6*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 30;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 10;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 6;
        break;
      }
    case 2:
      {
        return 6;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[15] = offset + c.entity_indices[0][0];
    dofs[16] = offset + c.entity_indices[0][1];
    dofs[17] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset + 3*c.entity_indices[1][0];
    dofs[19] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[20] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[21] = offset + 3*c.entity_indices[1][1];
    dofs[22] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[23] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[24] = offset + 3*c.entity_indices[1][2];
    dofs[25] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[26] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[27] = offset + 3*c.entity_indices[2][0];
    dofs[28] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[29] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 16;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 19;
      dofs[9] = 20;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 15;
      dofs[6] = 17;
      dofs[7] = 21;
      dofs[8] = 22;
      dofs[9] = 23;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
      dofs[5] = 15;
      dofs[6] = 16;
      dofs[7] = 24;
      dofs[8] = 25;
      dofs[9] = 26;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 15;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 16;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 17;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
        dofs[3] = 18;
        dofs[4] = 19;
        dofs[5] = 20;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
        dofs[3] = 21;
        dofs[4] = 22;
        dofs[5] = 23;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
        dofs[3] = 24;
        dofs[4] = 25;
        dofs[5] = 26;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
      dofs[3] = 27;
      dofs[4] = 28;
      dofs[5] = 29;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[30] = vertex_coordinates[0];
    dof_coordinates[31] = vertex_coordinates[1];
    dof_coordinates[32] = vertex_coordinates[2];
    dof_coordinates[33] = vertex_coordinates[3];
    dof_coordinates[34] = vertex_coordinates[4];
    dof_coordinates[35] = vertex_coordinates[5];
    dof_coordinates[36] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[37] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[38] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[39] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[40] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[41] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[42] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[43] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[44] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[45] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[46] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[47] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[48] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[49] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[50] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[51] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[52] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[53] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[54] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[55] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[56] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[57] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[58] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[59] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2: public ufc::dofmap
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 4, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 4, None), **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[0] + 9*num_global_entities[1] + 9*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t num_element_dofs() const
  {
    return 45;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 15;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 9;
        break;
      }
    case 2:
      {
        return 9;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3*c.entity_indices[1][0];
    dofs[4] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[6] = offset + 3*c.entity_indices[1][1];
    dofs[7] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[8] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[9] = offset + 3*c.entity_indices[1][2];
    dofs[10] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[11] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[15] = offset + c.entity_indices[0][0];
    dofs[16] = offset + c.entity_indices[0][1];
    dofs[17] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset + 3*c.entity_indices[1][0];
    dofs[19] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[20] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[21] = offset + 3*c.entity_indices[1][1];
    dofs[22] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[23] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[24] = offset + 3*c.entity_indices[1][2];
    dofs[25] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[26] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[27] = offset + 3*c.entity_indices[2][0];
    dofs[28] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[29] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
    dofs[30] = offset + c.entity_indices[0][0];
    dofs[31] = offset + c.entity_indices[0][1];
    dofs[32] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[33] = offset + 3*c.entity_indices[1][0];
    dofs[34] = offset + 3*c.entity_indices[1][0] + 1;
    dofs[35] = offset + 3*c.entity_indices[1][0] + 2;
    dofs[36] = offset + 3*c.entity_indices[1][1];
    dofs[37] = offset + 3*c.entity_indices[1][1] + 1;
    dofs[38] = offset + 3*c.entity_indices[1][1] + 2;
    dofs[39] = offset + 3*c.entity_indices[1][2];
    dofs[40] = offset + 3*c.entity_indices[1][2] + 1;
    dofs[41] = offset + 3*c.entity_indices[1][2] + 2;
    offset += 3*num_global_entities[1];
    dofs[42] = offset + 3*c.entity_indices[2][0];
    dofs[43] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[44] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 16;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 19;
      dofs[9] = 20;
      dofs[10] = 31;
      dofs[11] = 32;
      dofs[12] = 33;
      dofs[13] = 34;
      dofs[14] = 35;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 6;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 15;
      dofs[6] = 17;
      dofs[7] = 21;
      dofs[8] = 22;
      dofs[9] = 23;
      dofs[10] = 30;
      dofs[11] = 32;
      dofs[12] = 36;
      dofs[13] = 37;
      dofs[14] = 38;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 9;
      dofs[3] = 10;
      dofs[4] = 11;
      dofs[5] = 15;
      dofs[6] = 16;
      dofs[7] = 24;
      dofs[8] = 25;
      dofs[9] = 26;
      dofs[10] = 30;
      dofs[11] = 31;
      dofs[12] = 39;
      dofs[13] = 40;
      dofs[14] = 41;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 15;
        dofs[2] = 30;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 16;
        dofs[2] = 31;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 17;
        dofs[2] = 32;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 5;
        dofs[3] = 18;
        dofs[4] = 19;
        dofs[5] = 20;
        dofs[6] = 33;
        dofs[7] = 34;
        dofs[8] = 35;
          break;
        }
      case 1:
        {
          dofs[0] = 6;
        dofs[1] = 7;
        dofs[2] = 8;
        dofs[3] = 21;
        dofs[4] = 22;
        dofs[5] = 23;
        dofs[6] = 36;
        dofs[7] = 37;
        dofs[8] = 38;
          break;
        }
      case 2:
        {
          dofs[0] = 9;
        dofs[1] = 10;
        dofs[2] = 11;
        dofs[3] = 24;
        dofs[4] = 25;
        dofs[5] = 26;
        dofs[6] = 39;
        dofs[7] = 40;
        dofs[8] = 41;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 12;
      dofs[1] = 13;
      dofs[2] = 14;
      dofs[3] = 27;
      dofs[4] = 28;
      dofs[5] = 29;
      dofs[6] = 42;
      dofs[7] = 43;
      dofs[8] = 44;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0] = vertex_coordinates[0];
    dof_coordinates[1] = vertex_coordinates[1];
    dof_coordinates[2] = vertex_coordinates[2];
    dof_coordinates[3] = vertex_coordinates[3];
    dof_coordinates[4] = vertex_coordinates[4];
    dof_coordinates[5] = vertex_coordinates[5];
    dof_coordinates[6] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[7] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[8] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[11] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[12] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[13] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[14] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[15] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[16] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[17] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[18] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[19] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[20] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[21] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[22] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[23] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[24] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[25] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[26] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[27] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[28] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[29] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[30] = vertex_coordinates[0];
    dof_coordinates[31] = vertex_coordinates[1];
    dof_coordinates[32] = vertex_coordinates[2];
    dof_coordinates[33] = vertex_coordinates[3];
    dof_coordinates[34] = vertex_coordinates[4];
    dof_coordinates[35] = vertex_coordinates[5];
    dof_coordinates[36] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[37] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[38] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[39] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[40] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[41] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[42] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[43] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[44] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[45] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[46] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[47] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[48] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[49] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[50] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[51] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[52] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[53] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[54] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[55] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[56] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[57] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[58] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[59] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[60] = vertex_coordinates[0];
    dof_coordinates[61] = vertex_coordinates[1];
    dof_coordinates[62] = vertex_coordinates[2];
    dof_coordinates[63] = vertex_coordinates[3];
    dof_coordinates[64] = vertex_coordinates[4];
    dof_coordinates[65] = vertex_coordinates[5];
    dof_coordinates[66] = 0.75*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[67] = 0.75*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[68] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[69] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[70] = 0.25*vertex_coordinates[2] + 0.75*vertex_coordinates[4];
    dof_coordinates[71] = 0.25*vertex_coordinates[3] + 0.75*vertex_coordinates[5];
    dof_coordinates[72] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[4];
    dof_coordinates[73] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[5];
    dof_coordinates[74] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[75] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[76] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[4];
    dof_coordinates[77] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[5];
    dof_coordinates[78] = 0.75*vertex_coordinates[0] + 0.25*vertex_coordinates[2];
    dof_coordinates[79] = 0.75*vertex_coordinates[1] + 0.25*vertex_coordinates[3];
    dof_coordinates[80] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[81] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[82] = 0.25*vertex_coordinates[0] + 0.75*vertex_coordinates[2];
    dof_coordinates[83] = 0.25*vertex_coordinates[1] + 0.75*vertex_coordinates[3];
    dof_coordinates[84] = 0.5*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[85] = 0.5*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[86] = 0.25*vertex_coordinates[0] + 0.5*vertex_coordinates[2] + 0.25*vertex_coordinates[4];
    dof_coordinates[87] = 0.25*vertex_coordinates[1] + 0.5*vertex_coordinates[3] + 0.25*vertex_coordinates[5];
    dof_coordinates[88] = 0.25*vertex_coordinates[0] + 0.25*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[89] = 0.25*vertex_coordinates[1] + 0.25*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_1();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_cell_integral_0_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_cell_integral_0_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    32
    // Number of operations (multiply-add pairs) for tensor contraction: 3747
    // Total number of operations (multiply-add pairs):                  3782
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*K[0]*K[0]*(1.0);
    const double G0_0_1 = det*K[0]*K[2]*(1.0);
    const double G0_1_0 = det*K[2]*K[0]*(1.0);
    const double G0_1_1 = det*K[2]*K[2]*(1.0);
    const double G1_0_0 = det*K[0]*K[0]*(1.0);
    const double G1_0_1 = det*K[0]*K[2]*(1.0);
    const double G1_1_0 = det*K[2]*K[0]*(1.0);
    const double G1_1_1 = det*K[2]*K[2]*(1.0);
    const double G2_0_0 = det*K[1]*K[1]*(1.0);
    const double G2_0_1 = det*K[1]*K[3]*(1.0);
    const double G2_1_0 = det*K[3]*K[1]*(1.0);
    const double G2_1_1 = det*K[3]*K[3]*(1.0);
    const double G3_0_0 = det*K[1]*K[1]*(1.0);
    const double G3_0_1 = det*K[1]*K[3]*(1.0);
    const double G3_1_0 = det*K[3]*K[1]*(1.0);
    const double G3_1_1 = det*K[3]*K[3]*(1.0);
    const double G4_0 = det*K[0]*(1.0);
    const double G4_1 = det*K[2]*(1.0);
    const double G5_0 = det*K[1]*(1.0);
    const double G5_1 = det*K[3]*(1.0);
    const double G6_0 = det*K[0]*(1.0);
    const double G6_1 = det*K[2]*(1.0);
    const double G7_0 = det*K[1]*(1.0);
    const double G7_1 = det*K[3]*(1.0);
    
    // Compute element tensor
    A[0] = 0.373015873015875*G0_0_0 + 0.373015873015875*G0_0_1 + 0.373015873015874*G0_1_0 + 0.373015873015874*G0_1_1 + 0.373015873015875*G2_0_0 + 0.373015873015875*G2_0_1 + 0.373015873015874*G2_1_0 + 0.373015873015874*G2_1_1;
    A[1] = 0.0566137566137567*G0_0_0 + 0.0566137566137556*G0_1_0 + 0.0566137566137567*G2_0_0 + 0.0566137566137556*G2_1_0;
    A[2] = 0.0566137566137565*G0_0_1 + 0.0566137566137561*G0_1_1 + 0.0566137566137565*G2_0_1 + 0.0566137566137561*G2_1_1;
    A[3] = 0.04232804232804*G0_0_0 + 0.0423280423280395*G0_0_1 + 0.0423280423280384*G0_1_0 + 0.0423280423280363*G0_1_1 + 0.04232804232804*G2_0_0 + 0.0423280423280395*G2_0_1 + 0.0423280423280384*G2_1_0 + 0.0423280423280363*G2_1_1;
    A[4] = 0.0423280423280401*G0_0_0 + 0.0423280423280416*G0_0_1 + 0.0423280423280413*G0_1_0 + 0.0423280423280435*G0_1_1 + 0.0423280423280401*G2_0_0 + 0.0423280423280416*G2_0_1 + 0.0423280423280413*G2_1_0 + 0.0423280423280435*G2_1_1;
    A[5] = 0.0423280423280428*G0_0_0 + 0.0423280423280417*G0_0_1 + 0.0423280423280414*G0_1_0 + 0.0423280423280404*G0_1_1 + 0.0423280423280428*G2_0_0 + 0.0423280423280417*G2_0_1 + 0.0423280423280414*G2_1_0 + 0.0423280423280404*G2_1_1;
    A[6] = 0.126984126984129*G0_0_0 - 0.651851851851853*G0_0_1 + 0.126984126984129*G0_1_0 - 0.651851851851852*G0_1_1 + 0.126984126984129*G2_0_0 - 0.651851851851853*G2_0_1 + 0.126984126984129*G2_1_0 - 0.651851851851852*G2_1_1;
    A[7] = 0.0423280423280412*G0_0_0 + 0.467724867724866*G0_0_1 + 0.0423280423280428*G0_1_0 + 0.467724867724866*G0_1_1 + 0.0423280423280412*G2_0_0 + 0.467724867724866*G2_0_1 + 0.0423280423280428*G2_1_0 + 0.467724867724866*G2_1_1;
    A[8] = -0.0423280423280427*G0_0_0 - 0.245502645502645*G0_0_1 - 0.0423280423280414*G0_1_0 - 0.245502645502645*G0_1_1 - 0.0423280423280427*G2_0_0 - 0.245502645502645*G2_0_1 - 0.0423280423280414*G2_1_0 - 0.245502645502645*G2_1_1;
    A[9] = -0.651851851851855*G0_0_0 + 0.126984126984129*G0_0_1 - 0.651851851851855*G0_1_0 + 0.126984126984128*G0_1_1 - 0.651851851851855*G2_0_0 + 0.126984126984129*G2_0_1 - 0.651851851851855*G2_1_0 + 0.126984126984128*G2_1_1;
    A[10] = 0.467724867724869*G0_0_0 + 0.0423280423280412*G0_0_1 + 0.467724867724869*G0_1_0 + 0.0423280423280402*G0_1_1 + 0.467724867724869*G2_0_0 + 0.0423280423280412*G2_0_1 + 0.467724867724869*G2_1_0 + 0.0423280423280402*G2_1_1;
    A[11] = -0.245502645502646*G0_0_0 - 0.042328042328042*G0_0_1 - 0.245502645502644*G0_1_0 - 0.0423280423280388*G0_1_1 - 0.245502645502646*G2_0_0 - 0.042328042328042*G2_0_1 - 0.245502645502644*G2_1_0 - 0.0423280423280388*G2_1_1;
    A[12] = -0.0846560846560899*G0_0_0 - 0.0846560846560888*G0_0_1 - 0.0846560846560897*G0_1_0 - 0.0846560846560862*G0_1_1 - 0.0846560846560899*G2_0_0 - 0.0846560846560888*G2_0_1 - 0.0846560846560897*G2_1_0 - 0.0846560846560862*G2_1_1;
    A[13] = -0.0846560846560792*G0_0_0 - 0.0846560846560804*G0_0_1 - 0.0846560846560777*G0_1_0 - 0.0846560846560814*G0_1_1 - 0.0846560846560792*G2_0_0 - 0.0846560846560804*G2_0_1 - 0.0846560846560777*G2_1_0 - 0.0846560846560814*G2_1_1;
    A[14] = -0.0846560846560815*G0_0_0 - 0.084656084656081*G0_0_1 - 0.0846560846560843*G0_1_0 - 0.0846560846560819*G0_1_1 - 0.0846560846560815*G2_0_0 - 0.084656084656081*G2_0_1 - 0.0846560846560843*G2_1_0 - 0.0846560846560819*G2_1_1;
    A[15] = 0.0;
    A[16] = 0.0;
    A[17] = 0.0;
    A[18] = 0.0;
    A[19] = 0.0;
    A[20] = 0.0;
    A[21] = 0.0;
    A[22] = 0.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.0;
    A[28] = 0.0;
    A[29] = 0.0;
    A[30] = -0.0257495590828924*G4_0 - 0.0257495590828924*G4_1;
    A[31] = 0.0051146384479718*G4_0 + 0.00511463844797173*G4_1;
    A[32] = 0.0051146384479718*G4_0 + 0.00511463844797179*G4_1;
    A[33] = 0.00776014109347426*G4_0 + 0.007760141093474*G4_1;
    A[34] = 0.00511463844797154*G4_0 + 0.00511463844797178*G4_1;
    A[35] = 0.00776014109347442*G4_0 + 0.00776014109347428*G4_1;
    A[36] = -0.0458553791887127*G4_0 - 0.0458553791887127*G4_1;
    A[37] = 0.0326278659611995*G4_0 + 0.0326278659611993*G4_1;
    A[38] = -0.0176366843033509*G4_0 - 0.0176366843033511*G4_1;
    A[39] = -0.0458553791887128*G4_0 - 0.0458553791887128*G4_1;
    A[40] = 0.0326278659611995*G4_0 + 0.0326278659611996*G4_1;
    A[41] = -0.017636684303351*G4_0 - 0.0176366843033513*G4_1;
    A[42] = -0.00705467372134038*G4_0 - 0.00705467372134042*G4_1;
    A[43] = -0.00705467372134065*G4_0 - 0.00705467372134074*G4_1;
    A[44] = -0.00705467372134039*G4_0 - 0.00705467372134069*G4_1;
    A[45] = 0.0566137566137567*G0_0_0 + 0.0566137566137556*G0_0_1 + 0.0566137566137567*G2_0_0 + 0.0566137566137556*G2_0_1;
    A[46] = 0.373015873015871*G0_0_0 + 0.373015873015871*G2_0_0;
    A[47] = -0.0566137566137562*G0_0_1 - 0.0566137566137562*G2_0_1;
    A[48] = 0.126984126984126*G0_0_0 + 0.778835978835976*G0_0_1 + 0.126984126984126*G2_0_0 + 0.778835978835976*G2_0_1;
    A[49] = 0.0423280423280426*G0_0_0 - 0.425396825396824*G0_0_1 + 0.0423280423280426*G2_0_0 - 0.425396825396824*G2_0_1;
    A[50] = -0.0423280423280422*G0_0_0 + 0.203174603174602*G0_0_1 - 0.0423280423280422*G2_0_0 + 0.203174603174602*G2_0_1;
    A[51] = 0.0423280423280418*G0_0_0 + 0.0423280423280418*G2_0_0;
    A[52] = 0.042328042328042*G0_0_0 + 0.042328042328042*G2_0_0;
    A[53] = 0.0423280423280422*G0_0_0 + 0.0423280423280422*G2_0_0;
    A[54] = -0.245502645502644*G0_0_0 - 0.203174603174603*G0_0_1 - 0.245502645502644*G2_0_0 - 0.203174603174603*G2_0_1;
    A[55] = 0.467724867724863*G0_0_0 + 0.425396825396823*G0_0_1 + 0.467724867724863*G2_0_0 + 0.425396825396823*G2_0_1;
    A[56] = -0.651851851851847*G0_0_0 - 0.778835978835975*G0_0_1 - 0.651851851851847*G2_0_0 - 0.778835978835975*G2_0_1;
    A[57] = -0.0846560846560837*G0_0_0 - 0.0846560846560837*G2_0_0;
    A[58] = -0.0846560846560839*G0_0_0 - 0.0846560846560839*G2_0_0;
    A[59] = -0.0846560846560845*G0_0_0 - 0.0846560846560845*G2_0_0;
    A[60] = 0.0;
    A[61] = 0.0;
    A[62] = 0.0;
    A[63] = 0.0;
    A[64] = 0.0;
    A[65] = 0.0;
    A[66] = 0.0;
    A[67] = 0.0;
    A[68] = 0.0;
    A[69] = 0.0;
    A[70] = 0.0;
    A[71] = 0.0;
    A[72] = 0.0;
    A[73] = 0.0;
    A[74] = 0.0;
    A[75] = -0.00511463844797179*G4_0;
    A[76] = 0.0257495590828923*G4_0;
    A[77] = -0.00511463844797177*G4_0;
    A[78] = 0.0458553791887123*G4_0;
    A[79] = -0.0326278659611992*G4_0;
    A[80] = 0.0176366843033509*G4_0;
    A[81] = -0.00776014109347446*G4_0;
    A[82] = -0.00511463844797175*G4_0;
    A[83] = -0.00776014109347439*G4_0;
    A[84] = 0.0176366843033509*G4_0;
    A[85] = -0.0326278659611991*G4_0;
    A[86] = 0.0458553791887123*G4_0;
    A[87] = 0.00705467372134055*G4_0;
    A[88] = 0.00705467372134029*G4_0;
    A[89] = 0.00705467372134037*G4_0;
    A[90] = 0.0566137566137565*G0_1_0 + 0.0566137566137561*G0_1_1 + 0.0566137566137565*G2_1_0 + 0.0566137566137561*G2_1_1;
    A[91] = -0.0566137566137562*G0_1_0 - 0.0566137566137562*G2_1_0;
    A[92] = 0.373015873015871*G0_1_1 + 0.373015873015871*G2_1_1;
    A[93] = 0.203174603174604*G0_1_0 - 0.0423280423280405*G0_1_1 + 0.203174603174604*G2_1_0 - 0.0423280423280405*G2_1_1;
    A[94] = -0.425396825396826*G0_1_0 + 0.0423280423280393*G0_1_1 - 0.425396825396826*G2_1_0 + 0.0423280423280393*G2_1_1;
    A[95] = 0.778835978835978*G0_1_0 + 0.126984126984128*G0_1_1 + 0.778835978835978*G2_1_0 + 0.126984126984128*G2_1_1;
    A[96] = -0.203174603174604*G0_1_0 - 0.245502645502645*G0_1_1 - 0.203174603174604*G2_1_0 - 0.245502645502645*G2_1_1;
    A[97] = 0.425396825396827*G0_1_0 + 0.467724867724867*G0_1_1 + 0.425396825396827*G2_1_0 + 0.467724867724867*G2_1_1;
    A[98] = -0.778835978835978*G0_1_0 - 0.651851851851849*G0_1_1 - 0.778835978835978*G2_1_0 - 0.651851851851849*G2_1_1;
    A[99] = 0.0423280423280409*G0_1_1 + 0.0423280423280409*G2_1_1;
    A[100] = 0.042328042328042*G0_1_1 + 0.042328042328042*G2_1_1;
    A[101] = 0.0423280423280423*G0_1_1 + 0.0423280423280423*G2_1_1;
    A[102] = -0.0846560846560822*G0_1_1 - 0.0846560846560822*G2_1_1;
    A[103] = -0.0846560846560844*G0_1_1 - 0.0846560846560844*G2_1_1;
    A[104] = -0.0846560846560861*G0_1_1 - 0.0846560846560861*G2_1_1;
    A[105] = 0.0;
    A[106] = 0.0;
    A[107] = 0.0;
    A[108] = 0.0;
    A[109] = 0.0;
    A[110] = 0.0;
    A[111] = 0.0;
    A[112] = 0.0;
    A[113] = 0.0;
    A[114] = 0.0;
    A[115] = 0.0;
    A[116] = 0.0;
    A[117] = 0.0;
    A[118] = 0.0;
    A[119] = 0.0;
    A[120] = -0.00511463844797176*G4_1;
    A[121] = -0.00511463844797177*G4_1;
    A[122] = 0.0257495590828923*G4_1;
    A[123] = 0.017636684303351*G4_1;
    A[124] = -0.0326278659611993*G4_1;
    A[125] = 0.0458553791887124*G4_1;
    A[126] = 0.017636684303351*G4_1;
    A[127] = -0.0326278659611992*G4_1;
    A[128] = 0.0458553791887124*G4_1;
    A[129] = -0.00776014109347434*G4_1;
    A[130] = -0.00511463844797176*G4_1;
    A[131] = -0.00776014109347433*G4_1;
    A[132] = 0.00705467372134057*G4_1;
    A[133] = 0.00705467372134054*G4_1;
    A[134] = 0.00705467372134003*G4_1;
    A[135] = 0.04232804232804*G0_0_0 + 0.0423280423280384*G0_0_1 + 0.0423280423280395*G0_1_0 + 0.0423280423280363*G0_1_1 + 0.04232804232804*G2_0_0 + 0.0423280423280384*G2_0_1 + 0.0423280423280395*G2_1_0 + 0.0423280423280363*G2_1_1;
    A[136] = 0.126984126984126*G0_0_0 + 0.778835978835976*G0_1_0 + 0.126984126984126*G2_0_0 + 0.778835978835976*G2_1_0;
    A[137] = 0.203174603174604*G0_0_1 - 0.0423280423280405*G0_1_1 + 0.203174603174604*G2_0_1 - 0.0423280423280405*G2_1_1;
    A[138] = 1.82857142857142*G0_0_0 + 1.04973544973545*G0_0_1 + 1.04973544973545*G0_1_0 + 2.0994708994709*G0_1_1 + 1.82857142857142*G2_0_0 + 1.04973544973545*G2_0_1 + 1.04973544973545*G2_1_0 + 2.0994708994709*G2_1_1;
    A[139] = -0.660317460317459*G0_0_0 + 0.821164021164017*G0_0_1 - 0.296296296296294*G0_1_0 - 0.761904761904761*G0_1_1 - 0.660317460317459*G2_0_0 + 0.821164021164017*G2_0_1 - 0.296296296296294*G2_1_0 - 0.761904761904761*G2_1_1;
    A[140] = 0.33862433862434*G0_0_0 - 0.44021164021164*G0_0_1 + 0.101587301587306*G0_1_0 + 0.33862433862434*G0_1_1 + 0.33862433862434*G2_0_0 - 0.44021164021164*G2_0_1 + 0.101587301587306*G2_1_0 + 0.33862433862434*G2_1_1;
    A[141] = -0.203174603174601*G0_0_0 - 0.101587301587295*G0_0_1 - 0.101587301587307*G0_1_0 - 0.203174603174601*G2_0_0 - 0.101587301587295*G2_0_1 - 0.101587301587307*G2_1_0;
    A[142] = -0.152380952380952*G0_0_0 - 0.0423280423280416*G0_0_1 - 0.0423280423280379*G0_1_0 - 0.152380952380952*G2_0_0 - 0.0423280423280416*G2_0_1 - 0.0423280423280379*G2_1_0;
    A[143] = -0.33862433862434*G0_0_0 - 0.101587301587298*G0_0_1 - 0.101587301587305*G0_1_0 - 0.33862433862434*G2_0_0 - 0.101587301587298*G2_0_1 - 0.101587301587305*G2_1_0;
    A[144] = -0.135449735449728*G0_0_0 - 0.237037037037036*G0_0_1 - 0.237037037037028*G0_1_0 - 0.338624338624343*G0_1_1 - 0.135449735449728*G2_0_0 - 0.237037037037036*G2_0_1 - 0.237037037037028*G2_1_0 - 0.338624338624343*G2_1_1;
    A[145] = 0.101587301587291*G0_0_0 + 0.465608465608462*G0_0_1 + 0.46560846560845*G0_1_0 + 0.761904761904757*G0_1_1 + 0.101587301587291*G2_0_0 + 0.465608465608462*G2_0_1 + 0.46560846560845*G2_1_0 + 0.761904761904757*G2_1_1;
    A[146] = -0.135449735449728*G0_0_0 - 1.04973544973544*G0_0_1 - 1.04973544973544*G0_1_0 - 2.09947089947089*G0_1_1 - 0.135449735449728*G2_0_0 - 1.04973544973544*G2_0_1 - 1.04973544973544*G2_1_0 - 2.09947089947089*G2_1_1;
    A[147] = 0.812698412698406*G0_0_0 + 0.338624338624332*G0_0_1 + 0.338624338624346*G0_1_0 + 0.812698412698406*G2_0_0 + 0.338624338624332*G2_0_1 + 0.338624338624346*G2_1_0;
    A[148] = -2.43809523809523*G0_0_0 - 1.28677248677248*G0_0_1 - 1.28677248677249*G0_1_0 - 2.43809523809523*G2_0_0 - 1.28677248677248*G2_0_1 - 1.28677248677249*G2_1_0;
    A[149] = 0.81269841269841*G0_0_0 + 0.338624338624333*G0_0_1 + 0.338624338624331*G0_1_0 - 1.52950568876875e-14*G0_1_1 + 0.81269841269841*G2_0_0 + 0.338624338624333*G2_0_1 + 0.338624338624331*G2_1_0 - 1.52950568876875e-14*G2_1_1;
    A[150] = 0.0;
    A[151] = 0.0;
    A[152] = 0.0;
    A[153] = 0.0;
    A[154] = 0.0;
    A[155] = 0.0;
    A[156] = 0.0;
    A[157] = 0.0;
    A[158] = 0.0;
    A[159] = 0.0;
    A[160] = 0.0;
    A[161] = 0.0;
    A[162] = 0.0;
    A[163] = 0.0;
    A[164] = 0.0;
    A[165] = -0.00776014109347438*G4_0 - 0.00776014109347429*G4_1;
    A[166] = 0.00634920634920633*G4_0 + 0.0522045855379187*G4_1;
    A[167] = 0.00987654320987657*G4_0 - 0.00776014109347437*G4_1;
    A[168] = 0.158024691358024*G4_0 + 0.158024691358024*G4_1;
    A[169] = -0.016931216931217*G4_0 - 0.0902998236331568*G4_1;
    A[170] = 0.0451499118165789*G4_1;
    A[171] = 0.0225749559082893*G4_0 + 0.0112874779541452*G4_1;
    A[172] = 0.0169312169312168*G4_0 + 0.00282186948853558*G4_1;
    A[173] = 0.0451499118165786*G4_0 + 0.011287477954145*G4_1;
    A[174] = 0.033862433862434*G4_0 + 0.0451499118165791*G4_1;
    A[175] = -0.0592592592592591*G4_0 - 0.0902998236331569*G4_1;
    A[176] = 0.0790123456790122*G4_0 + 0.158024691358025*G4_1;
    A[177] = -0.0677248677248676*G4_0 - 0.0225749559082888*G4_1;
    A[178] = 0.203174603174603*G4_0 + 0.112874779541446*G4_1;
    A[179] = -0.0677248677248675*G4_0 - 0.0225749559082892*G4_1;
    A[180] = 0.0423280423280401*G0_0_0 + 0.0423280423280413*G0_0_1 + 0.0423280423280416*G0_1_0 + 0.0423280423280435*G0_1_1 + 0.0423280423280401*G2_0_0 + 0.0423280423280413*G2_0_1 + 0.0423280423280416*G2_1_0 + 0.0423280423280435*G2_1_1;
    A[181] = 0.0423280423280426*G0_0_0 - 0.425396825396824*G0_1_0 + 0.0423280423280426*G2_0_0 - 0.425396825396824*G2_1_0;
    A[182] = -0.425396825396826*G0_0_1 + 0.0423280423280394*G0_1_1 - 0.425396825396826*G2_0_1 + 0.0423280423280394*G2_1_1;
    A[183] = -0.660317460317459*G0_0_0 - 0.296296296296294*G0_0_1 + 0.821164021164018*G0_1_0 - 0.761904761904761*G0_1_1 - 0.660317460317459*G2_0_0 - 0.296296296296294*G2_0_1 + 0.821164021164018*G2_1_0 - 0.761904761904761*G2_1_1;
    A[184] = 2.45079365079365*G0_0_0 + 0.971428571428569*G0_0_1 + 0.971428571428569*G0_1_0 + 2.45079365079364*G0_1_1 + 2.45079365079365*G2_0_0 + 0.971428571428569*G2_0_1 + 0.971428571428569*G2_1_0 + 2.45079365079364*G2_1_1;
    A[185] = -0.761904761904765*G0_0_0 + 0.821164021164017*G0_0_1 - 0.296296296296305*G0_1_0 - 0.660317460317466*G0_1_1 - 0.761904761904765*G2_0_0 + 0.821164021164017*G2_0_1 - 0.296296296296305*G2_1_0 - 0.660317460317466*G2_1_1;
    A[186] = -0.152380952380946*G0_0_0 - 0.110052910052908*G0_0_1 - 0.110052910052895*G0_1_0 - 0.0677248677248669*G0_1_1 - 0.152380952380946*G2_0_0 - 0.110052910052908*G2_0_1 - 0.110052910052895*G2_1_0 - 0.0677248677248669*G2_1_1;
    A[187] = 0.393650793650788*G0_0_0 + 0.196825396825396*G0_0_1 + 0.196825396825387*G0_1_0 + 0.0507936507936495*G0_1_1 + 0.393650793650788*G2_0_0 + 0.196825396825396*G2_0_1 + 0.196825396825387*G2_1_0 + 0.0507936507936495*G2_1_1;
    A[188] = 0.761904761904765*G0_0_0 + 0.296296296296298*G0_0_1 + 0.296296296296305*G0_1_0 - 0.0677248677248641*G0_1_1 + 0.761904761904765*G2_0_0 + 0.296296296296298*G2_0_1 + 0.296296296296305*G2_1_0 - 0.0677248677248641*G2_1_1;
    A[189] = -0.067724867724864*G0_0_0 - 0.110052910052907*G0_0_1 - 0.110052910052908*G0_1_0 - 0.152380952380943*G0_1_1 - 0.067724867724864*G2_0_0 - 0.110052910052907*G2_0_1 - 0.110052910052908*G2_1_0 - 0.152380952380943*G2_1_1;
    A[190] = 0.0507936507936503*G0_0_0 + 0.196825396825396*G0_0_1 + 0.196825396825396*G0_1_0 + 0.393650793650791*G0_1_1 + 0.0507936507936503*G2_0_0 + 0.196825396825396*G2_0_1 + 0.196825396825396*G2_1_0 + 0.393650793650791*G2_1_1;
    A[191] = -0.0677248677248689*G0_0_0 + 0.296296296296295*G0_0_1 + 0.296296296296294*G0_1_0 + 0.761904761904762*G0_1_1 - 0.0677248677248689*G2_0_0 + 0.296296296296295*G2_0_1 + 0.296296296296294*G2_1_0 + 0.761904761904762*G2_1_1;
    A[192] = 0.406349206349193*G0_0_0 + 0.457142857142842*G0_0_1 + 0.457142857142832*G0_1_0 + 0.406349206349181*G0_1_1 + 0.406349206349193*G2_0_0 + 0.457142857142842*G2_0_1 + 0.457142857142832*G2_1_0 + 0.406349206349181*G2_1_1;
    A[193] = 0.406349206349211*G0_0_0 - 1.16825396825397*G0_0_1 - 1.16825396825395*G0_1_0 - 2.84444444444444*G0_1_1 + 0.406349206349211*G2_0_0 - 1.16825396825397*G2_0_1 - 1.16825396825395*G2_1_0 - 2.84444444444444*G2_1_1;
    A[194] = -2.84444444444443*G0_0_0 - 1.16825396825395*G0_0_1 - 1.16825396825396*G0_1_0 + 0.406349206349225*G0_1_1 - 2.84444444444443*G2_0_0 - 1.16825396825395*G2_0_1 - 1.16825396825396*G2_1_0 + 0.406349206349225*G2_1_1;
    A[195] = 0.0;
    A[196] = 0.0;
    A[197] = 0.0;
    A[198] = 0.0;
    A[199] = 0.0;
    A[200] = 0.0;
    A[201] = 0.0;
    A[202] = 0.0;
    A[203] = 0.0;
    A[204] = 0.0;
    A[205] = 0.0;
    A[206] = 0.0;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = -0.00511463844797178*G4_0 - 0.00511463844797192*G4_1;
    A[211] = 0.00194003527336863*G4_0 - 0.0306878306878306*G4_1;
    A[212] = -0.0306878306878308*G4_0 + 0.00194003527336844*G4_1;
    A[213] = -0.0507936507936507*G4_0 + 0.022574955908289*G4_1;
    A[214] = 0.165079365079365*G4_0 + 0.165079365079365*G4_1;
    A[215] = 0.022574955908289*G4_0 - 0.0507936507936514*G4_1;
    A[216] = 0.0169312169312169*G4_0 + 0.0141093474426799*G4_1;
    A[217] = -0.021164021164021*G4_0 - 0.0105820105820098*G4_1;
    A[218] = -0.0902998236331572*G4_0 - 0.0310405643738984*G4_1;
    A[219] = 0.0141093474426807*G4_0 + 0.0169312169312162*G4_1;
    A[220] = -0.0105820105820106*G4_0 - 0.0211640211640208*G4_1;
    A[221] = -0.0310405643738975*G4_0 - 0.0902998236331571*G4_1;
    A[222] = -0.0846560846560842*G4_0 - 0.0846560846560849*G4_1;
    A[223] = 0.0507936507936509*G4_0 + 0.186243386243386*G4_1;
    A[224] = 0.186243386243386*G4_0 + 0.05079365079365*G4_1;
    A[225] = 0.0423280423280428*G0_0_0 + 0.0423280423280414*G0_0_1 + 0.0423280423280417*G0_1_0 + 0.0423280423280404*G0_1_1 + 0.0423280423280428*G2_0_0 + 0.0423280423280414*G2_0_1 + 0.0423280423280417*G2_1_0 + 0.0423280423280404*G2_1_1;
    A[226] = -0.0423280423280422*G0_0_0 + 0.203174603174602*G0_1_0 - 0.0423280423280422*G2_0_0 + 0.203174603174602*G2_1_0;
    A[227] = 0.778835978835978*G0_0_1 + 0.126984126984128*G0_1_1 + 0.778835978835978*G2_0_1 + 0.126984126984128*G2_1_1;
    A[228] = 0.33862433862434*G0_0_0 + 0.101587301587305*G0_0_1 - 0.44021164021164*G0_1_0 + 0.33862433862434*G0_1_1 + 0.33862433862434*G2_0_0 + 0.101587301587305*G2_0_1 - 0.44021164021164*G2_1_0 + 0.33862433862434*G2_1_1;
    A[229] = -0.761904761904765*G0_0_0 - 0.296296296296305*G0_0_1 + 0.821164021164017*G0_1_0 - 0.660317460317466*G0_1_1 - 0.761904761904765*G2_0_0 - 0.296296296296305*G2_0_1 + 0.821164021164017*G2_1_0 - 0.660317460317466*G2_1_1;
    A[230] = 2.09947089947091*G0_0_0 + 1.04973544973546*G0_0_1 + 1.04973544973546*G0_1_0 + 1.82857142857143*G0_1_1 + 2.09947089947091*G2_0_0 + 1.04973544973546*G2_0_1 + 1.04973544973546*G2_1_0 + 1.82857142857143*G2_1_1;
    A[231] = -0.338624338624341*G0_0_0 - 0.237037037037037*G0_0_1 - 0.237037037037039*G0_1_0 - 0.135449735449733*G0_1_1 - 0.338624338624341*G2_0_0 - 0.237037037037037*G2_0_1 - 0.237037037037039*G2_1_0 - 0.135449735449733*G2_1_1;
    A[232] = 0.761904761904769*G0_0_0 + 0.465608465608467*G0_0_1 + 0.465608465608474*G0_1_0 + 0.101587301587304*G0_1_1 + 0.761904761904769*G2_0_0 + 0.465608465608467*G2_0_1 + 0.465608465608474*G2_1_0 + 0.101587301587304*G2_1_1;
    A[233] = -2.09947089947091*G0_0_0 - 1.04973544973545*G0_0_1 - 1.04973544973546*G0_1_0 - 0.135449735449735*G0_1_1 - 2.09947089947091*G2_0_0 - 1.04973544973545*G2_0_1 - 1.04973544973546*G2_1_0 - 0.135449735449735*G2_1_1;
    A[234] = -0.101587301587305*G0_0_1 - 0.1015873015873*G0_1_0 - 0.203174603174607*G0_1_1 - 0.101587301587305*G2_0_1 - 0.1015873015873*G2_1_0 - 0.203174603174607*G2_1_1;
    A[235] = -0.0423280423280413*G0_0_1 - 0.0423280423280442*G0_1_0 - 0.152380952380951*G0_1_1 - 0.0423280423280413*G2_0_1 - 0.0423280423280442*G2_1_0 - 0.152380952380951*G2_1_1;
    A[236] = -0.101587301587298*G0_0_1 - 0.1015873015873*G0_1_0 - 0.338624338624333*G0_1_1 - 0.101587301587298*G2_0_1 - 0.1015873015873*G2_1_0 - 0.338624338624333*G2_1_1;
    A[237] = 0.338624338624346*G0_0_1 + 0.338624338624342*G0_1_0 + 0.812698412698421*G0_1_1 + 0.338624338624346*G2_0_1 + 0.338624338624342*G2_1_0 + 0.812698412698421*G2_1_1;
    A[238] = 0.338624338624336*G0_0_1 + 0.338624338624336*G0_1_0 + 0.812698412698409*G0_1_1 + 0.338624338624336*G2_0_1 + 0.338624338624336*G2_1_0 + 0.812698412698409*G2_1_1;
    A[239] = -1.2867724867725*G0_0_1 - 1.28677248677249*G0_1_0 - 2.43809523809525*G0_1_1 - 1.2867724867725*G2_0_1 - 1.28677248677249*G2_1_0 - 2.43809523809525*G2_1_1;
    A[240] = 0.0;
    A[241] = 0.0;
    A[242] = 0.0;
    A[243] = 0.0;
    A[244] = 0.0;
    A[245] = 0.0;
    A[246] = 0.0;
    A[247] = 0.0;
    A[248] = 0.0;
    A[249] = 0.0;
    A[250] = 0.0;
    A[251] = 0.0;
    A[252] = 0.0;
    A[253] = 0.0;
    A[254] = 0.0;
    A[255] = -0.00776014109347446*G4_0 - 0.00776014109347438*G4_1;
    A[256] = -0.00776014109347447*G4_0 + 0.00987654320987643*G4_1;
    A[257] = 0.0522045855379189*G4_0 + 0.00634920634920647*G4_1;
    A[258] = 0.0451499118165785*G4_0;
    A[259] = -0.0902998236331571*G4_0 - 0.016931216931217*G4_1;
    A[260] = 0.158024691358025*G4_0 + 0.158024691358025*G4_1;
    A[261] = 0.0451499118165785*G4_0 + 0.0338624338624341*G4_1;
    A[262] = -0.090299823633157*G4_0 - 0.0592592592592598*G4_1;
    A[263] = 0.158024691358025*G4_0 + 0.0790123456790126*G4_1;
    A[264] = 0.0112874779541446*G4_0 + 0.0225749559082893*G4_1;
    A[265] = 0.00282186948853619*G4_0 + 0.016931216931217*G4_1;
    A[266] = 0.0112874779541446*G4_0 + 0.0451499118165783*G4_1;
    A[267] = -0.0225749559082894*G4_0 - 0.067724867724868*G4_1;
    A[268] = -0.0225749559082894*G4_0 - 0.0677248677248683*G4_1;
    A[269] = 0.112874779541446*G4_0 + 0.203174603174603*G4_1;
    A[270] = 0.126984126984129*G0_0_0 + 0.126984126984129*G0_0_1 - 0.651851851851853*G0_1_0 - 0.651851851851852*G0_1_1 + 0.126984126984129*G2_0_0 + 0.126984126984129*G2_0_1 - 0.651851851851853*G2_1_0 - 0.651851851851852*G2_1_1;
    A[271] = 0.0423280423280418*G0_0_0 + 0.0423280423280418*G2_0_0;
    A[272] = -0.203174603174604*G0_0_1 - 0.245502645502645*G0_1_1 - 0.203174603174604*G2_0_1 - 0.245502645502645*G2_1_1;
    A[273] = -0.203174603174601*G0_0_0 - 0.101587301587307*G0_0_1 - 0.101587301587295*G0_1_0 - 0.203174603174601*G2_0_0 - 0.101587301587307*G2_0_1 - 0.101587301587295*G2_1_0;
    A[274] = -0.152380952380946*G0_0_0 - 0.110052910052895*G0_0_1 - 0.110052910052908*G0_1_0 - 0.067724867724867*G0_1_1 - 0.152380952380946*G2_0_0 - 0.110052910052895*G2_0_1 - 0.110052910052908*G2_1_0 - 0.067724867724867*G2_1_1;
    A[275] = -0.338624338624341*G0_0_0 - 0.237037037037039*G0_0_1 - 0.237037037037037*G0_1_0 - 0.135449735449734*G0_1_1 - 0.338624338624341*G2_0_0 - 0.237037037037039*G2_0_1 - 0.237037037037037*G2_1_0 - 0.135449735449734*G2_1_1;
    A[276] = 1.82857142857143*G0_0_0 + 0.778835978835979*G0_0_1 + 0.778835978835978*G0_1_0 + 1.82857142857143*G0_1_1 + 1.82857142857143*G2_0_0 + 0.778835978835979*G2_0_1 + 0.778835978835978*G2_1_0 + 1.82857142857143*G2_1_1;
    A[277] = -0.660317460317455*G0_0_0 - 1.48148148148148*G0_0_1 - 0.364021164021164*G0_1_0 - 1.94708994708994*G0_1_1 - 0.660317460317455*G2_0_0 - 1.48148148148148*G2_0_1 - 0.364021164021164*G2_1_0 - 1.94708994708994*G2_1_1;
    A[278] = 0.338624338624341*G0_0_0 + 0.778835978835976*G0_0_1 + 0.237037037037037*G0_1_0 + 1.01587301587301*G0_1_1 + 0.338624338624341*G2_0_0 + 0.778835978835976*G2_0_1 + 0.237037037037037*G2_1_0 + 1.01587301587301*G2_1_1;
    A[279] = -0.135449735449741*G0_0_0 + 0.914285714285713*G0_0_1 + 0.914285714285717*G0_1_0 - 0.135449735449735*G0_1_1 - 0.135449735449741*G2_0_0 + 0.914285714285713*G2_0_1 + 0.914285714285717*G2_1_0 - 0.135449735449735*G2_1_1;
    A[280] = 0.101587301587306*G0_0_0 - 0.364021164021163*G0_0_1 - 0.364021164021165*G0_1_0 - 0.0677248677248648*G0_1_1 + 0.101587301587306*G2_0_0 - 0.364021164021163*G2_0_1 - 0.364021164021165*G2_1_0 - 0.0677248677248648*G2_1_1;
    A[281] = -0.135449735449736*G0_0_0 + 0.1015873015873*G0_0_1 + 0.101587301587299*G0_1_0 - 0.135449735449736*G2_0_0 + 0.1015873015873*G2_0_1 + 0.101587301587299*G2_1_0;
    A[282] = -2.43809523809524*G0_0_0 - 1.15132275132275*G0_0_1 - 1.15132275132275*G0_1_0 + 0.135449735449735*G0_1_1 - 2.43809523809524*G2_0_0 - 1.15132275132275*G2_0_1 - 1.15132275132275*G2_1_0 + 0.135449735449735*G2_1_1;
    A[283] = 0.812698412698416*G0_0_0 + 0.474074074074066*G0_0_1 + 0.474074074074065*G0_1_0 + 0.135449735449731*G0_1_1 + 0.812698412698416*G2_0_0 + 0.474074074074066*G2_0_1 + 0.474074074074065*G2_1_0 + 0.135449735449731*G2_1_1;
    A[284] = 0.812698412698401*G0_0_0 + 0.474074074074077*G0_0_1 + 0.474074074074071*G0_1_0 + 0.135449735449732*G0_1_1 + 0.812698412698401*G2_0_0 + 0.474074074074077*G2_0_1 + 0.474074074074071*G2_1_0 + 0.135449735449732*G2_1_1;
    A[285] = 0.0;
    A[286] = 0.0;
    A[287] = 0.0;
    A[288] = 0.0;
    A[289] = 0.0;
    A[290] = 0.0;
    A[291] = 0.0;
    A[292] = 0.0;
    A[293] = 0.0;
    A[294] = 0.0;
    A[295] = 0.0;
    A[296] = 0.0;
    A[297] = 0.0;
    A[298] = 0.0;
    A[299] = 0.0;
    A[300] = -0.00634920634920632*G4_0 + 0.0458553791887124*G4_1;
    A[301] = 0.0077601410934744*G4_0;
    A[302] = -0.00987654320987659*G4_0 - 0.017636684303351*G4_1;
    A[303] = -0.0225749559082891*G4_0 - 0.011287477954144*G4_1;
    A[304] = -0.0169312169312162*G4_0 - 0.0141093474426806*G4_1;
    A[305] = -0.0451499118165785*G4_0 - 0.0338624338624336*G4_1;
    A[306] = -0.158024691358025*G4_0;
    A[307] = 0.0169312169312165*G4_0 - 0.07336860670194*G4_1;
    A[308] = 0.0451499118165784*G4_1;
    A[309] = -0.0790123456790122*G4_0 + 0.0790123456790125*G4_1;
    A[310] = 0.0592592592592591*G4_0 - 0.0310405643738981*G4_1;
    A[311] = -0.033862433862434*G4_0 + 0.0112874779541449*G4_1;
    A[312] = -0.203174603174604*G4_0 - 0.0902998236331575*G4_1;
    A[313] = 0.0677248677248689*G4_0 + 0.0451499118165792*G4_1;
    A[314] = 0.0677248677248677*G4_0 + 0.0451499118165788*G4_1;
    A[315] = 0.0423280423280412*G0_0_0 + 0.0423280423280428*G0_0_1 + 0.467724867724866*G0_1_0 + 0.467724867724866*G0_1_1 + 0.0423280423280412*G2_0_0 + 0.0423280423280428*G2_0_1 + 0.467724867724866*G2_1_0 + 0.467724867724866*G2_1_1;
    A[316] = 0.042328042328042*G0_0_0 + 0.042328042328042*G2_0_0;
    A[317] = 0.425396825396827*G0_0_1 + 0.467724867724867*G0_1_1 + 0.425396825396827*G2_0_1 + 0.467724867724867*G2_1_1;
    A[318] = -0.152380952380952*G0_0_0 - 0.0423280423280379*G0_0_1 - 0.0423280423280416*G0_1_0 - 0.152380952380952*G2_0_0 - 0.0423280423280379*G2_0_1 - 0.0423280423280416*G2_1_0;
    A[319] = 0.393650793650788*G0_0_0 + 0.196825396825387*G0_0_1 + 0.196825396825396*G0_1_0 + 0.0507936507936495*G0_1_1 + 0.393650793650788*G2_0_0 + 0.196825396825387*G2_0_1 + 0.196825396825396*G2_1_0 + 0.0507936507936495*G2_1_1;
    A[320] = 0.761904761904769*G0_0_0 + 0.465608465608474*G0_0_1 + 0.465608465608467*G0_1_0 + 0.101587301587304*G0_1_1 + 0.761904761904769*G2_0_0 + 0.465608465608474*G2_0_1 + 0.465608465608467*G2_1_0 + 0.101587301587304*G2_1_1;
    A[321] = -0.660317460317455*G0_0_0 - 0.364021164021164*G0_0_1 - 1.48148148148148*G0_1_0 - 1.94708994708994*G0_1_1 - 0.660317460317455*G2_0_0 - 0.364021164021164*G2_0_1 - 1.48148148148148*G2_1_0 - 1.94708994708994*G2_1_1;
    A[322] = 2.45079365079365*G0_0_0 + 1.47936507936508*G0_0_1 + 1.47936507936508*G0_1_0 + 2.95873015873015*G0_1_1 + 2.45079365079365*G2_0_0 + 1.47936507936508*G2_0_1 + 1.47936507936508*G2_1_0 + 2.95873015873015*G2_1_1;
    A[323] = -0.761904761904769*G0_0_0 - 1.58306878306878*G0_0_1 - 0.465608465608467*G0_1_0 - 1.94708994708994*G0_1_1 - 0.761904761904769*G2_0_0 - 1.58306878306878*G2_0_1 - 0.465608465608467*G2_1_0 - 1.94708994708994*G2_1_1;
    A[324] = -0.0677248677248647*G0_0_0 - 0.36402116402116*G0_0_1 - 0.364021164021163*G0_1_0 + 0.101587301587297*G0_1_1 - 0.0677248677248647*G2_0_0 - 0.36402116402116*G2_0_1 - 0.364021164021163*G2_1_0 + 0.101587301587297*G2_1_1;
    A[325] = 0.0507936507936486*G0_0_0 - 0.146031746031748*G0_0_1 - 0.146031746031746*G0_1_0 + 0.0507936507936495*G0_1_1 + 0.0507936507936486*G2_0_0 - 0.146031746031748*G2_0_1 - 0.146031746031746*G2_1_0 + 0.0507936507936495*G2_1_1;
    A[326] = -0.067724867724867*G0_0_0 + 0.0423280423280398*G0_0_1 + 0.0423280423280429*G0_1_0 - 0.067724867724867*G2_0_0 + 0.0423280423280398*G2_0_1 + 0.0423280423280429*G2_1_0;
    A[327] = 0.406349206349198*G0_0_0 + 1.57460317460317*G0_0_1 + 1.57460317460318*G0_1_0 - 0.101587301587297*G0_1_1 + 0.406349206349198*G2_0_0 + 1.57460317460317*G2_0_1 + 1.57460317460318*G2_1_0 - 0.101587301587297*G2_1_1;
    A[328] = 0.40634920634921*G0_0_0 - 0.0507936507936399*G0_0_1 - 0.050793650793651*G0_1_0 - 0.1015873015873*G0_1_1 + 0.40634920634921*G2_0_0 - 0.0507936507936399*G2_0_1 - 0.050793650793651*G2_1_0 - 0.1015873015873*G2_1_1;
    A[329] = -2.84444444444443*G0_0_0 - 1.67619047619048*G0_0_1 - 1.67619047619047*G0_1_0 - 0.101587301587302*G0_1_1 - 2.84444444444443*G2_0_0 - 1.67619047619048*G2_0_1 - 1.67619047619047*G2_1_0 - 0.101587301587302*G2_1_1;
    A[330] = 0.0;
    A[331] = 0.0;
    A[332] = 0.0;
    A[333] = 0.0;
    A[334] = 0.0;
    A[335] = 0.0;
    A[336] = 0.0;
    A[337] = 0.0;
    A[338] = 0.0;
    A[339] = 0.0;
    A[340] = 0.0;
    A[341] = 0.0;
    A[342] = 0.0;
    A[343] = 0.0;
    A[344] = 0.0;
    A[345] = -0.00194003527336868*G4_0 - 0.0326278659611991*G4_1;
    A[346] = 0.00511463844797175*G4_0;
    A[347] = 0.0306878306878308*G4_0 + 0.0326278659611992*G4_1;
    A[348] = -0.0169312169312168*G4_0 - 0.00282186948853604*G4_1;
    A[349] = 0.0211640211640207*G4_0 + 0.0105820105820104*G4_1;
    A[350] = 0.0902998236331573*G4_0 + 0.0592592592592593*G4_1;
    A[351] = 0.0507936507936507*G4_0 + 0.0733686067019404*G4_1;
    A[352] = -0.165079365079365*G4_0;
    A[353] = -0.0225749559082889*G4_0 - 0.0733686067019396*G4_1;
    A[354] = 0.0310405643738975*G4_0 - 0.0592592592592587*G4_1;
    A[355] = 0.0105820105820106*G4_0 - 0.0105820105820106*G4_1;
    A[356] = -0.0141093474426807*G4_0 + 0.00282186948853644*G4_1;
    A[357] = -0.0507936507936505*G4_0 + 0.135449735449736*G4_1;
    A[358] = 0.0846560846560838*G4_0;
    A[359] = -0.186243386243386*G4_0 - 0.135449735449736*G4_1;
    A[360] = -0.0423280423280427*G0_0_0 - 0.0423280423280414*G0_0_1 - 0.245502645502645*G0_1_0 - 0.245502645502645*G0_1_1 - 0.0423280423280427*G2_0_0 - 0.0423280423280414*G2_0_1 - 0.245502645502645*G2_1_0 - 0.245502645502645*G2_1_1;
    A[361] = 0.0423280423280422*G0_0_0 + 0.0423280423280422*G2_0_0;
    A[362] = -0.778835978835978*G0_0_1 - 0.651851851851849*G0_1_1 - 0.778835978835978*G2_0_1 - 0.651851851851849*G2_1_1;
    A[363] = -0.33862433862434*G0_0_0 - 0.101587301587305*G0_0_1 - 0.101587301587298*G0_1_0 - 0.33862433862434*G2_0_0 - 0.101587301587305*G2_0_1 - 0.101587301587298*G2_1_0;
    A[364] = 0.761904761904765*G0_0_0 + 0.296296296296305*G0_0_1 + 0.296296296296298*G0_1_0 - 0.0677248677248641*G0_1_1 + 0.761904761904765*G2_0_0 + 0.296296296296305*G2_0_1 + 0.296296296296298*G2_1_0 - 0.0677248677248641*G2_1_1;
    A[365] = -2.09947089947091*G0_0_0 - 1.04973544973546*G0_0_1 - 1.04973544973545*G0_1_0 - 0.135449735449735*G0_1_1 - 2.09947089947091*G2_0_0 - 1.04973544973546*G2_0_1 - 1.04973544973545*G2_1_0 - 0.135449735449735*G2_1_1;
    A[366] = 0.338624338624341*G0_0_0 + 0.237037037037037*G0_0_1 + 0.778835978835976*G0_1_0 + 1.01587301587301*G0_1_1 + 0.338624338624341*G2_0_0 + 0.237037037037037*G2_0_1 + 0.778835978835976*G2_1_0 + 1.01587301587301*G2_1_1;
    A[367] = -0.761904761904769*G0_0_0 - 0.465608465608467*G0_0_1 - 1.58306878306878*G0_1_0 - 1.94708994708994*G0_1_1 - 0.761904761904769*G2_0_0 - 0.465608465608467*G2_0_1 - 1.58306878306878*G2_1_0 - 1.94708994708994*G2_1_1;
    A[368] = 2.09947089947091*G0_0_0 + 1.04973544973545*G0_0_1 + 1.04973544973545*G0_1_0 + 1.82857142857142*G0_1_1 + 2.09947089947091*G2_0_0 + 1.04973544973545*G2_0_1 + 1.04973544973545*G2_1_0 + 1.82857142857142*G2_1_1;
    A[369] = 0.101587301587305*G0_0_1 + 0.101587301587301*G0_1_0 - 0.135449735449737*G0_1_1 + 0.101587301587305*G2_0_1 + 0.101587301587301*G2_1_0 - 0.135449735449737*G2_1_1;
    A[370] = 0.0423280423280411*G0_0_1 + 0.042328042328043*G0_1_0 - 0.0677248677248685*G0_1_1 + 0.0423280423280411*G2_0_1 + 0.042328042328043*G2_1_0 - 0.0677248677248685*G2_1_1;
    A[371] = 0.101587301587298*G0_0_1 + 0.1015873015873*G0_1_0 + 0.101587301587298*G2_0_1 + 0.1015873015873*G2_1_0;
    A[372] = -0.338624338624346*G0_0_1 - 0.338624338624339*G0_1_0 + 0.135449735449733*G0_1_1 - 0.338624338624346*G2_0_1 - 0.338624338624339*G2_1_0 + 0.135449735449733*G2_1_1;
    A[373] = -0.338624338624336*G0_0_1 - 0.338624338624339*G0_1_0 + 0.135449735449735*G0_1_1 - 0.338624338624336*G2_0_1 - 0.338624338624339*G2_1_0 + 0.135449735449735*G2_1_1;
    A[374] = 1.2867724867725*G0_0_1 + 1.28677248677249*G0_1_0 + 0.135449735449737*G0_1_1 + 1.2867724867725*G2_0_1 + 1.28677248677249*G2_1_0 + 0.135449735449737*G2_1_1;
    A[375] = 0.0;
    A[376] = 0.0;
    A[377] = 0.0;
    A[378] = 0.0;
    A[379] = 0.0;
    A[380] = 0.0;
    A[381] = 0.0;
    A[382] = 0.0;
    A[383] = 0.0;
    A[384] = 0.0;
    A[385] = 0.0;
    A[386] = 0.0;
    A[387] = 0.0;
    A[388] = 0.0;
    A[389] = 0.0;
    A[390] = 0.00776014109347445*G4_0 + 0.0176366843033509*G4_1;
    A[391] = 0.00776014109347447*G4_0;
    A[392] = -0.0522045855379189*G4_0 - 0.0458553791887125*G4_1;
    A[393] = -0.0451499118165785*G4_0 - 0.0112874779541441*G4_1;
    A[394] = 0.090299823633157*G4_0 + 0.0310405643738975*G4_1;
    A[395] = -0.158024691358025*G4_0 - 0.0790123456790117*G4_1;
    A[396] = -0.0451499118165785*G4_0 - 0.0451499118165782*G4_1;
    A[397] = 0.090299823633157*G4_0 + 0.0733686067019398*G4_1;
    A[398] = -0.158024691358025*G4_0;
    A[399] = -0.0112874779541446*G4_0 + 0.033862433862434*G4_1;
    A[400] = -0.00282186948853618*G4_0 + 0.0141093474426807*G4_1;
    A[401] = -0.0112874779541446*G4_0 + 0.0112874779541451*G4_1;
    A[402] = 0.0225749559082894*G4_0 - 0.0451499118165781*G4_1;
    A[403] = 0.0225749559082894*G4_0 - 0.0451499118165775*G4_1;
    A[404] = -0.112874779541446*G4_0 + 0.0902998236331581*G4_1;
    A[405] = -0.651851851851855*G0_0_0 - 0.651851851851855*G0_0_1 + 0.126984126984129*G0_1_0 + 0.126984126984128*G0_1_1 - 0.651851851851855*G2_0_0 - 0.651851851851855*G2_0_1 + 0.126984126984129*G2_1_0 + 0.126984126984128*G2_1_1;
    A[406] = -0.245502645502644*G0_0_0 - 0.203174603174603*G0_1_0 - 0.245502645502644*G2_0_0 - 0.203174603174603*G2_1_0;
    A[407] = 0.0423280423280409*G0_1_1 + 0.0423280423280409*G2_1_1;
    A[408] = -0.135449735449728*G0_0_0 - 0.237037037037028*G0_0_1 - 0.237037037037036*G0_1_0 - 0.338624338624343*G0_1_1 - 0.135449735449728*G2_0_0 - 0.237037037037028*G2_0_1 - 0.237037037037036*G2_1_0 - 0.338624338624343*G2_1_1;
    A[409] = -0.067724867724864*G0_0_0 - 0.110052910052908*G0_0_1 - 0.110052910052907*G0_1_0 - 0.152380952380943*G0_1_1 - 0.067724867724864*G2_0_0 - 0.110052910052908*G2_0_1 - 0.110052910052907*G2_1_0 - 0.152380952380943*G2_1_1;
    A[410] = -0.1015873015873*G0_0_1 - 0.101587301587305*G0_1_0 - 0.203174603174607*G0_1_1 - 0.1015873015873*G2_0_1 - 0.101587301587305*G2_1_0 - 0.203174603174607*G2_1_1;
    A[411] = -0.135449735449741*G0_0_0 + 0.914285714285717*G0_0_1 + 0.914285714285713*G0_1_0 - 0.135449735449735*G0_1_1 - 0.135449735449741*G2_0_0 + 0.914285714285717*G2_0_1 + 0.914285714285713*G2_1_0 - 0.135449735449735*G2_1_1;
    A[412] = -0.0677248677248647*G0_0_0 - 0.364021164021163*G0_0_1 - 0.36402116402116*G0_1_0 + 0.101587301587297*G0_1_1 - 0.0677248677248647*G2_0_0 - 0.364021164021163*G2_0_1 - 0.36402116402116*G2_1_0 + 0.101587301587297*G2_1_1;
    A[413] = 0.101587301587301*G0_0_1 + 0.101587301587305*G0_1_0 - 0.135449735449737*G0_1_1 + 0.101587301587301*G2_0_1 + 0.101587301587305*G2_1_0 - 0.135449735449737*G2_1_1;
    A[414] = 1.82857142857143*G0_0_0 + 0.778835978835974*G0_0_1 + 0.778835978835974*G0_1_0 + 1.82857142857143*G0_1_1 + 1.82857142857143*G2_0_0 + 0.778835978835974*G2_0_1 + 0.778835978835974*G2_1_0 + 1.82857142857143*G2_1_1;
    A[415] = -1.94708994708995*G0_0_0 - 0.364021164021159*G0_0_1 - 1.48148148148147*G0_1_0 - 0.660317460317453*G0_1_1 - 1.94708994708995*G2_0_0 - 0.364021164021159*G2_0_1 - 1.48148148148147*G2_1_0 - 0.660317460317453*G2_1_1;
    A[416] = 1.01587301587301*G0_0_0 + 0.23703703703703*G0_0_1 + 0.778835978835975*G0_1_0 + 0.338624338624337*G0_1_1 + 1.01587301587301*G2_0_0 + 0.23703703703703*G2_0_1 + 0.778835978835975*G2_1_0 + 0.338624338624337*G2_1_1;
    A[417] = 0.135449735449746*G0_0_0 - 1.15132275132274*G0_0_1 - 1.15132275132275*G0_1_0 - 2.43809523809524*G0_1_1 + 0.135449735449746*G2_0_0 - 1.15132275132274*G2_0_1 - 1.15132275132275*G2_1_0 - 2.43809523809524*G2_1_1;
    A[418] = 0.135449735449723*G0_0_0 + 0.474074074074063*G0_0_1 + 0.474074074074072*G0_1_0 + 0.8126984126984*G0_1_1 + 0.135449735449723*G2_0_0 + 0.474074074074063*G2_0_1 + 0.474074074074072*G2_1_0 + 0.8126984126984*G2_1_1;
    A[419] = 0.135449735449729*G0_0_0 + 0.474074074074072*G0_0_1 + 0.474074074074067*G0_1_0 + 0.812698412698421*G0_1_1 + 0.135449735449729*G2_0_0 + 0.474074074074072*G2_0_1 + 0.474074074074067*G2_1_0 + 0.812698412698421*G2_1_1;
    A[420] = 0.0;
    A[421] = 0.0;
    A[422] = 0.0;
    A[423] = 0.0;
    A[424] = 0.0;
    A[425] = 0.0;
    A[426] = 0.0;
    A[427] = 0.0;
    A[428] = 0.0;
    A[429] = 0.0;
    A[430] = 0.0;
    A[431] = 0.0;
    A[432] = 0.0;
    A[433] = 0.0;
    A[434] = 0.0;
    A[435] = 0.0458553791887127*G4_0 - 0.0063492063492062*G4_1;
    A[436] = -0.0176366843033509*G4_0 - 0.00987654320987649*G4_1;
    A[437] = 0.00776014109347438*G4_1;
    A[438] = -0.033862433862433*G4_0 - 0.0451499118165783*G4_1;
    A[439] = -0.0141093474426805*G4_0 - 0.0169312169312166*G4_1;
    A[440] = -0.0112874779541445*G4_0 - 0.0225749559082895*G4_1;
    A[441] = 0.079012345679013*G4_0 - 0.0790123456790122*G4_1;
    A[442] = -0.0310405643738982*G4_0 + 0.059259259259259*G4_1;
    A[443] = 0.0112874779541447*G4_0 - 0.0338624338624342*G4_1;
    A[444] = -0.158024691358025*G4_1;
    A[445] = -0.0733686067019408*G4_0 + 0.0169312169312163*G4_1;
    A[446] = 0.045149911816579*G4_0;
    A[447] = -0.0902998236331568*G4_0 - 0.203174603174604*G4_1;
    A[448] = 0.0451499118165794*G4_0 + 0.0677248677248674*G4_1;
    A[449] = 0.0451499118165784*G4_0 + 0.0677248677248674*G4_1;
    A[450] = 0.467724867724869*G0_0_0 + 0.467724867724869*G0_0_1 + 0.0423280423280412*G0_1_0 + 0.0423280423280403*G0_1_1 + 0.467724867724869*G2_0_0 + 0.467724867724869*G2_0_1 + 0.0423280423280412*G2_1_0 + 0.0423280423280403*G2_1_1;
    A[451] = 0.467724867724863*G0_0_0 + 0.425396825396823*G0_1_0 + 0.467724867724863*G2_0_0 + 0.425396825396823*G2_1_0;
    A[452] = 0.042328042328042*G0_1_1 + 0.042328042328042*G2_1_1;
    A[453] = 0.101587301587291*G0_0_0 + 0.46560846560845*G0_0_1 + 0.465608465608462*G0_1_0 + 0.761904761904757*G0_1_1 + 0.101587301587291*G2_0_0 + 0.46560846560845*G2_0_1 + 0.465608465608462*G2_1_0 + 0.761904761904757*G2_1_1;
    A[454] = 0.0507936507936503*G0_0_0 + 0.196825396825396*G0_0_1 + 0.196825396825396*G0_1_0 + 0.393650793650791*G0_1_1 + 0.0507936507936503*G2_0_0 + 0.196825396825396*G2_0_1 + 0.196825396825396*G2_1_0 + 0.393650793650791*G2_1_1;
    A[455] = -0.0423280423280442*G0_0_1 - 0.0423280423280413*G0_1_0 - 0.152380952380951*G0_1_1 - 0.0423280423280442*G2_0_1 - 0.0423280423280413*G2_1_0 - 0.152380952380951*G2_1_1;
    A[456] = 0.101587301587306*G0_0_0 - 0.364021164021165*G0_0_1 - 0.364021164021163*G0_1_0 - 0.0677248677248648*G0_1_1 + 0.101587301587306*G2_0_0 - 0.364021164021165*G2_0_1 - 0.364021164021163*G2_1_0 - 0.0677248677248648*G2_1_1;
    A[457] = 0.0507936507936486*G0_0_0 - 0.146031746031746*G0_0_1 - 0.146031746031748*G0_1_0 + 0.0507936507936495*G0_1_1 + 0.0507936507936486*G2_0_0 - 0.146031746031746*G2_0_1 - 0.146031746031748*G2_1_0 + 0.0507936507936495*G2_1_1;
    A[458] = 0.042328042328043*G0_0_1 + 0.0423280423280411*G0_1_0 - 0.0677248677248686*G0_1_1 + 0.042328042328043*G2_0_1 + 0.0423280423280411*G2_1_0 - 0.0677248677248686*G2_1_1;
    A[459] = -1.94708994708995*G0_0_0 - 1.48148148148147*G0_0_1 - 0.364021164021159*G0_1_0 - 0.660317460317453*G0_1_1 - 1.94708994708995*G2_0_0 - 1.48148148148147*G2_0_1 - 0.364021164021159*G2_1_0 - 0.660317460317453*G2_1_1;
    A[460] = 2.95873015873015*G0_0_0 + 1.47936507936507*G0_0_1 + 1.47936507936507*G0_1_0 + 2.45079365079365*G0_1_1 + 2.95873015873015*G2_0_0 + 1.47936507936507*G2_0_1 + 1.47936507936507*G2_1_0 + 2.45079365079365*G2_1_1;
    A[461] = -1.94708994708994*G0_0_0 - 0.465608465608452*G0_0_1 - 1.58306878306878*G0_1_0 - 0.761904761904758*G0_1_1 - 1.94708994708994*G2_0_0 - 0.465608465608452*G2_0_1 - 1.58306878306878*G2_1_0 - 0.761904761904758*G2_1_1;
    A[462] = -0.101587301587311*G0_0_0 + 1.57460317460317*G0_0_1 + 1.57460317460317*G0_1_0 + 0.406349206349191*G0_1_1 - 0.101587301587311*G2_0_0 + 1.57460317460317*G2_0_1 + 1.57460317460317*G2_1_0 + 0.406349206349191*G2_1_1;
    A[463] = -0.101587301587286*G0_0_0 - 1.67619047619046*G0_0_1 - 1.67619047619047*G0_1_0 - 2.84444444444444*G0_1_1 - 0.101587301587286*G2_0_0 - 1.67619047619046*G2_0_1 - 1.67619047619047*G2_1_0 - 2.84444444444444*G2_1_1;
    A[464] = -0.101587301587299*G0_0_0 - 0.0507936507936499*G0_0_1 - 0.0507936507936479*G0_1_0 + 0.406349206349213*G0_1_1 - 0.101587301587299*G2_0_0 - 0.0507936507936499*G2_0_1 - 0.0507936507936479*G2_1_0 + 0.406349206349213*G2_1_1;
    A[465] = 0.0;
    A[466] = 0.0;
    A[467] = 0.0;
    A[468] = 0.0;
    A[469] = 0.0;
    A[470] = 0.0;
    A[471] = 0.0;
    A[472] = 0.0;
    A[473] = 0.0;
    A[474] = 0.0;
    A[475] = 0.0;
    A[476] = 0.0;
    A[477] = 0.0;
    A[478] = 0.0;
    A[479] = 0.0;
    A[480] = -0.0326278659611994*G4_0 - 0.00194003527336865*G4_1;
    A[481] = 0.032627865961199*G4_0 + 0.0306878306878307*G4_1;
    A[482] = 0.00511463844797181*G4_1;
    A[483] = 0.0592592592592578*G4_0 + 0.0902998236331564*G4_1;
    A[484] = 0.0105820105820109*G4_0 + 0.0211640211640212*G4_1;
    A[485] = -0.00282186948853648*G4_0 - 0.0169312169312169*G4_1;
    A[486] = -0.0592592592592599*G4_0 + 0.0310405643738976*G4_1;
    A[487] = -0.0105820105820103*G4_0 + 0.0105820105820107*G4_1;
    A[488] = 0.00282186948853594*G4_0 - 0.0141093474426807*G4_1;
    A[489] = 0.0733686067019392*G4_0 + 0.0507936507936506*G4_1;
    A[490] = -0.165079365079365*G4_1;
    A[491] = -0.0733686067019411*G4_0 - 0.0225749559082896*G4_1;
    A[492] = 0.135449735449736*G4_0 - 0.0507936507936507*G4_1;
    A[493] = -0.135449735449736*G4_0 - 0.186243386243387*G4_1;
    A[494] = 0.0846560846560849*G4_1;
    A[495] = -0.245502645502646*G0_0_0 - 0.245502645502644*G0_0_1 - 0.042328042328042*G0_1_0 - 0.0423280423280388*G0_1_1 - 0.245502645502646*G2_0_0 - 0.245502645502644*G2_0_1 - 0.042328042328042*G2_1_0 - 0.0423280423280388*G2_1_1;
    A[496] = -0.651851851851847*G0_0_0 - 0.778835978835975*G0_1_0 - 0.651851851851847*G2_0_0 - 0.778835978835975*G2_1_0;
    A[497] = 0.0423280423280423*G0_1_1 + 0.0423280423280423*G2_1_1;
    A[498] = -0.135449735449728*G0_0_0 - 1.04973544973544*G0_0_1 - 1.04973544973544*G0_1_0 - 2.09947089947089*G0_1_1 - 0.135449735449728*G2_0_0 - 1.04973544973544*G2_0_1 - 1.04973544973544*G2_1_0 - 2.09947089947089*G2_1_1;
    A[499] = -0.0677248677248689*G0_0_0 + 0.296296296296294*G0_0_1 + 0.296296296296295*G0_1_0 + 0.761904761904762*G0_1_1 - 0.0677248677248689*G2_0_0 + 0.296296296296294*G2_0_1 + 0.296296296296295*G2_1_0 + 0.761904761904762*G2_1_1;
    A[500] = -0.1015873015873*G0_0_1 - 0.101587301587298*G0_1_0 - 0.338624338624333*G0_1_1 - 0.1015873015873*G2_0_1 - 0.101587301587298*G2_1_0 - 0.338624338624333*G2_1_1;
    A[501] = -0.135449735449736*G0_0_0 + 0.101587301587299*G0_0_1 + 0.1015873015873*G0_1_0 - 0.135449735449736*G2_0_0 + 0.101587301587299*G2_0_1 + 0.1015873015873*G2_1_0;
    A[502] = -0.067724867724867*G0_0_0 + 0.0423280423280429*G0_0_1 + 0.0423280423280398*G0_1_0 - 0.067724867724867*G2_0_0 + 0.0423280423280429*G2_0_1 + 0.0423280423280398*G2_1_0;
    A[503] = 0.1015873015873*G0_0_1 + 0.101587301587298*G0_1_0 + 0.1015873015873*G2_0_1 + 0.101587301587298*G2_1_0;
    A[504] = 1.01587301587301*G0_0_0 + 0.778835978835975*G0_0_1 + 0.23703703703703*G0_1_0 + 0.338624338624337*G0_1_1 + 1.01587301587301*G2_0_0 + 0.778835978835975*G2_0_1 + 0.23703703703703*G2_1_0 + 0.338624338624337*G2_1_1;
    A[505] = -1.94708994708994*G0_0_0 - 1.58306878306878*G0_0_1 - 0.465608465608452*G0_1_0 - 0.761904761904758*G0_1_1 - 1.94708994708994*G2_0_0 - 1.58306878306878*G2_0_1 - 0.465608465608452*G2_1_0 - 0.761904761904758*G2_1_1;
    A[506] = 1.82857142857142*G0_0_0 + 1.04973544973544*G0_0_1 + 1.04973544973544*G0_1_0 + 2.09947089947088*G0_1_1 + 1.82857142857142*G2_0_0 + 1.04973544973544*G2_0_1 + 1.04973544973544*G2_1_0 + 2.09947089947088*G2_1_1;
    A[507] = 0.135449735449739*G0_0_0 - 0.338624338624332*G0_0_1 - 0.338624338624343*G0_1_0 + 0.135449735449739*G2_0_0 - 0.338624338624332*G2_0_1 - 0.338624338624343*G2_1_0;
    A[508] = 0.135449735449726*G0_0_0 + 1.28677248677248*G0_0_1 + 1.28677248677249*G0_1_0 + 0.135449735449726*G2_0_0 + 1.28677248677248*G2_0_1 + 1.28677248677249*G2_1_0;
    A[509] = 0.135449735449736*G0_0_0 - 0.338624338624339*G0_0_1 - 0.338624338624335*G0_1_0 + 1.03007880003503e-14*G0_1_1 + 0.135449735449736*G2_0_0 - 0.338624338624339*G2_0_1 - 0.338624338624335*G2_1_0 + 1.03007880003503e-14*G2_1_1;
    A[510] = 0.0;
    A[511] = 0.0;
    A[512] = 0.0;
    A[513] = 0.0;
    A[514] = 0.0;
    A[515] = 0.0;
    A[516] = 0.0;
    A[517] = 0.0;
    A[518] = 0.0;
    A[519] = 0.0;
    A[520] = 0.0;
    A[521] = 0.0;
    A[522] = 0.0;
    A[523] = 0.0;
    A[524] = 0.0;
    A[525] = 0.017636684303351*G4_0 + 0.00776014109347439*G4_1;
    A[526] = -0.0458553791887123*G4_0 - 0.0522045855379187*G4_1;
    A[527] = 0.00776014109347442*G4_1;
    A[528] = -0.0790123456790113*G4_0 - 0.158024691358024*G4_1;
    A[529] = 0.0310405643738973*G4_0 + 0.0902998236331565*G4_1;
    A[530] = -0.0112874779541444*G4_0 - 0.045149911816578*G4_1;
    A[531] = 0.0338624338624341*G4_0 - 0.0112874779541443*G4_1;
    A[532] = 0.0141093474426807*G4_0 - 0.00282186948853616*G4_1;
    A[533] = 0.0112874779541447*G4_0 - 0.0112874779541442*G4_1;
    A[534] = -0.0451499118165782*G4_0 - 0.0451499118165782*G4_1;
    A[535] = 0.0733686067019394*G4_0 + 0.0902998236331566*G4_1;
    A[536] = -0.158024691358024*G4_1;
    A[537] = -0.0451499118165789*G4_0 + 0.0225749559082898*G4_1;
    A[538] = 0.0902998236331575*G4_0 - 0.112874779541445*G4_1;
    A[539] = -0.0451499118165785*G4_0 + 0.0225749559082902*G4_1;
    A[540] = -0.0846560846560898*G0_0_0 - 0.0846560846560897*G0_0_1 - 0.0846560846560887*G0_1_0 - 0.0846560846560862*G0_1_1 - 0.0846560846560898*G2_0_0 - 0.0846560846560897*G2_0_1 - 0.0846560846560887*G2_1_0 - 0.0846560846560862*G2_1_1;
    A[541] = -0.0846560846560837*G0_0_0 - 0.0846560846560837*G2_0_0;
    A[542] = -0.0846560846560822*G0_1_1 - 0.0846560846560822*G2_1_1;
    A[543] = 0.812698412698406*G0_0_0 + 0.338624338624346*G0_0_1 + 0.338624338624332*G0_1_0 + 0.812698412698406*G2_0_0 + 0.338624338624346*G2_0_1 + 0.338624338624332*G2_1_0;
    A[544] = 0.406349206349193*G0_0_0 + 0.457142857142832*G0_0_1 + 0.457142857142842*G0_1_0 + 0.406349206349181*G0_1_1 + 0.406349206349193*G2_0_0 + 0.457142857142832*G2_0_1 + 0.457142857142842*G2_1_0 + 0.406349206349181*G2_1_1;
    A[545] = 0.338624338624343*G0_0_1 + 0.338624338624346*G0_1_0 + 0.812698412698421*G0_1_1 + 0.338624338624343*G2_0_1 + 0.338624338624346*G2_1_0 + 0.812698412698421*G2_1_1;
    A[546] = -2.43809523809524*G0_0_0 - 1.15132275132275*G0_0_1 - 1.15132275132275*G0_1_0 + 0.135449735449735*G0_1_1 - 2.43809523809524*G2_0_0 - 1.15132275132275*G2_0_1 - 1.15132275132275*G2_1_0 + 0.135449735449735*G2_1_1;
    A[547] = 0.406349206349198*G0_0_0 + 1.57460317460318*G0_0_1 + 1.57460317460317*G0_1_0 - 0.101587301587297*G0_1_1 + 0.406349206349198*G2_0_0 + 1.57460317460318*G2_0_1 + 1.57460317460317*G2_1_0 - 0.101587301587297*G2_1_1;
    A[548] = -0.338624338624339*G0_0_1 - 0.338624338624346*G0_1_0 + 0.135449735449733*G0_1_1 - 0.338624338624339*G2_0_1 - 0.338624338624346*G2_1_0 + 0.135449735449733*G2_1_1;
    A[549] = 0.135449735449746*G0_0_0 - 1.15132275132275*G0_0_1 - 1.15132275132274*G0_1_0 - 2.43809523809523*G0_1_1 + 0.135449735449746*G2_0_0 - 1.15132275132275*G2_0_1 - 1.15132275132274*G2_1_0 - 2.43809523809523*G2_1_1;
    A[550] = -0.101587301587311*G0_0_0 + 1.57460317460317*G0_0_1 + 1.57460317460317*G0_1_0 + 0.406349206349191*G0_1_1 - 0.101587301587311*G2_0_0 + 1.57460317460317*G2_0_1 + 1.57460317460317*G2_1_0 + 0.406349206349191*G2_1_1;
    A[551] = 0.135449735449739*G0_0_0 - 0.338624338624343*G0_0_1 - 0.338624338624332*G0_1_0 + 0.135449735449739*G2_0_0 - 0.338624338624343*G2_0_1 - 0.338624338624332*G2_1_0;
    A[552] = 5.6888888888889*G0_0_0 + 2.84444444444443*G0_0_1 + 2.84444444444443*G0_1_0 + 5.68888888888888*G0_1_1 + 5.6888888888889*G2_0_0 + 2.84444444444443*G2_0_1 + 2.84444444444443*G2_1_0 + 5.68888888888888*G2_1_1;
    A[553] = -4.06349206349206*G0_0_0 - 2.03174603174601*G0_0_1 - 2.03174603174601*G0_1_0 - 0.812698412698374*G0_1_1 - 4.06349206349206*G2_0_0 - 2.03174603174601*G2_0_1 - 2.03174603174601*G2_1_0 - 0.812698412698374*G2_1_1;
    A[554] = -0.81269841269839*G0_0_0 - 2.03174603174602*G0_0_1 - 2.03174603174601*G0_1_0 - 4.06349206349207*G0_1_1 - 0.81269841269839*G2_0_0 - 2.03174603174602*G2_0_1 - 2.03174603174601*G2_1_0 - 4.06349206349207*G2_1_1;
    A[555] = 0.0;
    A[556] = 0.0;
    A[557] = 0.0;
    A[558] = 0.0;
    A[559] = 0.0;
    A[560] = 0.0;
    A[561] = 0.0;
    A[562] = 0.0;
    A[563] = 0.0;
    A[564] = 0.0;
    A[565] = 0.0;
    A[566] = 0.0;
    A[567] = 0.0;
    A[568] = 0.0;
    A[569] = 0.0;
    A[570] = 0.00705467372134048*G4_0 + 0.00705467372134031*G4_1;
    A[571] = -0.00705467372134023*G4_0;
    A[572] = -0.00705467372134029*G4_1;
    A[573] = 0.0677248677248674*G4_0 + 0.0225749559082885*G4_1;
    A[574] = 0.0846560846560831*G4_0 + 0.0846560846560833*G4_1;
    A[575] = 0.0225749559082894*G4_0 + 0.0677248677248681*G4_1;
    A[576] = 0.203174603174604*G4_0 + 0.0902998236331568*G4_1;
    A[577] = 0.0507936507936513*G4_0 - 0.135449735449735*G4_1;
    A[578] = -0.0225749559082885*G4_0 + 0.0451499118165791*G4_1;
    A[579] = 0.0902998236331573*G4_0 + 0.203174603174603*G4_1;
    A[580] = -0.135449735449736*G4_0 + 0.0507936507936519*G4_1;
    A[581] = 0.0451499118165791*G4_0 - 0.022574955908289*G4_1;
    A[582] = 0.0;
    A[583] = -0.270899470899473*G4_0 - 0.135449735449737*G4_1;
    A[584] = -0.135449735449736*G4_0 - 0.270899470899471*G4_1;
    A[585] = -0.0846560846560792*G0_0_0 - 0.0846560846560777*G0_0_1 - 0.0846560846560804*G0_1_0 - 0.0846560846560814*G0_1_1 - 0.0846560846560792*G2_0_0 - 0.0846560846560777*G2_0_1 - 0.0846560846560804*G2_1_0 - 0.0846560846560814*G2_1_1;
    A[586] = -0.0846560846560839*G0_0_0 - 0.0846560846560839*G2_0_0;
    A[587] = -0.0846560846560844*G0_1_1 - 0.0846560846560844*G2_1_1;
    A[588] = -2.43809523809523*G0_0_0 - 1.28677248677249*G0_0_1 - 1.28677248677248*G0_1_0 - 2.43809523809523*G2_0_0 - 1.28677248677249*G2_0_1 - 1.28677248677248*G2_1_0;
    A[589] = 0.406349206349211*G0_0_0 - 1.16825396825395*G0_0_1 - 1.16825396825397*G0_1_0 - 2.84444444444444*G0_1_1 + 0.406349206349211*G2_0_0 - 1.16825396825395*G2_0_1 - 1.16825396825397*G2_1_0 - 2.84444444444444*G2_1_1;
    A[590] = 0.338624338624337*G0_0_1 + 0.338624338624336*G0_1_0 + 0.812698412698409*G0_1_1 + 0.338624338624337*G2_0_1 + 0.338624338624336*G2_1_0 + 0.812698412698409*G2_1_1;
    A[591] = 0.812698412698416*G0_0_0 + 0.474074074074065*G0_0_1 + 0.474074074074066*G0_1_0 + 0.135449735449731*G0_1_1 + 0.812698412698416*G2_0_0 + 0.474074074074065*G2_0_1 + 0.474074074074066*G2_1_0 + 0.135449735449731*G2_1_1;
    A[592] = 0.40634920634921*G0_0_0 - 0.0507936507936509*G0_0_1 - 0.0507936507936399*G0_1_0 - 0.1015873015873*G0_1_1 + 0.40634920634921*G2_0_0 - 0.0507936507936509*G2_0_1 - 0.0507936507936399*G2_1_0 - 0.1015873015873*G2_1_1;
    A[593] = -0.338624338624339*G0_0_1 - 0.338624338624335*G0_1_0 + 0.135449735449735*G0_1_1 - 0.338624338624339*G2_0_1 - 0.338624338624335*G2_1_0 + 0.135449735449735*G2_1_1;
    A[594] = 0.135449735449723*G0_0_0 + 0.474074074074072*G0_0_1 + 0.474074074074063*G0_1_0 + 0.8126984126984*G0_1_1 + 0.135449735449723*G2_0_0 + 0.474074074074072*G2_0_1 + 0.474074074074063*G2_1_0 + 0.8126984126984*G2_1_1;
    A[595] = -0.101587301587286*G0_0_0 - 1.67619047619047*G0_0_1 - 1.67619047619046*G0_1_0 - 2.84444444444444*G0_1_1 - 0.101587301587286*G2_0_0 - 1.67619047619047*G2_0_1 - 1.67619047619046*G2_1_0 - 2.84444444444444*G2_1_1;
    A[596] = 0.135449735449726*G0_0_0 + 1.28677248677249*G0_0_1 + 1.28677248677248*G0_1_0 + 0.135449735449726*G2_0_0 + 1.28677248677249*G2_0_1 + 1.28677248677248*G2_1_0;
    A[597] = -4.06349206349206*G0_0_0 - 2.03174603174601*G0_0_1 - 2.03174603174601*G0_1_0 - 0.812698412698374*G0_1_1 - 4.06349206349206*G2_0_0 - 2.03174603174601*G2_0_1 - 2.03174603174601*G2_1_0 - 0.812698412698374*G2_1_1;
    A[598] = 5.68888888888887*G0_0_0 + 2.84444444444442*G0_0_1 + 2.84444444444442*G0_1_0 + 5.68888888888887*G0_1_1 + 5.68888888888887*G2_0_0 + 2.84444444444442*G2_0_1 + 2.84444444444442*G2_1_0 + 5.68888888888887*G2_1_1;
    A[599] = -0.812698412698421*G0_0_0 + 1.21904761904761*G0_0_1 + 1.2190476190476*G0_1_0 - 0.812698412698432*G0_1_1 - 0.812698412698421*G2_0_0 + 1.21904761904761*G2_0_1 + 1.2190476190476*G2_1_0 - 0.812698412698432*G2_1_1;
    A[600] = 0.0;
    A[601] = 0.0;
    A[602] = 0.0;
    A[603] = 0.0;
    A[604] = 0.0;
    A[605] = 0.0;
    A[606] = 0.0;
    A[607] = 0.0;
    A[608] = 0.0;
    A[609] = 0.0;
    A[610] = 0.0;
    A[611] = 0.0;
    A[612] = 0.0;
    A[613] = 0.0;
    A[614] = 0.0;
    A[615] = 0.00705467372134022*G4_0 + 0.00705467372134047*G4_1;
    A[616] = -0.00705467372134051*G4_0;
    A[617] = -0.00705467372134041*G4_1;
    A[618] = -0.203174603174603*G4_0 - 0.112874779541446*G4_1;
    A[619] = -0.05079365079365*G4_0 - 0.186243386243386*G4_1;
    A[620] = 0.0225749559082889*G4_0 + 0.0677248677248674*G4_1;
    A[621] = -0.0677248677248684*G4_0 - 0.0451499118165785*G4_1;
    A[622] = -0.0846560846560846*G4_0;
    A[623] = -0.0225749559082897*G4_0 + 0.045149911816578*G4_1;
    A[624] = -0.0451499118165791*G4_0 - 0.0677248677248674*G4_1;
    A[625] = 0.135449735449736*G4_0 + 0.186243386243386*G4_1;
    A[626] = -0.0902998236331573*G4_0 + 0.112874779541446*G4_1;
    A[627] = 0.270899470899469*G4_0 + 0.135449735449734*G4_1;
    A[628] = 0.0;
    A[629] = 0.135449735449735*G4_0 - 0.135449735449737*G4_1;
    A[630] = -0.0846560846560814*G0_0_0 - 0.0846560846560843*G0_0_1 - 0.084656084656081*G0_1_0 - 0.0846560846560819*G0_1_1 - 0.0846560846560814*G2_0_0 - 0.0846560846560843*G2_0_1 - 0.084656084656081*G2_1_0 - 0.0846560846560819*G2_1_1;
    A[631] = -0.0846560846560846*G0_0_0 - 0.0846560846560846*G2_0_0;
    A[632] = -0.0846560846560861*G0_1_1 - 0.0846560846560861*G2_1_1;
    A[633] = 0.812698412698411*G0_0_0 + 0.338624338624331*G0_0_1 + 0.338624338624333*G0_1_0 - 1.52881179937836e-14*G0_1_1 + 0.812698412698411*G2_0_0 + 0.338624338624331*G2_0_1 + 0.338624338624333*G2_1_0 - 1.52881179937836e-14*G2_1_1;
    A[634] = -2.84444444444443*G0_0_0 - 1.16825396825396*G0_0_1 - 1.16825396825395*G0_1_0 + 0.406349206349225*G0_1_1 - 2.84444444444443*G2_0_0 - 1.16825396825396*G2_0_1 - 1.16825396825395*G2_1_0 + 0.406349206349225*G2_1_1;
    A[635] = -1.28677248677249*G0_0_1 - 1.2867724867725*G0_1_0 - 2.43809523809525*G0_1_1 - 1.28677248677249*G2_0_1 - 1.2867724867725*G2_1_0 - 2.43809523809525*G2_1_1;
    A[636] = 0.8126984126984*G0_0_0 + 0.474074074074071*G0_0_1 + 0.474074074074077*G0_1_0 + 0.135449735449732*G0_1_1 + 0.8126984126984*G2_0_0 + 0.474074074074071*G2_0_1 + 0.474074074074077*G2_1_0 + 0.135449735449732*G2_1_1;
    A[637] = -2.84444444444443*G0_0_0 - 1.67619047619047*G0_0_1 - 1.67619047619048*G0_1_0 - 0.101587301587302*G0_1_1 - 2.84444444444443*G2_0_0 - 1.67619047619047*G2_0_1 - 1.67619047619048*G2_1_0 - 0.101587301587302*G2_1_1;
    A[638] = 1.28677248677249*G0_0_1 + 1.2867724867725*G0_1_0 + 0.135449735449737*G0_1_1 + 1.28677248677249*G2_0_1 + 1.2867724867725*G2_1_0 + 0.135449735449737*G2_1_1;
    A[639] = 0.135449735449729*G0_0_0 + 0.474074074074067*G0_0_1 + 0.474074074074072*G0_1_0 + 0.81269841269842*G0_1_1 + 0.135449735449729*G2_0_0 + 0.474074074074067*G2_0_1 + 0.474074074074072*G2_1_0 + 0.81269841269842*G2_1_1;
    A[640] = -0.101587301587299*G0_0_0 - 0.0507936507936479*G0_0_1 - 0.0507936507936499*G0_1_0 + 0.406349206349213*G0_1_1 - 0.101587301587299*G2_0_0 - 0.0507936507936479*G2_0_1 - 0.0507936507936499*G2_1_0 + 0.406349206349213*G2_1_1;
    A[641] = 0.135449735449736*G0_0_0 - 0.338624338624335*G0_0_1 - 0.338624338624339*G0_1_0 + 1.03007880003503e-14*G0_1_1 + 0.135449735449736*G2_0_0 - 0.338624338624335*G2_0_1 - 0.338624338624339*G2_1_0 + 1.03007880003503e-14*G2_1_1;
    A[642] = -0.812698412698389*G0_0_0 - 2.03174603174601*G0_0_1 - 2.03174603174602*G0_1_0 - 4.06349206349207*G0_1_1 - 0.812698412698389*G2_0_0 - 2.03174603174601*G2_0_1 - 2.03174603174602*G2_1_0 - 4.06349206349207*G2_1_1;
    A[643] = -0.812698412698421*G0_0_0 + 1.2190476190476*G0_0_1 + 1.21904761904761*G0_1_0 - 0.812698412698432*G0_1_1 - 0.812698412698421*G2_0_0 + 1.2190476190476*G2_0_1 + 1.21904761904761*G2_1_0 - 0.812698412698432*G2_1_1;
    A[644] = 5.68888888888887*G0_0_0 + 2.84444444444443*G0_0_1 + 2.84444444444443*G0_1_0 + 5.6888888888889*G0_1_1 + 5.68888888888887*G2_0_0 + 2.84444444444443*G2_0_1 + 2.84444444444443*G2_1_0 + 5.6888888888889*G2_1_1;
    A[645] = 0.0;
    A[646] = 0.0;
    A[647] = 0.0;
    A[648] = 0.0;
    A[649] = 0.0;
    A[650] = 0.0;
    A[651] = 0.0;
    A[652] = 0.0;
    A[653] = 0.0;
    A[654] = 0.0;
    A[655] = 0.0;
    A[656] = 0.0;
    A[657] = 0.0;
    A[658] = 0.0;
    A[659] = 0.0;
    A[660] = 0.00705467372134046*G4_0 + 0.00705467372134032*G4_1;
    A[661] = -0.00705467372134038*G4_0;
    A[662] = -0.00705467372134043*G4_1;
    A[663] = 0.0677248677248675*G4_0 + 0.0225749559082886*G4_1;
    A[664] = -0.186243386243385*G4_0 - 0.0507936507936496*G4_1;
    A[665] = -0.112874779541446*G4_0 - 0.203174603174604*G4_1;
    A[666] = -0.0677248677248676*G4_0 - 0.0451499118165791*G4_1;
    A[667] = 0.186243386243386*G4_0 + 0.135449735449736*G4_1;
    A[668] = 0.112874779541446*G4_0 - 0.0902998236331578*G4_1;
    A[669] = -0.0451499118165782*G4_0 - 0.0677248677248687*G4_1;
    A[670] = -0.0846560846560848*G4_1;
    A[671] = 0.0451499118165782*G4_0 - 0.0225749559082903*G4_1;
    A[672] = 0.135449735449735*G4_0 + 0.270899470899469*G4_1;
    A[673] = -0.135449735449735*G4_0 + 0.135449735449735*G4_1;
    A[674] = 0.0;
    A[675] = 0.0;
    A[676] = 0.0;
    A[677] = 0.0;
    A[678] = 0.0;
    A[679] = 0.0;
    A[680] = 0.0;
    A[681] = 0.0;
    A[682] = 0.0;
    A[683] = 0.0;
    A[684] = 0.0;
    A[685] = 0.0;
    A[686] = 0.0;
    A[687] = 0.0;
    A[688] = 0.0;
    A[689] = 0.0;
    A[690] = 0.373015873015875*G1_0_0 + 0.373015873015875*G1_0_1 + 0.373015873015874*G1_1_0 + 0.373015873015874*G1_1_1 + 0.373015873015875*G3_0_0 + 0.373015873015875*G3_0_1 + 0.373015873015874*G3_1_0 + 0.373015873015874*G3_1_1;
    A[691] = 0.0566137566137567*G1_0_0 + 0.0566137566137556*G1_1_0 + 0.0566137566137567*G3_0_0 + 0.0566137566137556*G3_1_0;
    A[692] = 0.0566137566137565*G1_0_1 + 0.0566137566137561*G1_1_1 + 0.0566137566137565*G3_0_1 + 0.0566137566137561*G3_1_1;
    A[693] = 0.04232804232804*G1_0_0 + 0.0423280423280395*G1_0_1 + 0.0423280423280384*G1_1_0 + 0.0423280423280363*G1_1_1 + 0.04232804232804*G3_0_0 + 0.0423280423280395*G3_0_1 + 0.0423280423280384*G3_1_0 + 0.0423280423280363*G3_1_1;
    A[694] = 0.0423280423280401*G1_0_0 + 0.0423280423280416*G1_0_1 + 0.0423280423280413*G1_1_0 + 0.0423280423280435*G1_1_1 + 0.0423280423280401*G3_0_0 + 0.0423280423280416*G3_0_1 + 0.0423280423280413*G3_1_0 + 0.0423280423280435*G3_1_1;
    A[695] = 0.0423280423280428*G1_0_0 + 0.0423280423280417*G1_0_1 + 0.0423280423280414*G1_1_0 + 0.0423280423280404*G1_1_1 + 0.0423280423280428*G3_0_0 + 0.0423280423280417*G3_0_1 + 0.0423280423280414*G3_1_0 + 0.0423280423280404*G3_1_1;
    A[696] = 0.126984126984129*G1_0_0 - 0.651851851851853*G1_0_1 + 0.126984126984129*G1_1_0 - 0.651851851851852*G1_1_1 + 0.126984126984129*G3_0_0 - 0.651851851851853*G3_0_1 + 0.126984126984129*G3_1_0 - 0.651851851851852*G3_1_1;
    A[697] = 0.0423280423280412*G1_0_0 + 0.467724867724866*G1_0_1 + 0.0423280423280428*G1_1_0 + 0.467724867724866*G1_1_1 + 0.0423280423280412*G3_0_0 + 0.467724867724866*G3_0_1 + 0.0423280423280428*G3_1_0 + 0.467724867724866*G3_1_1;
    A[698] = -0.0423280423280427*G1_0_0 - 0.245502645502645*G1_0_1 - 0.0423280423280414*G1_1_0 - 0.245502645502645*G1_1_1 - 0.0423280423280427*G3_0_0 - 0.245502645502645*G3_0_1 - 0.0423280423280414*G3_1_0 - 0.245502645502645*G3_1_1;
    A[699] = -0.651851851851855*G1_0_0 + 0.126984126984129*G1_0_1 - 0.651851851851855*G1_1_0 + 0.126984126984128*G1_1_1 - 0.651851851851855*G3_0_0 + 0.126984126984129*G3_0_1 - 0.651851851851855*G3_1_0 + 0.126984126984128*G3_1_1;
    A[700] = 0.467724867724869*G1_0_0 + 0.0423280423280412*G1_0_1 + 0.467724867724869*G1_1_0 + 0.0423280423280402*G1_1_1 + 0.467724867724869*G3_0_0 + 0.0423280423280412*G3_0_1 + 0.467724867724869*G3_1_0 + 0.0423280423280402*G3_1_1;
    A[701] = -0.245502645502646*G1_0_0 - 0.042328042328042*G1_0_1 - 0.245502645502644*G1_1_0 - 0.0423280423280388*G1_1_1 - 0.245502645502646*G3_0_0 - 0.042328042328042*G3_0_1 - 0.245502645502644*G3_1_0 - 0.0423280423280388*G3_1_1;
    A[702] = -0.0846560846560899*G1_0_0 - 0.0846560846560888*G1_0_1 - 0.0846560846560897*G1_1_0 - 0.0846560846560862*G1_1_1 - 0.0846560846560899*G3_0_0 - 0.0846560846560888*G3_0_1 - 0.0846560846560897*G3_1_0 - 0.0846560846560862*G3_1_1;
    A[703] = -0.0846560846560792*G1_0_0 - 0.0846560846560804*G1_0_1 - 0.0846560846560777*G1_1_0 - 0.0846560846560814*G1_1_1 - 0.0846560846560792*G3_0_0 - 0.0846560846560804*G3_0_1 - 0.0846560846560777*G3_1_0 - 0.0846560846560814*G3_1_1;
    A[704] = -0.0846560846560815*G1_0_0 - 0.084656084656081*G1_0_1 - 0.0846560846560843*G1_1_0 - 0.0846560846560819*G1_1_1 - 0.0846560846560815*G3_0_0 - 0.084656084656081*G3_0_1 - 0.0846560846560843*G3_1_0 - 0.0846560846560819*G3_1_1;
    A[705] = -0.0257495590828924*G5_0 - 0.0257495590828924*G5_1;
    A[706] = 0.0051146384479718*G5_0 + 0.00511463844797173*G5_1;
    A[707] = 0.0051146384479718*G5_0 + 0.00511463844797179*G5_1;
    A[708] = 0.00776014109347426*G5_0 + 0.007760141093474*G5_1;
    A[709] = 0.00511463844797154*G5_0 + 0.00511463844797178*G5_1;
    A[710] = 0.00776014109347442*G5_0 + 0.00776014109347428*G5_1;
    A[711] = -0.0458553791887127*G5_0 - 0.0458553791887127*G5_1;
    A[712] = 0.0326278659611995*G5_0 + 0.0326278659611993*G5_1;
    A[713] = -0.0176366843033509*G5_0 - 0.0176366843033511*G5_1;
    A[714] = -0.0458553791887128*G5_0 - 0.0458553791887128*G5_1;
    A[715] = 0.0326278659611995*G5_0 + 0.0326278659611996*G5_1;
    A[716] = -0.017636684303351*G5_0 - 0.0176366843033513*G5_1;
    A[717] = -0.00705467372134038*G5_0 - 0.00705467372134042*G5_1;
    A[718] = -0.00705467372134065*G5_0 - 0.00705467372134074*G5_1;
    A[719] = -0.00705467372134039*G5_0 - 0.00705467372134069*G5_1;
    A[720] = 0.0;
    A[721] = 0.0;
    A[722] = 0.0;
    A[723] = 0.0;
    A[724] = 0.0;
    A[725] = 0.0;
    A[726] = 0.0;
    A[727] = 0.0;
    A[728] = 0.0;
    A[729] = 0.0;
    A[730] = 0.0;
    A[731] = 0.0;
    A[732] = 0.0;
    A[733] = 0.0;
    A[734] = 0.0;
    A[735] = 0.0566137566137567*G1_0_0 + 0.0566137566137556*G1_0_1 + 0.0566137566137567*G3_0_0 + 0.0566137566137556*G3_0_1;
    A[736] = 0.373015873015871*G1_0_0 + 0.373015873015871*G3_0_0;
    A[737] = -0.0566137566137562*G1_0_1 - 0.0566137566137562*G3_0_1;
    A[738] = 0.126984126984126*G1_0_0 + 0.778835978835976*G1_0_1 + 0.126984126984126*G3_0_0 + 0.778835978835976*G3_0_1;
    A[739] = 0.0423280423280426*G1_0_0 - 0.425396825396824*G1_0_1 + 0.0423280423280426*G3_0_0 - 0.425396825396824*G3_0_1;
    A[740] = -0.0423280423280422*G1_0_0 + 0.203174603174602*G1_0_1 - 0.0423280423280422*G3_0_0 + 0.203174603174602*G3_0_1;
    A[741] = 0.0423280423280418*G1_0_0 + 0.0423280423280418*G3_0_0;
    A[742] = 0.042328042328042*G1_0_0 + 0.042328042328042*G3_0_0;
    A[743] = 0.0423280423280422*G1_0_0 + 0.0423280423280422*G3_0_0;
    A[744] = -0.245502645502644*G1_0_0 - 0.203174603174603*G1_0_1 - 0.245502645502644*G3_0_0 - 0.203174603174603*G3_0_1;
    A[745] = 0.467724867724863*G1_0_0 + 0.425396825396823*G1_0_1 + 0.467724867724863*G3_0_0 + 0.425396825396823*G3_0_1;
    A[746] = -0.651851851851847*G1_0_0 - 0.778835978835975*G1_0_1 - 0.651851851851847*G3_0_0 - 0.778835978835975*G3_0_1;
    A[747] = -0.0846560846560837*G1_0_0 - 0.0846560846560837*G3_0_0;
    A[748] = -0.0846560846560839*G1_0_0 - 0.0846560846560839*G3_0_0;
    A[749] = -0.0846560846560845*G1_0_0 - 0.0846560846560845*G3_0_0;
    A[750] = -0.00511463844797179*G5_0;
    A[751] = 0.0257495590828923*G5_0;
    A[752] = -0.00511463844797177*G5_0;
    A[753] = 0.0458553791887123*G5_0;
    A[754] = -0.0326278659611992*G5_0;
    A[755] = 0.0176366843033509*G5_0;
    A[756] = -0.00776014109347446*G5_0;
    A[757] = -0.00511463844797175*G5_0;
    A[758] = -0.00776014109347439*G5_0;
    A[759] = 0.0176366843033509*G5_0;
    A[760] = -0.0326278659611991*G5_0;
    A[761] = 0.0458553791887123*G5_0;
    A[762] = 0.00705467372134055*G5_0;
    A[763] = 0.00705467372134029*G5_0;
    A[764] = 0.00705467372134037*G5_0;
    A[765] = 0.0;
    A[766] = 0.0;
    A[767] = 0.0;
    A[768] = 0.0;
    A[769] = 0.0;
    A[770] = 0.0;
    A[771] = 0.0;
    A[772] = 0.0;
    A[773] = 0.0;
    A[774] = 0.0;
    A[775] = 0.0;
    A[776] = 0.0;
    A[777] = 0.0;
    A[778] = 0.0;
    A[779] = 0.0;
    A[780] = 0.0566137566137565*G1_1_0 + 0.0566137566137561*G1_1_1 + 0.0566137566137565*G3_1_0 + 0.0566137566137561*G3_1_1;
    A[781] = -0.0566137566137562*G1_1_0 - 0.0566137566137562*G3_1_0;
    A[782] = 0.373015873015871*G1_1_1 + 0.373015873015871*G3_1_1;
    A[783] = 0.203174603174604*G1_1_0 - 0.0423280423280405*G1_1_1 + 0.203174603174604*G3_1_0 - 0.0423280423280405*G3_1_1;
    A[784] = -0.425396825396826*G1_1_0 + 0.0423280423280393*G1_1_1 - 0.425396825396826*G3_1_0 + 0.0423280423280393*G3_1_1;
    A[785] = 0.778835978835978*G1_1_0 + 0.126984126984128*G1_1_1 + 0.778835978835978*G3_1_0 + 0.126984126984128*G3_1_1;
    A[786] = -0.203174603174604*G1_1_0 - 0.245502645502645*G1_1_1 - 0.203174603174604*G3_1_0 - 0.245502645502645*G3_1_1;
    A[787] = 0.425396825396827*G1_1_0 + 0.467724867724867*G1_1_1 + 0.425396825396827*G3_1_0 + 0.467724867724867*G3_1_1;
    A[788] = -0.778835978835978*G1_1_0 - 0.651851851851849*G1_1_1 - 0.778835978835978*G3_1_0 - 0.651851851851849*G3_1_1;
    A[789] = 0.0423280423280409*G1_1_1 + 0.0423280423280409*G3_1_1;
    A[790] = 0.042328042328042*G1_1_1 + 0.042328042328042*G3_1_1;
    A[791] = 0.0423280423280423*G1_1_1 + 0.0423280423280423*G3_1_1;
    A[792] = -0.0846560846560822*G1_1_1 - 0.0846560846560822*G3_1_1;
    A[793] = -0.0846560846560844*G1_1_1 - 0.0846560846560844*G3_1_1;
    A[794] = -0.0846560846560861*G1_1_1 - 0.0846560846560861*G3_1_1;
    A[795] = -0.00511463844797176*G5_1;
    A[796] = -0.00511463844797177*G5_1;
    A[797] = 0.0257495590828923*G5_1;
    A[798] = 0.017636684303351*G5_1;
    A[799] = -0.0326278659611993*G5_1;
    A[800] = 0.0458553791887124*G5_1;
    A[801] = 0.017636684303351*G5_1;
    A[802] = -0.0326278659611992*G5_1;
    A[803] = 0.0458553791887124*G5_1;
    A[804] = -0.00776014109347434*G5_1;
    A[805] = -0.00511463844797176*G5_1;
    A[806] = -0.00776014109347433*G5_1;
    A[807] = 0.00705467372134057*G5_1;
    A[808] = 0.00705467372134054*G5_1;
    A[809] = 0.00705467372134003*G5_1;
    A[810] = 0.0;
    A[811] = 0.0;
    A[812] = 0.0;
    A[813] = 0.0;
    A[814] = 0.0;
    A[815] = 0.0;
    A[816] = 0.0;
    A[817] = 0.0;
    A[818] = 0.0;
    A[819] = 0.0;
    A[820] = 0.0;
    A[821] = 0.0;
    A[822] = 0.0;
    A[823] = 0.0;
    A[824] = 0.0;
    A[825] = 0.04232804232804*G1_0_0 + 0.0423280423280384*G1_0_1 + 0.0423280423280395*G1_1_0 + 0.0423280423280363*G1_1_1 + 0.04232804232804*G3_0_0 + 0.0423280423280384*G3_0_1 + 0.0423280423280395*G3_1_0 + 0.0423280423280363*G3_1_1;
    A[826] = 0.126984126984126*G1_0_0 + 0.778835978835976*G1_1_0 + 0.126984126984126*G3_0_0 + 0.778835978835976*G3_1_0;
    A[827] = 0.203174603174604*G1_0_1 - 0.0423280423280405*G1_1_1 + 0.203174603174604*G3_0_1 - 0.0423280423280405*G3_1_1;
    A[828] = 1.82857142857142*G1_0_0 + 1.04973544973545*G1_0_1 + 1.04973544973545*G1_1_0 + 2.0994708994709*G1_1_1 + 1.82857142857142*G3_0_0 + 1.04973544973545*G3_0_1 + 1.04973544973545*G3_1_0 + 2.0994708994709*G3_1_1;
    A[829] = -0.660317460317459*G1_0_0 + 0.821164021164017*G1_0_1 - 0.296296296296294*G1_1_0 - 0.761904761904761*G1_1_1 - 0.660317460317459*G3_0_0 + 0.821164021164017*G3_0_1 - 0.296296296296294*G3_1_0 - 0.761904761904761*G3_1_1;
    A[830] = 0.33862433862434*G1_0_0 - 0.44021164021164*G1_0_1 + 0.101587301587306*G1_1_0 + 0.33862433862434*G1_1_1 + 0.33862433862434*G3_0_0 - 0.44021164021164*G3_0_1 + 0.101587301587306*G3_1_0 + 0.33862433862434*G3_1_1;
    A[831] = -0.203174603174601*G1_0_0 - 0.101587301587295*G1_0_1 - 0.101587301587307*G1_1_0 - 0.203174603174601*G3_0_0 - 0.101587301587295*G3_0_1 - 0.101587301587307*G3_1_0;
    A[832] = -0.152380952380952*G1_0_0 - 0.0423280423280416*G1_0_1 - 0.0423280423280379*G1_1_0 - 0.152380952380952*G3_0_0 - 0.0423280423280416*G3_0_1 - 0.0423280423280379*G3_1_0;
    A[833] = -0.33862433862434*G1_0_0 - 0.101587301587298*G1_0_1 - 0.101587301587305*G1_1_0 - 0.33862433862434*G3_0_0 - 0.101587301587298*G3_0_1 - 0.101587301587305*G3_1_0;
    A[834] = -0.135449735449728*G1_0_0 - 0.237037037037036*G1_0_1 - 0.237037037037028*G1_1_0 - 0.338624338624343*G1_1_1 - 0.135449735449728*G3_0_0 - 0.237037037037036*G3_0_1 - 0.237037037037028*G3_1_0 - 0.338624338624343*G3_1_1;
    A[835] = 0.101587301587291*G1_0_0 + 0.465608465608462*G1_0_1 + 0.46560846560845*G1_1_0 + 0.761904761904757*G1_1_1 + 0.101587301587291*G3_0_0 + 0.465608465608462*G3_0_1 + 0.46560846560845*G3_1_0 + 0.761904761904757*G3_1_1;
    A[836] = -0.135449735449728*G1_0_0 - 1.04973544973544*G1_0_1 - 1.04973544973544*G1_1_0 - 2.09947089947089*G1_1_1 - 0.135449735449728*G3_0_0 - 1.04973544973544*G3_0_1 - 1.04973544973544*G3_1_0 - 2.09947089947089*G3_1_1;
    A[837] = 0.812698412698406*G1_0_0 + 0.338624338624332*G1_0_1 + 0.338624338624346*G1_1_0 + 0.812698412698406*G3_0_0 + 0.338624338624332*G3_0_1 + 0.338624338624346*G3_1_0;
    A[838] = -2.43809523809523*G1_0_0 - 1.28677248677248*G1_0_1 - 1.28677248677249*G1_1_0 - 2.43809523809523*G3_0_0 - 1.28677248677248*G3_0_1 - 1.28677248677249*G3_1_0;
    A[839] = 0.81269841269841*G1_0_0 + 0.338624338624333*G1_0_1 + 0.338624338624331*G1_1_0 - 1.52950568876875e-14*G1_1_1 + 0.81269841269841*G3_0_0 + 0.338624338624333*G3_0_1 + 0.338624338624331*G3_1_0 - 1.52950568876875e-14*G3_1_1;
    A[840] = -0.00776014109347438*G5_0 - 0.00776014109347429*G5_1;
    A[841] = 0.00634920634920633*G5_0 + 0.0522045855379187*G5_1;
    A[842] = 0.00987654320987657*G5_0 - 0.00776014109347437*G5_1;
    A[843] = 0.158024691358024*G5_0 + 0.158024691358024*G5_1;
    A[844] = -0.016931216931217*G5_0 - 0.0902998236331568*G5_1;
    A[845] = 0.0451499118165789*G5_1;
    A[846] = 0.0225749559082893*G5_0 + 0.0112874779541452*G5_1;
    A[847] = 0.0169312169312168*G5_0 + 0.00282186948853558*G5_1;
    A[848] = 0.0451499118165786*G5_0 + 0.011287477954145*G5_1;
    A[849] = 0.033862433862434*G5_0 + 0.0451499118165791*G5_1;
    A[850] = -0.0592592592592591*G5_0 - 0.0902998236331569*G5_1;
    A[851] = 0.0790123456790122*G5_0 + 0.158024691358025*G5_1;
    A[852] = -0.0677248677248676*G5_0 - 0.0225749559082888*G5_1;
    A[853] = 0.203174603174603*G5_0 + 0.112874779541446*G5_1;
    A[854] = -0.0677248677248675*G5_0 - 0.0225749559082892*G5_1;
    A[855] = 0.0;
    A[856] = 0.0;
    A[857] = 0.0;
    A[858] = 0.0;
    A[859] = 0.0;
    A[860] = 0.0;
    A[861] = 0.0;
    A[862] = 0.0;
    A[863] = 0.0;
    A[864] = 0.0;
    A[865] = 0.0;
    A[866] = 0.0;
    A[867] = 0.0;
    A[868] = 0.0;
    A[869] = 0.0;
    A[870] = 0.0423280423280401*G1_0_0 + 0.0423280423280413*G1_0_1 + 0.0423280423280416*G1_1_0 + 0.0423280423280435*G1_1_1 + 0.0423280423280401*G3_0_0 + 0.0423280423280413*G3_0_1 + 0.0423280423280416*G3_1_0 + 0.0423280423280435*G3_1_1;
    A[871] = 0.0423280423280426*G1_0_0 - 0.425396825396824*G1_1_0 + 0.0423280423280426*G3_0_0 - 0.425396825396824*G3_1_0;
    A[872] = -0.425396825396826*G1_0_1 + 0.0423280423280394*G1_1_1 - 0.425396825396826*G3_0_1 + 0.0423280423280394*G3_1_1;
    A[873] = -0.660317460317459*G1_0_0 - 0.296296296296294*G1_0_1 + 0.821164021164018*G1_1_0 - 0.761904761904761*G1_1_1 - 0.660317460317459*G3_0_0 - 0.296296296296294*G3_0_1 + 0.821164021164018*G3_1_0 - 0.761904761904761*G3_1_1;
    A[874] = 2.45079365079365*G1_0_0 + 0.971428571428569*G1_0_1 + 0.971428571428569*G1_1_0 + 2.45079365079364*G1_1_1 + 2.45079365079365*G3_0_0 + 0.971428571428569*G3_0_1 + 0.971428571428569*G3_1_0 + 2.45079365079364*G3_1_1;
    A[875] = -0.761904761904765*G1_0_0 + 0.821164021164017*G1_0_1 - 0.296296296296305*G1_1_0 - 0.660317460317466*G1_1_1 - 0.761904761904765*G3_0_0 + 0.821164021164017*G3_0_1 - 0.296296296296305*G3_1_0 - 0.660317460317466*G3_1_1;
    A[876] = -0.152380952380946*G1_0_0 - 0.110052910052908*G1_0_1 - 0.110052910052895*G1_1_0 - 0.0677248677248669*G1_1_1 - 0.152380952380946*G3_0_0 - 0.110052910052908*G3_0_1 - 0.110052910052895*G3_1_0 - 0.0677248677248669*G3_1_1;
    A[877] = 0.393650793650788*G1_0_0 + 0.196825396825396*G1_0_1 + 0.196825396825387*G1_1_0 + 0.0507936507936495*G1_1_1 + 0.393650793650788*G3_0_0 + 0.196825396825396*G3_0_1 + 0.196825396825387*G3_1_0 + 0.0507936507936495*G3_1_1;
    A[878] = 0.761904761904765*G1_0_0 + 0.296296296296298*G1_0_1 + 0.296296296296305*G1_1_0 - 0.0677248677248641*G1_1_1 + 0.761904761904765*G3_0_0 + 0.296296296296298*G3_0_1 + 0.296296296296305*G3_1_0 - 0.0677248677248641*G3_1_1;
    A[879] = -0.067724867724864*G1_0_0 - 0.110052910052907*G1_0_1 - 0.110052910052908*G1_1_0 - 0.152380952380943*G1_1_1 - 0.067724867724864*G3_0_0 - 0.110052910052907*G3_0_1 - 0.110052910052908*G3_1_0 - 0.152380952380943*G3_1_1;
    A[880] = 0.0507936507936503*G1_0_0 + 0.196825396825396*G1_0_1 + 0.196825396825396*G1_1_0 + 0.393650793650791*G1_1_1 + 0.0507936507936503*G3_0_0 + 0.196825396825396*G3_0_1 + 0.196825396825396*G3_1_0 + 0.393650793650791*G3_1_1;
    A[881] = -0.0677248677248689*G1_0_0 + 0.296296296296295*G1_0_1 + 0.296296296296294*G1_1_0 + 0.761904761904762*G1_1_1 - 0.0677248677248689*G3_0_0 + 0.296296296296295*G3_0_1 + 0.296296296296294*G3_1_0 + 0.761904761904762*G3_1_1;
    A[882] = 0.406349206349193*G1_0_0 + 0.457142857142842*G1_0_1 + 0.457142857142832*G1_1_0 + 0.406349206349181*G1_1_1 + 0.406349206349193*G3_0_0 + 0.457142857142842*G3_0_1 + 0.457142857142832*G3_1_0 + 0.406349206349181*G3_1_1;
    A[883] = 0.406349206349211*G1_0_0 - 1.16825396825397*G1_0_1 - 1.16825396825395*G1_1_0 - 2.84444444444444*G1_1_1 + 0.406349206349211*G3_0_0 - 1.16825396825397*G3_0_1 - 1.16825396825395*G3_1_0 - 2.84444444444444*G3_1_1;
    A[884] = -2.84444444444443*G1_0_0 - 1.16825396825395*G1_0_1 - 1.16825396825396*G1_1_0 + 0.406349206349225*G1_1_1 - 2.84444444444443*G3_0_0 - 1.16825396825395*G3_0_1 - 1.16825396825396*G3_1_0 + 0.406349206349225*G3_1_1;
    A[885] = -0.00511463844797178*G5_0 - 0.00511463844797192*G5_1;
    A[886] = 0.00194003527336863*G5_0 - 0.0306878306878306*G5_1;
    A[887] = -0.0306878306878308*G5_0 + 0.00194003527336844*G5_1;
    A[888] = -0.0507936507936507*G5_0 + 0.022574955908289*G5_1;
    A[889] = 0.165079365079365*G5_0 + 0.165079365079365*G5_1;
    A[890] = 0.022574955908289*G5_0 - 0.0507936507936514*G5_1;
    A[891] = 0.0169312169312169*G5_0 + 0.0141093474426799*G5_1;
    A[892] = -0.021164021164021*G5_0 - 0.0105820105820098*G5_1;
    A[893] = -0.0902998236331572*G5_0 - 0.0310405643738984*G5_1;
    A[894] = 0.0141093474426807*G5_0 + 0.0169312169312162*G5_1;
    A[895] = -0.0105820105820106*G5_0 - 0.0211640211640208*G5_1;
    A[896] = -0.0310405643738975*G5_0 - 0.0902998236331571*G5_1;
    A[897] = -0.0846560846560842*G5_0 - 0.0846560846560849*G5_1;
    A[898] = 0.0507936507936509*G5_0 + 0.186243386243386*G5_1;
    A[899] = 0.186243386243386*G5_0 + 0.05079365079365*G5_1;
    A[900] = 0.0;
    A[901] = 0.0;
    A[902] = 0.0;
    A[903] = 0.0;
    A[904] = 0.0;
    A[905] = 0.0;
    A[906] = 0.0;
    A[907] = 0.0;
    A[908] = 0.0;
    A[909] = 0.0;
    A[910] = 0.0;
    A[911] = 0.0;
    A[912] = 0.0;
    A[913] = 0.0;
    A[914] = 0.0;
    A[915] = 0.0423280423280428*G1_0_0 + 0.0423280423280414*G1_0_1 + 0.0423280423280417*G1_1_0 + 0.0423280423280404*G1_1_1 + 0.0423280423280428*G3_0_0 + 0.0423280423280414*G3_0_1 + 0.0423280423280417*G3_1_0 + 0.0423280423280404*G3_1_1;
    A[916] = -0.0423280423280422*G1_0_0 + 0.203174603174602*G1_1_0 - 0.0423280423280422*G3_0_0 + 0.203174603174602*G3_1_0;
    A[917] = 0.778835978835978*G1_0_1 + 0.126984126984128*G1_1_1 + 0.778835978835978*G3_0_1 + 0.126984126984128*G3_1_1;
    A[918] = 0.33862433862434*G1_0_0 + 0.101587301587305*G1_0_1 - 0.44021164021164*G1_1_0 + 0.33862433862434*G1_1_1 + 0.33862433862434*G3_0_0 + 0.101587301587305*G3_0_1 - 0.44021164021164*G3_1_0 + 0.33862433862434*G3_1_1;
    A[919] = -0.761904761904765*G1_0_0 - 0.296296296296305*G1_0_1 + 0.821164021164017*G1_1_0 - 0.660317460317466*G1_1_1 - 0.761904761904765*G3_0_0 - 0.296296296296305*G3_0_1 + 0.821164021164017*G3_1_0 - 0.660317460317466*G3_1_1;
    A[920] = 2.09947089947091*G1_0_0 + 1.04973544973546*G1_0_1 + 1.04973544973546*G1_1_0 + 1.82857142857143*G1_1_1 + 2.09947089947091*G3_0_0 + 1.04973544973546*G3_0_1 + 1.04973544973546*G3_1_0 + 1.82857142857143*G3_1_1;
    A[921] = -0.338624338624341*G1_0_0 - 0.237037037037037*G1_0_1 - 0.237037037037039*G1_1_0 - 0.135449735449733*G1_1_1 - 0.338624338624341*G3_0_0 - 0.237037037037037*G3_0_1 - 0.237037037037039*G3_1_0 - 0.135449735449733*G3_1_1;
    A[922] = 0.761904761904769*G1_0_0 + 0.465608465608467*G1_0_1 + 0.465608465608474*G1_1_0 + 0.101587301587304*G1_1_1 + 0.761904761904769*G3_0_0 + 0.465608465608467*G3_0_1 + 0.465608465608474*G3_1_0 + 0.101587301587304*G3_1_1;
    A[923] = -2.09947089947091*G1_0_0 - 1.04973544973545*G1_0_1 - 1.04973544973546*G1_1_0 - 0.135449735449735*G1_1_1 - 2.09947089947091*G3_0_0 - 1.04973544973545*G3_0_1 - 1.04973544973546*G3_1_0 - 0.135449735449735*G3_1_1;
    A[924] = -0.101587301587305*G1_0_1 - 0.1015873015873*G1_1_0 - 0.203174603174607*G1_1_1 - 0.101587301587305*G3_0_1 - 0.1015873015873*G3_1_0 - 0.203174603174607*G3_1_1;
    A[925] = -0.0423280423280413*G1_0_1 - 0.0423280423280442*G1_1_0 - 0.152380952380951*G1_1_1 - 0.0423280423280413*G3_0_1 - 0.0423280423280442*G3_1_0 - 0.152380952380951*G3_1_1;
    A[926] = -0.101587301587298*G1_0_1 - 0.1015873015873*G1_1_0 - 0.338624338624333*G1_1_1 - 0.101587301587298*G3_0_1 - 0.1015873015873*G3_1_0 - 0.338624338624333*G3_1_1;
    A[927] = 0.338624338624346*G1_0_1 + 0.338624338624342*G1_1_0 + 0.812698412698421*G1_1_1 + 0.338624338624346*G3_0_1 + 0.338624338624342*G3_1_0 + 0.812698412698421*G3_1_1;
    A[928] = 0.338624338624336*G1_0_1 + 0.338624338624336*G1_1_0 + 0.812698412698409*G1_1_1 + 0.338624338624336*G3_0_1 + 0.338624338624336*G3_1_0 + 0.812698412698409*G3_1_1;
    A[929] = -1.2867724867725*G1_0_1 - 1.28677248677249*G1_1_0 - 2.43809523809525*G1_1_1 - 1.2867724867725*G3_0_1 - 1.28677248677249*G3_1_0 - 2.43809523809525*G3_1_1;
    A[930] = -0.00776014109347446*G5_0 - 0.00776014109347438*G5_1;
    A[931] = -0.00776014109347447*G5_0 + 0.00987654320987643*G5_1;
    A[932] = 0.0522045855379189*G5_0 + 0.00634920634920647*G5_1;
    A[933] = 0.0451499118165785*G5_0;
    A[934] = -0.0902998236331571*G5_0 - 0.016931216931217*G5_1;
    A[935] = 0.158024691358025*G5_0 + 0.158024691358025*G5_1;
    A[936] = 0.0451499118165785*G5_0 + 0.0338624338624341*G5_1;
    A[937] = -0.090299823633157*G5_0 - 0.0592592592592598*G5_1;
    A[938] = 0.158024691358025*G5_0 + 0.0790123456790126*G5_1;
    A[939] = 0.0112874779541446*G5_0 + 0.0225749559082893*G5_1;
    A[940] = 0.00282186948853619*G5_0 + 0.016931216931217*G5_1;
    A[941] = 0.0112874779541446*G5_0 + 0.0451499118165783*G5_1;
    A[942] = -0.0225749559082894*G5_0 - 0.067724867724868*G5_1;
    A[943] = -0.0225749559082894*G5_0 - 0.0677248677248683*G5_1;
    A[944] = 0.112874779541446*G5_0 + 0.203174603174603*G5_1;
    A[945] = 0.0;
    A[946] = 0.0;
    A[947] = 0.0;
    A[948] = 0.0;
    A[949] = 0.0;
    A[950] = 0.0;
    A[951] = 0.0;
    A[952] = 0.0;
    A[953] = 0.0;
    A[954] = 0.0;
    A[955] = 0.0;
    A[956] = 0.0;
    A[957] = 0.0;
    A[958] = 0.0;
    A[959] = 0.0;
    A[960] = 0.126984126984129*G1_0_0 + 0.126984126984129*G1_0_1 - 0.651851851851853*G1_1_0 - 0.651851851851852*G1_1_1 + 0.126984126984129*G3_0_0 + 0.126984126984129*G3_0_1 - 0.651851851851853*G3_1_0 - 0.651851851851852*G3_1_1;
    A[961] = 0.0423280423280418*G1_0_0 + 0.0423280423280418*G3_0_0;
    A[962] = -0.203174603174604*G1_0_1 - 0.245502645502645*G1_1_1 - 0.203174603174604*G3_0_1 - 0.245502645502645*G3_1_1;
    A[963] = -0.203174603174601*G1_0_0 - 0.101587301587307*G1_0_1 - 0.101587301587295*G1_1_0 - 0.203174603174601*G3_0_0 - 0.101587301587307*G3_0_1 - 0.101587301587295*G3_1_0;
    A[964] = -0.152380952380946*G1_0_0 - 0.110052910052895*G1_0_1 - 0.110052910052908*G1_1_0 - 0.067724867724867*G1_1_1 - 0.152380952380946*G3_0_0 - 0.110052910052895*G3_0_1 - 0.110052910052908*G3_1_0 - 0.067724867724867*G3_1_1;
    A[965] = -0.338624338624341*G1_0_0 - 0.237037037037039*G1_0_1 - 0.237037037037037*G1_1_0 - 0.135449735449734*G1_1_1 - 0.338624338624341*G3_0_0 - 0.237037037037039*G3_0_1 - 0.237037037037037*G3_1_0 - 0.135449735449734*G3_1_1;
    A[966] = 1.82857142857143*G1_0_0 + 0.778835978835979*G1_0_1 + 0.778835978835978*G1_1_0 + 1.82857142857143*G1_1_1 + 1.82857142857143*G3_0_0 + 0.778835978835979*G3_0_1 + 0.778835978835978*G3_1_0 + 1.82857142857143*G3_1_1;
    A[967] = -0.660317460317455*G1_0_0 - 1.48148148148148*G1_0_1 - 0.364021164021164*G1_1_0 - 1.94708994708994*G1_1_1 - 0.660317460317455*G3_0_0 - 1.48148148148148*G3_0_1 - 0.364021164021164*G3_1_0 - 1.94708994708994*G3_1_1;
    A[968] = 0.338624338624341*G1_0_0 + 0.778835978835976*G1_0_1 + 0.237037037037037*G1_1_0 + 1.01587301587301*G1_1_1 + 0.338624338624341*G3_0_0 + 0.778835978835976*G3_0_1 + 0.237037037037037*G3_1_0 + 1.01587301587301*G3_1_1;
    A[969] = -0.135449735449741*G1_0_0 + 0.914285714285713*G1_0_1 + 0.914285714285717*G1_1_0 - 0.135449735449735*G1_1_1 - 0.135449735449741*G3_0_0 + 0.914285714285713*G3_0_1 + 0.914285714285717*G3_1_0 - 0.135449735449735*G3_1_1;
    A[970] = 0.101587301587306*G1_0_0 - 0.364021164021163*G1_0_1 - 0.364021164021165*G1_1_0 - 0.0677248677248648*G1_1_1 + 0.101587301587306*G3_0_0 - 0.364021164021163*G3_0_1 - 0.364021164021165*G3_1_0 - 0.0677248677248648*G3_1_1;
    A[971] = -0.135449735449736*G1_0_0 + 0.1015873015873*G1_0_1 + 0.101587301587299*G1_1_0 - 0.135449735449736*G3_0_0 + 0.1015873015873*G3_0_1 + 0.101587301587299*G3_1_0;
    A[972] = -2.43809523809524*G1_0_0 - 1.15132275132275*G1_0_1 - 1.15132275132275*G1_1_0 + 0.135449735449735*G1_1_1 - 2.43809523809524*G3_0_0 - 1.15132275132275*G3_0_1 - 1.15132275132275*G3_1_0 + 0.135449735449735*G3_1_1;
    A[973] = 0.812698412698416*G1_0_0 + 0.474074074074066*G1_0_1 + 0.474074074074065*G1_1_0 + 0.135449735449731*G1_1_1 + 0.812698412698416*G3_0_0 + 0.474074074074066*G3_0_1 + 0.474074074074065*G3_1_0 + 0.135449735449731*G3_1_1;
    A[974] = 0.812698412698401*G1_0_0 + 0.474074074074077*G1_0_1 + 0.474074074074071*G1_1_0 + 0.135449735449732*G1_1_1 + 0.812698412698401*G3_0_0 + 0.474074074074077*G3_0_1 + 0.474074074074071*G3_1_0 + 0.135449735449732*G3_1_1;
    A[975] = -0.00634920634920632*G5_0 + 0.0458553791887124*G5_1;
    A[976] = 0.0077601410934744*G5_0;
    A[977] = -0.00987654320987659*G5_0 - 0.017636684303351*G5_1;
    A[978] = -0.0225749559082891*G5_0 - 0.011287477954144*G5_1;
    A[979] = -0.0169312169312162*G5_0 - 0.0141093474426806*G5_1;
    A[980] = -0.0451499118165785*G5_0 - 0.0338624338624336*G5_1;
    A[981] = -0.158024691358025*G5_0;
    A[982] = 0.0169312169312165*G5_0 - 0.07336860670194*G5_1;
    A[983] = 0.0451499118165784*G5_1;
    A[984] = -0.0790123456790122*G5_0 + 0.0790123456790125*G5_1;
    A[985] = 0.0592592592592591*G5_0 - 0.0310405643738981*G5_1;
    A[986] = -0.033862433862434*G5_0 + 0.0112874779541449*G5_1;
    A[987] = -0.203174603174604*G5_0 - 0.0902998236331575*G5_1;
    A[988] = 0.0677248677248689*G5_0 + 0.0451499118165792*G5_1;
    A[989] = 0.0677248677248677*G5_0 + 0.0451499118165788*G5_1;
    A[990] = 0.0;
    A[991] = 0.0;
    A[992] = 0.0;
    A[993] = 0.0;
    A[994] = 0.0;
    A[995] = 0.0;
    A[996] = 0.0;
    A[997] = 0.0;
    A[998] = 0.0;
    A[999] = 0.0;
    A[1000] = 0.0;
    A[1001] = 0.0;
    A[1002] = 0.0;
    A[1003] = 0.0;
    A[1004] = 0.0;
    A[1005] = 0.0423280423280412*G1_0_0 + 0.0423280423280428*G1_0_1 + 0.467724867724866*G1_1_0 + 0.467724867724866*G1_1_1 + 0.0423280423280412*G3_0_0 + 0.0423280423280428*G3_0_1 + 0.467724867724866*G3_1_0 + 0.467724867724866*G3_1_1;
    A[1006] = 0.042328042328042*G1_0_0 + 0.042328042328042*G3_0_0;
    A[1007] = 0.425396825396827*G1_0_1 + 0.467724867724867*G1_1_1 + 0.425396825396827*G3_0_1 + 0.467724867724867*G3_1_1;
    A[1008] = -0.152380952380952*G1_0_0 - 0.0423280423280379*G1_0_1 - 0.0423280423280416*G1_1_0 - 0.152380952380952*G3_0_0 - 0.0423280423280379*G3_0_1 - 0.0423280423280416*G3_1_0;
    A[1009] = 0.393650793650788*G1_0_0 + 0.196825396825387*G1_0_1 + 0.196825396825396*G1_1_0 + 0.0507936507936495*G1_1_1 + 0.393650793650788*G3_0_0 + 0.196825396825387*G3_0_1 + 0.196825396825396*G3_1_0 + 0.0507936507936495*G3_1_1;
    A[1010] = 0.761904761904769*G1_0_0 + 0.465608465608474*G1_0_1 + 0.465608465608467*G1_1_0 + 0.101587301587304*G1_1_1 + 0.761904761904769*G3_0_0 + 0.465608465608474*G3_0_1 + 0.465608465608467*G3_1_0 + 0.101587301587304*G3_1_1;
    A[1011] = -0.660317460317455*G1_0_0 - 0.364021164021164*G1_0_1 - 1.48148148148148*G1_1_0 - 1.94708994708994*G1_1_1 - 0.660317460317455*G3_0_0 - 0.364021164021164*G3_0_1 - 1.48148148148148*G3_1_0 - 1.94708994708994*G3_1_1;
    A[1012] = 2.45079365079365*G1_0_0 + 1.47936507936508*G1_0_1 + 1.47936507936508*G1_1_0 + 2.95873015873015*G1_1_1 + 2.45079365079365*G3_0_0 + 1.47936507936508*G3_0_1 + 1.47936507936508*G3_1_0 + 2.95873015873015*G3_1_1;
    A[1013] = -0.761904761904769*G1_0_0 - 1.58306878306878*G1_0_1 - 0.465608465608467*G1_1_0 - 1.94708994708994*G1_1_1 - 0.761904761904769*G3_0_0 - 1.58306878306878*G3_0_1 - 0.465608465608467*G3_1_0 - 1.94708994708994*G3_1_1;
    A[1014] = -0.0677248677248647*G1_0_0 - 0.36402116402116*G1_0_1 - 0.364021164021163*G1_1_0 + 0.101587301587297*G1_1_1 - 0.0677248677248647*G3_0_0 - 0.36402116402116*G3_0_1 - 0.364021164021163*G3_1_0 + 0.101587301587297*G3_1_1;
    A[1015] = 0.0507936507936486*G1_0_0 - 0.146031746031748*G1_0_1 - 0.146031746031746*G1_1_0 + 0.0507936507936495*G1_1_1 + 0.0507936507936486*G3_0_0 - 0.146031746031748*G3_0_1 - 0.146031746031746*G3_1_0 + 0.0507936507936495*G3_1_1;
    A[1016] = -0.067724867724867*G1_0_0 + 0.0423280423280398*G1_0_1 + 0.0423280423280429*G1_1_0 - 0.067724867724867*G3_0_0 + 0.0423280423280398*G3_0_1 + 0.0423280423280429*G3_1_0;
    A[1017] = 0.406349206349198*G1_0_0 + 1.57460317460317*G1_0_1 + 1.57460317460318*G1_1_0 - 0.101587301587297*G1_1_1 + 0.406349206349198*G3_0_0 + 1.57460317460317*G3_0_1 + 1.57460317460318*G3_1_0 - 0.101587301587297*G3_1_1;
    A[1018] = 0.40634920634921*G1_0_0 - 0.0507936507936399*G1_0_1 - 0.050793650793651*G1_1_0 - 0.1015873015873*G1_1_1 + 0.40634920634921*G3_0_0 - 0.0507936507936399*G3_0_1 - 0.050793650793651*G3_1_0 - 0.1015873015873*G3_1_1;
    A[1019] = -2.84444444444443*G1_0_0 - 1.67619047619048*G1_0_1 - 1.67619047619047*G1_1_0 - 0.101587301587302*G1_1_1 - 2.84444444444443*G3_0_0 - 1.67619047619048*G3_0_1 - 1.67619047619047*G3_1_0 - 0.101587301587302*G3_1_1;
    A[1020] = -0.00194003527336868*G5_0 - 0.0326278659611991*G5_1;
    A[1021] = 0.00511463844797175*G5_0;
    A[1022] = 0.0306878306878308*G5_0 + 0.0326278659611992*G5_1;
    A[1023] = -0.0169312169312168*G5_0 - 0.00282186948853604*G5_1;
    A[1024] = 0.0211640211640207*G5_0 + 0.0105820105820104*G5_1;
    A[1025] = 0.0902998236331573*G5_0 + 0.0592592592592593*G5_1;
    A[1026] = 0.0507936507936507*G5_0 + 0.0733686067019404*G5_1;
    A[1027] = -0.165079365079365*G5_0;
    A[1028] = -0.0225749559082889*G5_0 - 0.0733686067019396*G5_1;
    A[1029] = 0.0310405643738975*G5_0 - 0.0592592592592587*G5_1;
    A[1030] = 0.0105820105820106*G5_0 - 0.0105820105820106*G5_1;
    A[1031] = -0.0141093474426807*G5_0 + 0.00282186948853644*G5_1;
    A[1032] = -0.0507936507936505*G5_0 + 0.135449735449736*G5_1;
    A[1033] = 0.0846560846560838*G5_0;
    A[1034] = -0.186243386243386*G5_0 - 0.135449735449736*G5_1;
    A[1035] = 0.0;
    A[1036] = 0.0;
    A[1037] = 0.0;
    A[1038] = 0.0;
    A[1039] = 0.0;
    A[1040] = 0.0;
    A[1041] = 0.0;
    A[1042] = 0.0;
    A[1043] = 0.0;
    A[1044] = 0.0;
    A[1045] = 0.0;
    A[1046] = 0.0;
    A[1047] = 0.0;
    A[1048] = 0.0;
    A[1049] = 0.0;
    A[1050] = -0.0423280423280427*G1_0_0 - 0.0423280423280414*G1_0_1 - 0.245502645502645*G1_1_0 - 0.245502645502645*G1_1_1 - 0.0423280423280427*G3_0_0 - 0.0423280423280414*G3_0_1 - 0.245502645502645*G3_1_0 - 0.245502645502645*G3_1_1;
    A[1051] = 0.0423280423280422*G1_0_0 + 0.0423280423280422*G3_0_0;
    A[1052] = -0.778835978835978*G1_0_1 - 0.651851851851849*G1_1_1 - 0.778835978835978*G3_0_1 - 0.651851851851849*G3_1_1;
    A[1053] = -0.33862433862434*G1_0_0 - 0.101587301587305*G1_0_1 - 0.101587301587298*G1_1_0 - 0.33862433862434*G3_0_0 - 0.101587301587305*G3_0_1 - 0.101587301587298*G3_1_0;
    A[1054] = 0.761904761904765*G1_0_0 + 0.296296296296305*G1_0_1 + 0.296296296296298*G1_1_0 - 0.0677248677248641*G1_1_1 + 0.761904761904765*G3_0_0 + 0.296296296296305*G3_0_1 + 0.296296296296298*G3_1_0 - 0.0677248677248641*G3_1_1;
    A[1055] = -2.09947089947091*G1_0_0 - 1.04973544973546*G1_0_1 - 1.04973544973545*G1_1_0 - 0.135449735449735*G1_1_1 - 2.09947089947091*G3_0_0 - 1.04973544973546*G3_0_1 - 1.04973544973545*G3_1_0 - 0.135449735449735*G3_1_1;
    A[1056] = 0.338624338624341*G1_0_0 + 0.237037037037037*G1_0_1 + 0.778835978835976*G1_1_0 + 1.01587301587301*G1_1_1 + 0.338624338624341*G3_0_0 + 0.237037037037037*G3_0_1 + 0.778835978835976*G3_1_0 + 1.01587301587301*G3_1_1;
    A[1057] = -0.761904761904769*G1_0_0 - 0.465608465608467*G1_0_1 - 1.58306878306878*G1_1_0 - 1.94708994708994*G1_1_1 - 0.761904761904769*G3_0_0 - 0.465608465608467*G3_0_1 - 1.58306878306878*G3_1_0 - 1.94708994708994*G3_1_1;
    A[1058] = 2.09947089947091*G1_0_0 + 1.04973544973545*G1_0_1 + 1.04973544973545*G1_1_0 + 1.82857142857142*G1_1_1 + 2.09947089947091*G3_0_0 + 1.04973544973545*G3_0_1 + 1.04973544973545*G3_1_0 + 1.82857142857142*G3_1_1;
    A[1059] = 0.101587301587305*G1_0_1 + 0.101587301587301*G1_1_0 - 0.135449735449737*G1_1_1 + 0.101587301587305*G3_0_1 + 0.101587301587301*G3_1_0 - 0.135449735449737*G3_1_1;
    A[1060] = 0.0423280423280411*G1_0_1 + 0.042328042328043*G1_1_0 - 0.0677248677248685*G1_1_1 + 0.0423280423280411*G3_0_1 + 0.042328042328043*G3_1_0 - 0.0677248677248685*G3_1_1;
    A[1061] = 0.101587301587298*G1_0_1 + 0.1015873015873*G1_1_0 + 0.101587301587298*G3_0_1 + 0.1015873015873*G3_1_0;
    A[1062] = -0.338624338624346*G1_0_1 - 0.338624338624339*G1_1_0 + 0.135449735449733*G1_1_1 - 0.338624338624346*G3_0_1 - 0.338624338624339*G3_1_0 + 0.135449735449733*G3_1_1;
    A[1063] = -0.338624338624336*G1_0_1 - 0.338624338624339*G1_1_0 + 0.135449735449735*G1_1_1 - 0.338624338624336*G3_0_1 - 0.338624338624339*G3_1_0 + 0.135449735449735*G3_1_1;
    A[1064] = 1.2867724867725*G1_0_1 + 1.28677248677249*G1_1_0 + 0.135449735449737*G1_1_1 + 1.2867724867725*G3_0_1 + 1.28677248677249*G3_1_0 + 0.135449735449737*G3_1_1;
    A[1065] = 0.00776014109347445*G5_0 + 0.0176366843033509*G5_1;
    A[1066] = 0.00776014109347447*G5_0;
    A[1067] = -0.0522045855379189*G5_0 - 0.0458553791887125*G5_1;
    A[1068] = -0.0451499118165785*G5_0 - 0.0112874779541441*G5_1;
    A[1069] = 0.090299823633157*G5_0 + 0.0310405643738975*G5_1;
    A[1070] = -0.158024691358025*G5_0 - 0.0790123456790117*G5_1;
    A[1071] = -0.0451499118165785*G5_0 - 0.0451499118165782*G5_1;
    A[1072] = 0.090299823633157*G5_0 + 0.0733686067019398*G5_1;
    A[1073] = -0.158024691358025*G5_0;
    A[1074] = -0.0112874779541446*G5_0 + 0.033862433862434*G5_1;
    A[1075] = -0.00282186948853618*G5_0 + 0.0141093474426807*G5_1;
    A[1076] = -0.0112874779541446*G5_0 + 0.0112874779541451*G5_1;
    A[1077] = 0.0225749559082894*G5_0 - 0.0451499118165781*G5_1;
    A[1078] = 0.0225749559082894*G5_0 - 0.0451499118165775*G5_1;
    A[1079] = -0.112874779541446*G5_0 + 0.0902998236331581*G5_1;
    A[1080] = 0.0;
    A[1081] = 0.0;
    A[1082] = 0.0;
    A[1083] = 0.0;
    A[1084] = 0.0;
    A[1085] = 0.0;
    A[1086] = 0.0;
    A[1087] = 0.0;
    A[1088] = 0.0;
    A[1089] = 0.0;
    A[1090] = 0.0;
    A[1091] = 0.0;
    A[1092] = 0.0;
    A[1093] = 0.0;
    A[1094] = 0.0;
    A[1095] = -0.651851851851855*G1_0_0 - 0.651851851851855*G1_0_1 + 0.126984126984129*G1_1_0 + 0.126984126984128*G1_1_1 - 0.651851851851855*G3_0_0 - 0.651851851851855*G3_0_1 + 0.126984126984129*G3_1_0 + 0.126984126984128*G3_1_1;
    A[1096] = -0.245502645502644*G1_0_0 - 0.203174603174603*G1_1_0 - 0.245502645502644*G3_0_0 - 0.203174603174603*G3_1_0;
    A[1097] = 0.0423280423280409*G1_1_1 + 0.0423280423280409*G3_1_1;
    A[1098] = -0.135449735449728*G1_0_0 - 0.237037037037028*G1_0_1 - 0.237037037037036*G1_1_0 - 0.338624338624343*G1_1_1 - 0.135449735449728*G3_0_0 - 0.237037037037028*G3_0_1 - 0.237037037037036*G3_1_0 - 0.338624338624343*G3_1_1;
    A[1099] = -0.067724867724864*G1_0_0 - 0.110052910052908*G1_0_1 - 0.110052910052907*G1_1_0 - 0.152380952380943*G1_1_1 - 0.067724867724864*G3_0_0 - 0.110052910052908*G3_0_1 - 0.110052910052907*G3_1_0 - 0.152380952380943*G3_1_1;
    A[1100] = -0.1015873015873*G1_0_1 - 0.101587301587305*G1_1_0 - 0.203174603174607*G1_1_1 - 0.1015873015873*G3_0_1 - 0.101587301587305*G3_1_0 - 0.203174603174607*G3_1_1;
    A[1101] = -0.135449735449741*G1_0_0 + 0.914285714285717*G1_0_1 + 0.914285714285713*G1_1_0 - 0.135449735449735*G1_1_1 - 0.135449735449741*G3_0_0 + 0.914285714285717*G3_0_1 + 0.914285714285713*G3_1_0 - 0.135449735449735*G3_1_1;
    A[1102] = -0.0677248677248647*G1_0_0 - 0.364021164021163*G1_0_1 - 0.36402116402116*G1_1_0 + 0.101587301587297*G1_1_1 - 0.0677248677248647*G3_0_0 - 0.364021164021163*G3_0_1 - 0.36402116402116*G3_1_0 + 0.101587301587297*G3_1_1;
    A[1103] = 0.101587301587301*G1_0_1 + 0.101587301587305*G1_1_0 - 0.135449735449737*G1_1_1 + 0.101587301587301*G3_0_1 + 0.101587301587305*G3_1_0 - 0.135449735449737*G3_1_1;
    A[1104] = 1.82857142857143*G1_0_0 + 0.778835978835974*G1_0_1 + 0.778835978835974*G1_1_0 + 1.82857142857143*G1_1_1 + 1.82857142857143*G3_0_0 + 0.778835978835974*G3_0_1 + 0.778835978835974*G3_1_0 + 1.82857142857143*G3_1_1;
    A[1105] = -1.94708994708995*G1_0_0 - 0.364021164021159*G1_0_1 - 1.48148148148147*G1_1_0 - 0.660317460317453*G1_1_1 - 1.94708994708995*G3_0_0 - 0.364021164021159*G3_0_1 - 1.48148148148147*G3_1_0 - 0.660317460317453*G3_1_1;
    A[1106] = 1.01587301587301*G1_0_0 + 0.23703703703703*G1_0_1 + 0.778835978835975*G1_1_0 + 0.338624338624337*G1_1_1 + 1.01587301587301*G3_0_0 + 0.23703703703703*G3_0_1 + 0.778835978835975*G3_1_0 + 0.338624338624337*G3_1_1;
    A[1107] = 0.135449735449746*G1_0_0 - 1.15132275132274*G1_0_1 - 1.15132275132275*G1_1_0 - 2.43809523809524*G1_1_1 + 0.135449735449746*G3_0_0 - 1.15132275132274*G3_0_1 - 1.15132275132275*G3_1_0 - 2.43809523809524*G3_1_1;
    A[1108] = 0.135449735449723*G1_0_0 + 0.474074074074063*G1_0_1 + 0.474074074074072*G1_1_0 + 0.8126984126984*G1_1_1 + 0.135449735449723*G3_0_0 + 0.474074074074063*G3_0_1 + 0.474074074074072*G3_1_0 + 0.8126984126984*G3_1_1;
    A[1109] = 0.135449735449729*G1_0_0 + 0.474074074074072*G1_0_1 + 0.474074074074067*G1_1_0 + 0.812698412698421*G1_1_1 + 0.135449735449729*G3_0_0 + 0.474074074074072*G3_0_1 + 0.474074074074067*G3_1_0 + 0.812698412698421*G3_1_1;
    A[1110] = 0.0458553791887127*G5_0 - 0.0063492063492062*G5_1;
    A[1111] = -0.0176366843033509*G5_0 - 0.00987654320987649*G5_1;
    A[1112] = 0.00776014109347438*G5_1;
    A[1113] = -0.033862433862433*G5_0 - 0.0451499118165783*G5_1;
    A[1114] = -0.0141093474426805*G5_0 - 0.0169312169312166*G5_1;
    A[1115] = -0.0112874779541445*G5_0 - 0.0225749559082895*G5_1;
    A[1116] = 0.079012345679013*G5_0 - 0.0790123456790122*G5_1;
    A[1117] = -0.0310405643738982*G5_0 + 0.059259259259259*G5_1;
    A[1118] = 0.0112874779541447*G5_0 - 0.0338624338624342*G5_1;
    A[1119] = -0.158024691358025*G5_1;
    A[1120] = -0.0733686067019408*G5_0 + 0.0169312169312163*G5_1;
    A[1121] = 0.045149911816579*G5_0;
    A[1122] = -0.0902998236331568*G5_0 - 0.203174603174604*G5_1;
    A[1123] = 0.0451499118165794*G5_0 + 0.0677248677248674*G5_1;
    A[1124] = 0.0451499118165784*G5_0 + 0.0677248677248674*G5_1;
    A[1125] = 0.0;
    A[1126] = 0.0;
    A[1127] = 0.0;
    A[1128] = 0.0;
    A[1129] = 0.0;
    A[1130] = 0.0;
    A[1131] = 0.0;
    A[1132] = 0.0;
    A[1133] = 0.0;
    A[1134] = 0.0;
    A[1135] = 0.0;
    A[1136] = 0.0;
    A[1137] = 0.0;
    A[1138] = 0.0;
    A[1139] = 0.0;
    A[1140] = 0.467724867724869*G1_0_0 + 0.467724867724869*G1_0_1 + 0.0423280423280412*G1_1_0 + 0.0423280423280403*G1_1_1 + 0.467724867724869*G3_0_0 + 0.467724867724869*G3_0_1 + 0.0423280423280412*G3_1_0 + 0.0423280423280403*G3_1_1;
    A[1141] = 0.467724867724863*G1_0_0 + 0.425396825396823*G1_1_0 + 0.467724867724863*G3_0_0 + 0.425396825396823*G3_1_0;
    A[1142] = 0.042328042328042*G1_1_1 + 0.042328042328042*G3_1_1;
    A[1143] = 0.101587301587291*G1_0_0 + 0.46560846560845*G1_0_1 + 0.465608465608462*G1_1_0 + 0.761904761904757*G1_1_1 + 0.101587301587291*G3_0_0 + 0.46560846560845*G3_0_1 + 0.465608465608462*G3_1_0 + 0.761904761904757*G3_1_1;
    A[1144] = 0.0507936507936503*G1_0_0 + 0.196825396825396*G1_0_1 + 0.196825396825396*G1_1_0 + 0.393650793650791*G1_1_1 + 0.0507936507936503*G3_0_0 + 0.196825396825396*G3_0_1 + 0.196825396825396*G3_1_0 + 0.393650793650791*G3_1_1;
    A[1145] = -0.0423280423280442*G1_0_1 - 0.0423280423280413*G1_1_0 - 0.152380952380951*G1_1_1 - 0.0423280423280442*G3_0_1 - 0.0423280423280413*G3_1_0 - 0.152380952380951*G3_1_1;
    A[1146] = 0.101587301587306*G1_0_0 - 0.364021164021165*G1_0_1 - 0.364021164021163*G1_1_0 - 0.0677248677248648*G1_1_1 + 0.101587301587306*G3_0_0 - 0.364021164021165*G3_0_1 - 0.364021164021163*G3_1_0 - 0.0677248677248648*G3_1_1;
    A[1147] = 0.0507936507936486*G1_0_0 - 0.146031746031746*G1_0_1 - 0.146031746031748*G1_1_0 + 0.0507936507936495*G1_1_1 + 0.0507936507936486*G3_0_0 - 0.146031746031746*G3_0_1 - 0.146031746031748*G3_1_0 + 0.0507936507936495*G3_1_1;
    A[1148] = 0.042328042328043*G1_0_1 + 0.0423280423280411*G1_1_0 - 0.0677248677248686*G1_1_1 + 0.042328042328043*G3_0_1 + 0.0423280423280411*G3_1_0 - 0.0677248677248686*G3_1_1;
    A[1149] = -1.94708994708995*G1_0_0 - 1.48148148148147*G1_0_1 - 0.364021164021159*G1_1_0 - 0.660317460317453*G1_1_1 - 1.94708994708995*G3_0_0 - 1.48148148148147*G3_0_1 - 0.364021164021159*G3_1_0 - 0.660317460317453*G3_1_1;
    A[1150] = 2.95873015873015*G1_0_0 + 1.47936507936507*G1_0_1 + 1.47936507936507*G1_1_0 + 2.45079365079365*G1_1_1 + 2.95873015873015*G3_0_0 + 1.47936507936507*G3_0_1 + 1.47936507936507*G3_1_0 + 2.45079365079365*G3_1_1;
    A[1151] = -1.94708994708994*G1_0_0 - 0.465608465608452*G1_0_1 - 1.58306878306878*G1_1_0 - 0.761904761904758*G1_1_1 - 1.94708994708994*G3_0_0 - 0.465608465608452*G3_0_1 - 1.58306878306878*G3_1_0 - 0.761904761904758*G3_1_1;
    A[1152] = -0.101587301587311*G1_0_0 + 1.57460317460317*G1_0_1 + 1.57460317460317*G1_1_0 + 0.406349206349191*G1_1_1 - 0.101587301587311*G3_0_0 + 1.57460317460317*G3_0_1 + 1.57460317460317*G3_1_0 + 0.406349206349191*G3_1_1;
    A[1153] = -0.101587301587286*G1_0_0 - 1.67619047619046*G1_0_1 - 1.67619047619047*G1_1_0 - 2.84444444444444*G1_1_1 - 0.101587301587286*G3_0_0 - 1.67619047619046*G3_0_1 - 1.67619047619047*G3_1_0 - 2.84444444444444*G3_1_1;
    A[1154] = -0.101587301587299*G1_0_0 - 0.0507936507936499*G1_0_1 - 0.0507936507936479*G1_1_0 + 0.406349206349213*G1_1_1 - 0.101587301587299*G3_0_0 - 0.0507936507936499*G3_0_1 - 0.0507936507936479*G3_1_0 + 0.406349206349213*G3_1_1;
    A[1155] = -0.0326278659611994*G5_0 - 0.00194003527336865*G5_1;
    A[1156] = 0.032627865961199*G5_0 + 0.0306878306878307*G5_1;
    A[1157] = 0.00511463844797181*G5_1;
    A[1158] = 0.0592592592592578*G5_0 + 0.0902998236331564*G5_1;
    A[1159] = 0.0105820105820109*G5_0 + 0.0211640211640212*G5_1;
    A[1160] = -0.00282186948853648*G5_0 - 0.0169312169312169*G5_1;
    A[1161] = -0.0592592592592599*G5_0 + 0.0310405643738976*G5_1;
    A[1162] = -0.0105820105820103*G5_0 + 0.0105820105820107*G5_1;
    A[1163] = 0.00282186948853594*G5_0 - 0.0141093474426807*G5_1;
    A[1164] = 0.0733686067019392*G5_0 + 0.0507936507936506*G5_1;
    A[1165] = -0.165079365079365*G5_1;
    A[1166] = -0.0733686067019411*G5_0 - 0.0225749559082896*G5_1;
    A[1167] = 0.135449735449736*G5_0 - 0.0507936507936507*G5_1;
    A[1168] = -0.135449735449736*G5_0 - 0.186243386243387*G5_1;
    A[1169] = 0.0846560846560849*G5_1;
    A[1170] = 0.0;
    A[1171] = 0.0;
    A[1172] = 0.0;
    A[1173] = 0.0;
    A[1174] = 0.0;
    A[1175] = 0.0;
    A[1176] = 0.0;
    A[1177] = 0.0;
    A[1178] = 0.0;
    A[1179] = 0.0;
    A[1180] = 0.0;
    A[1181] = 0.0;
    A[1182] = 0.0;
    A[1183] = 0.0;
    A[1184] = 0.0;
    A[1185] = -0.245502645502646*G1_0_0 - 0.245502645502644*G1_0_1 - 0.042328042328042*G1_1_0 - 0.0423280423280388*G1_1_1 - 0.245502645502646*G3_0_0 - 0.245502645502644*G3_0_1 - 0.042328042328042*G3_1_0 - 0.0423280423280388*G3_1_1;
    A[1186] = -0.651851851851847*G1_0_0 - 0.778835978835975*G1_1_0 - 0.651851851851847*G3_0_0 - 0.778835978835975*G3_1_0;
    A[1187] = 0.0423280423280423*G1_1_1 + 0.0423280423280423*G3_1_1;
    A[1188] = -0.135449735449728*G1_0_0 - 1.04973544973544*G1_0_1 - 1.04973544973544*G1_1_0 - 2.09947089947089*G1_1_1 - 0.135449735449728*G3_0_0 - 1.04973544973544*G3_0_1 - 1.04973544973544*G3_1_0 - 2.09947089947089*G3_1_1;
    A[1189] = -0.0677248677248689*G1_0_0 + 0.296296296296294*G1_0_1 + 0.296296296296295*G1_1_0 + 0.761904761904762*G1_1_1 - 0.0677248677248689*G3_0_0 + 0.296296296296294*G3_0_1 + 0.296296296296295*G3_1_0 + 0.761904761904762*G3_1_1;
    A[1190] = -0.1015873015873*G1_0_1 - 0.101587301587298*G1_1_0 - 0.338624338624333*G1_1_1 - 0.1015873015873*G3_0_1 - 0.101587301587298*G3_1_0 - 0.338624338624333*G3_1_1;
    A[1191] = -0.135449735449736*G1_0_0 + 0.101587301587299*G1_0_1 + 0.1015873015873*G1_1_0 - 0.135449735449736*G3_0_0 + 0.101587301587299*G3_0_1 + 0.1015873015873*G3_1_0;
    A[1192] = -0.067724867724867*G1_0_0 + 0.0423280423280429*G1_0_1 + 0.0423280423280398*G1_1_0 - 0.067724867724867*G3_0_0 + 0.0423280423280429*G3_0_1 + 0.0423280423280398*G3_1_0;
    A[1193] = 0.1015873015873*G1_0_1 + 0.101587301587298*G1_1_0 + 0.1015873015873*G3_0_1 + 0.101587301587298*G3_1_0;
    A[1194] = 1.01587301587301*G1_0_0 + 0.778835978835975*G1_0_1 + 0.23703703703703*G1_1_0 + 0.338624338624337*G1_1_1 + 1.01587301587301*G3_0_0 + 0.778835978835975*G3_0_1 + 0.23703703703703*G3_1_0 + 0.338624338624337*G3_1_1;
    A[1195] = -1.94708994708994*G1_0_0 - 1.58306878306878*G1_0_1 - 0.465608465608452*G1_1_0 - 0.761904761904758*G1_1_1 - 1.94708994708994*G3_0_0 - 1.58306878306878*G3_0_1 - 0.465608465608452*G3_1_0 - 0.761904761904758*G3_1_1;
    A[1196] = 1.82857142857142*G1_0_0 + 1.04973544973544*G1_0_1 + 1.04973544973544*G1_1_0 + 2.09947089947088*G1_1_1 + 1.82857142857142*G3_0_0 + 1.04973544973544*G3_0_1 + 1.04973544973544*G3_1_0 + 2.09947089947088*G3_1_1;
    A[1197] = 0.135449735449739*G1_0_0 - 0.338624338624332*G1_0_1 - 0.338624338624343*G1_1_0 + 0.135449735449739*G3_0_0 - 0.338624338624332*G3_0_1 - 0.338624338624343*G3_1_0;
    A[1198] = 0.135449735449726*G1_0_0 + 1.28677248677248*G1_0_1 + 1.28677248677249*G1_1_0 + 0.135449735449726*G3_0_0 + 1.28677248677248*G3_0_1 + 1.28677248677249*G3_1_0;
    A[1199] = 0.135449735449736*G1_0_0 - 0.338624338624339*G1_0_1 - 0.338624338624335*G1_1_0 + 1.03007880003503e-14*G1_1_1 + 0.135449735449736*G3_0_0 - 0.338624338624339*G3_0_1 - 0.338624338624335*G3_1_0 + 1.03007880003503e-14*G3_1_1;
    A[1200] = 0.017636684303351*G5_0 + 0.00776014109347439*G5_1;
    A[1201] = -0.0458553791887123*G5_0 - 0.0522045855379187*G5_1;
    A[1202] = 0.00776014109347442*G5_1;
    A[1203] = -0.0790123456790113*G5_0 - 0.158024691358024*G5_1;
    A[1204] = 0.0310405643738973*G5_0 + 0.0902998236331565*G5_1;
    A[1205] = -0.0112874779541444*G5_0 - 0.045149911816578*G5_1;
    A[1206] = 0.0338624338624341*G5_0 - 0.0112874779541443*G5_1;
    A[1207] = 0.0141093474426807*G5_0 - 0.00282186948853616*G5_1;
    A[1208] = 0.0112874779541447*G5_0 - 0.0112874779541442*G5_1;
    A[1209] = -0.0451499118165782*G5_0 - 0.0451499118165782*G5_1;
    A[1210] = 0.0733686067019394*G5_0 + 0.0902998236331566*G5_1;
    A[1211] = -0.158024691358024*G5_1;
    A[1212] = -0.0451499118165789*G5_0 + 0.0225749559082898*G5_1;
    A[1213] = 0.0902998236331575*G5_0 - 0.112874779541445*G5_1;
    A[1214] = -0.0451499118165785*G5_0 + 0.0225749559082902*G5_1;
    A[1215] = 0.0;
    A[1216] = 0.0;
    A[1217] = 0.0;
    A[1218] = 0.0;
    A[1219] = 0.0;
    A[1220] = 0.0;
    A[1221] = 0.0;
    A[1222] = 0.0;
    A[1223] = 0.0;
    A[1224] = 0.0;
    A[1225] = 0.0;
    A[1226] = 0.0;
    A[1227] = 0.0;
    A[1228] = 0.0;
    A[1229] = 0.0;
    A[1230] = -0.0846560846560898*G1_0_0 - 0.0846560846560897*G1_0_1 - 0.0846560846560887*G1_1_0 - 0.0846560846560862*G1_1_1 - 0.0846560846560898*G3_0_0 - 0.0846560846560897*G3_0_1 - 0.0846560846560887*G3_1_0 - 0.0846560846560862*G3_1_1;
    A[1231] = -0.0846560846560837*G1_0_0 - 0.0846560846560837*G3_0_0;
    A[1232] = -0.0846560846560822*G1_1_1 - 0.0846560846560822*G3_1_1;
    A[1233] = 0.812698412698406*G1_0_0 + 0.338624338624346*G1_0_1 + 0.338624338624332*G1_1_0 + 0.812698412698406*G3_0_0 + 0.338624338624346*G3_0_1 + 0.338624338624332*G3_1_0;
    A[1234] = 0.406349206349193*G1_0_0 + 0.457142857142832*G1_0_1 + 0.457142857142842*G1_1_0 + 0.406349206349181*G1_1_1 + 0.406349206349193*G3_0_0 + 0.457142857142832*G3_0_1 + 0.457142857142842*G3_1_0 + 0.406349206349181*G3_1_1;
    A[1235] = 0.338624338624343*G1_0_1 + 0.338624338624346*G1_1_0 + 0.812698412698421*G1_1_1 + 0.338624338624343*G3_0_1 + 0.338624338624346*G3_1_0 + 0.812698412698421*G3_1_1;
    A[1236] = -2.43809523809524*G1_0_0 - 1.15132275132275*G1_0_1 - 1.15132275132275*G1_1_0 + 0.135449735449735*G1_1_1 - 2.43809523809524*G3_0_0 - 1.15132275132275*G3_0_1 - 1.15132275132275*G3_1_0 + 0.135449735449735*G3_1_1;
    A[1237] = 0.406349206349198*G1_0_0 + 1.57460317460318*G1_0_1 + 1.57460317460317*G1_1_0 - 0.101587301587297*G1_1_1 + 0.406349206349198*G3_0_0 + 1.57460317460318*G3_0_1 + 1.57460317460317*G3_1_0 - 0.101587301587297*G3_1_1;
    A[1238] = -0.338624338624339*G1_0_1 - 0.338624338624346*G1_1_0 + 0.135449735449733*G1_1_1 - 0.338624338624339*G3_0_1 - 0.338624338624346*G3_1_0 + 0.135449735449733*G3_1_1;
    A[1239] = 0.135449735449746*G1_0_0 - 1.15132275132275*G1_0_1 - 1.15132275132274*G1_1_0 - 2.43809523809523*G1_1_1 + 0.135449735449746*G3_0_0 - 1.15132275132275*G3_0_1 - 1.15132275132274*G3_1_0 - 2.43809523809523*G3_1_1;
    A[1240] = -0.101587301587311*G1_0_0 + 1.57460317460317*G1_0_1 + 1.57460317460317*G1_1_0 + 0.406349206349191*G1_1_1 - 0.101587301587311*G3_0_0 + 1.57460317460317*G3_0_1 + 1.57460317460317*G3_1_0 + 0.406349206349191*G3_1_1;
    A[1241] = 0.135449735449739*G1_0_0 - 0.338624338624343*G1_0_1 - 0.338624338624332*G1_1_0 + 0.135449735449739*G3_0_0 - 0.338624338624343*G3_0_1 - 0.338624338624332*G3_1_0;
    A[1242] = 5.6888888888889*G1_0_0 + 2.84444444444443*G1_0_1 + 2.84444444444443*G1_1_0 + 5.68888888888888*G1_1_1 + 5.6888888888889*G3_0_0 + 2.84444444444443*G3_0_1 + 2.84444444444443*G3_1_0 + 5.68888888888888*G3_1_1;
    A[1243] = -4.06349206349206*G1_0_0 - 2.03174603174601*G1_0_1 - 2.03174603174601*G1_1_0 - 0.812698412698374*G1_1_1 - 4.06349206349206*G3_0_0 - 2.03174603174601*G3_0_1 - 2.03174603174601*G3_1_0 - 0.812698412698374*G3_1_1;
    A[1244] = -0.81269841269839*G1_0_0 - 2.03174603174602*G1_0_1 - 2.03174603174601*G1_1_0 - 4.06349206349207*G1_1_1 - 0.81269841269839*G3_0_0 - 2.03174603174602*G3_0_1 - 2.03174603174601*G3_1_0 - 4.06349206349207*G3_1_1;
    A[1245] = 0.00705467372134048*G5_0 + 0.00705467372134031*G5_1;
    A[1246] = -0.00705467372134023*G5_0;
    A[1247] = -0.00705467372134029*G5_1;
    A[1248] = 0.0677248677248674*G5_0 + 0.0225749559082885*G5_1;
    A[1249] = 0.0846560846560831*G5_0 + 0.0846560846560833*G5_1;
    A[1250] = 0.0225749559082894*G5_0 + 0.0677248677248681*G5_1;
    A[1251] = 0.203174603174604*G5_0 + 0.0902998236331568*G5_1;
    A[1252] = 0.0507936507936513*G5_0 - 0.135449735449735*G5_1;
    A[1253] = -0.0225749559082885*G5_0 + 0.0451499118165791*G5_1;
    A[1254] = 0.0902998236331573*G5_0 + 0.203174603174603*G5_1;
    A[1255] = -0.135449735449736*G5_0 + 0.0507936507936519*G5_1;
    A[1256] = 0.0451499118165791*G5_0 - 0.022574955908289*G5_1;
    A[1257] = 0.0;
    A[1258] = -0.270899470899473*G5_0 - 0.135449735449737*G5_1;
    A[1259] = -0.135449735449736*G5_0 - 0.270899470899471*G5_1;
    A[1260] = 0.0;
    A[1261] = 0.0;
    A[1262] = 0.0;
    A[1263] = 0.0;
    A[1264] = 0.0;
    A[1265] = 0.0;
    A[1266] = 0.0;
    A[1267] = 0.0;
    A[1268] = 0.0;
    A[1269] = 0.0;
    A[1270] = 0.0;
    A[1271] = 0.0;
    A[1272] = 0.0;
    A[1273] = 0.0;
    A[1274] = 0.0;
    A[1275] = -0.0846560846560792*G1_0_0 - 0.0846560846560777*G1_0_1 - 0.0846560846560804*G1_1_0 - 0.0846560846560814*G1_1_1 - 0.0846560846560792*G3_0_0 - 0.0846560846560777*G3_0_1 - 0.0846560846560804*G3_1_0 - 0.0846560846560814*G3_1_1;
    A[1276] = -0.0846560846560839*G1_0_0 - 0.0846560846560839*G3_0_0;
    A[1277] = -0.0846560846560844*G1_1_1 - 0.0846560846560844*G3_1_1;
    A[1278] = -2.43809523809523*G1_0_0 - 1.28677248677249*G1_0_1 - 1.28677248677248*G1_1_0 - 2.43809523809523*G3_0_0 - 1.28677248677249*G3_0_1 - 1.28677248677248*G3_1_0;
    A[1279] = 0.406349206349211*G1_0_0 - 1.16825396825395*G1_0_1 - 1.16825396825397*G1_1_0 - 2.84444444444444*G1_1_1 + 0.406349206349211*G3_0_0 - 1.16825396825395*G3_0_1 - 1.16825396825397*G3_1_0 - 2.84444444444444*G3_1_1;
    A[1280] = 0.338624338624337*G1_0_1 + 0.338624338624336*G1_1_0 + 0.812698412698409*G1_1_1 + 0.338624338624337*G3_0_1 + 0.338624338624336*G3_1_0 + 0.812698412698409*G3_1_1;
    A[1281] = 0.812698412698416*G1_0_0 + 0.474074074074065*G1_0_1 + 0.474074074074066*G1_1_0 + 0.135449735449731*G1_1_1 + 0.812698412698416*G3_0_0 + 0.474074074074065*G3_0_1 + 0.474074074074066*G3_1_0 + 0.135449735449731*G3_1_1;
    A[1282] = 0.40634920634921*G1_0_0 - 0.0507936507936509*G1_0_1 - 0.0507936507936399*G1_1_0 - 0.1015873015873*G1_1_1 + 0.40634920634921*G3_0_0 - 0.0507936507936509*G3_0_1 - 0.0507936507936399*G3_1_0 - 0.1015873015873*G3_1_1;
    A[1283] = -0.338624338624339*G1_0_1 - 0.338624338624335*G1_1_0 + 0.135449735449735*G1_1_1 - 0.338624338624339*G3_0_1 - 0.338624338624335*G3_1_0 + 0.135449735449735*G3_1_1;
    A[1284] = 0.135449735449723*G1_0_0 + 0.474074074074072*G1_0_1 + 0.474074074074063*G1_1_0 + 0.8126984126984*G1_1_1 + 0.135449735449723*G3_0_0 + 0.474074074074072*G3_0_1 + 0.474074074074063*G3_1_0 + 0.8126984126984*G3_1_1;
    A[1285] = -0.101587301587286*G1_0_0 - 1.67619047619047*G1_0_1 - 1.67619047619046*G1_1_0 - 2.84444444444444*G1_1_1 - 0.101587301587286*G3_0_0 - 1.67619047619047*G3_0_1 - 1.67619047619046*G3_1_0 - 2.84444444444444*G3_1_1;
    A[1286] = 0.135449735449726*G1_0_0 + 1.28677248677249*G1_0_1 + 1.28677248677248*G1_1_0 + 0.135449735449726*G3_0_0 + 1.28677248677249*G3_0_1 + 1.28677248677248*G3_1_0;
    A[1287] = -4.06349206349206*G1_0_0 - 2.03174603174601*G1_0_1 - 2.03174603174601*G1_1_0 - 0.812698412698374*G1_1_1 - 4.06349206349206*G3_0_0 - 2.03174603174601*G3_0_1 - 2.03174603174601*G3_1_0 - 0.812698412698374*G3_1_1;
    A[1288] = 5.68888888888887*G1_0_0 + 2.84444444444442*G1_0_1 + 2.84444444444442*G1_1_0 + 5.68888888888887*G1_1_1 + 5.68888888888887*G3_0_0 + 2.84444444444442*G3_0_1 + 2.84444444444442*G3_1_0 + 5.68888888888887*G3_1_1;
    A[1289] = -0.812698412698421*G1_0_0 + 1.21904761904761*G1_0_1 + 1.2190476190476*G1_1_0 - 0.812698412698432*G1_1_1 - 0.812698412698421*G3_0_0 + 1.21904761904761*G3_0_1 + 1.2190476190476*G3_1_0 - 0.812698412698432*G3_1_1;
    A[1290] = 0.00705467372134022*G5_0 + 0.00705467372134047*G5_1;
    A[1291] = -0.00705467372134051*G5_0;
    A[1292] = -0.00705467372134041*G5_1;
    A[1293] = -0.203174603174603*G5_0 - 0.112874779541446*G5_1;
    A[1294] = -0.05079365079365*G5_0 - 0.186243386243386*G5_1;
    A[1295] = 0.0225749559082889*G5_0 + 0.0677248677248674*G5_1;
    A[1296] = -0.0677248677248684*G5_0 - 0.0451499118165785*G5_1;
    A[1297] = -0.0846560846560846*G5_0;
    A[1298] = -0.0225749559082897*G5_0 + 0.045149911816578*G5_1;
    A[1299] = -0.0451499118165791*G5_0 - 0.0677248677248674*G5_1;
    A[1300] = 0.135449735449736*G5_0 + 0.186243386243386*G5_1;
    A[1301] = -0.0902998236331573*G5_0 + 0.112874779541446*G5_1;
    A[1302] = 0.270899470899469*G5_0 + 0.135449735449734*G5_1;
    A[1303] = 0.0;
    A[1304] = 0.135449735449735*G5_0 - 0.135449735449737*G5_1;
    A[1305] = 0.0;
    A[1306] = 0.0;
    A[1307] = 0.0;
    A[1308] = 0.0;
    A[1309] = 0.0;
    A[1310] = 0.0;
    A[1311] = 0.0;
    A[1312] = 0.0;
    A[1313] = 0.0;
    A[1314] = 0.0;
    A[1315] = 0.0;
    A[1316] = 0.0;
    A[1317] = 0.0;
    A[1318] = 0.0;
    A[1319] = 0.0;
    A[1320] = -0.0846560846560814*G1_0_0 - 0.0846560846560843*G1_0_1 - 0.084656084656081*G1_1_0 - 0.0846560846560819*G1_1_1 - 0.0846560846560814*G3_0_0 - 0.0846560846560843*G3_0_1 - 0.084656084656081*G3_1_0 - 0.0846560846560819*G3_1_1;
    A[1321] = -0.0846560846560846*G1_0_0 - 0.0846560846560846*G3_0_0;
    A[1322] = -0.0846560846560861*G1_1_1 - 0.0846560846560861*G3_1_1;
    A[1323] = 0.812698412698411*G1_0_0 + 0.338624338624331*G1_0_1 + 0.338624338624333*G1_1_0 - 1.52881179937836e-14*G1_1_1 + 0.812698412698411*G3_0_0 + 0.338624338624331*G3_0_1 + 0.338624338624333*G3_1_0 - 1.52881179937836e-14*G3_1_1;
    A[1324] = -2.84444444444443*G1_0_0 - 1.16825396825396*G1_0_1 - 1.16825396825395*G1_1_0 + 0.406349206349225*G1_1_1 - 2.84444444444443*G3_0_0 - 1.16825396825396*G3_0_1 - 1.16825396825395*G3_1_0 + 0.406349206349225*G3_1_1;
    A[1325] = -1.28677248677249*G1_0_1 - 1.2867724867725*G1_1_0 - 2.43809523809525*G1_1_1 - 1.28677248677249*G3_0_1 - 1.2867724867725*G3_1_0 - 2.43809523809525*G3_1_1;
    A[1326] = 0.8126984126984*G1_0_0 + 0.474074074074071*G1_0_1 + 0.474074074074077*G1_1_0 + 0.135449735449732*G1_1_1 + 0.8126984126984*G3_0_0 + 0.474074074074071*G3_0_1 + 0.474074074074077*G3_1_0 + 0.135449735449732*G3_1_1;
    A[1327] = -2.84444444444443*G1_0_0 - 1.67619047619047*G1_0_1 - 1.67619047619048*G1_1_0 - 0.101587301587302*G1_1_1 - 2.84444444444443*G3_0_0 - 1.67619047619047*G3_0_1 - 1.67619047619048*G3_1_0 - 0.101587301587302*G3_1_1;
    A[1328] = 1.28677248677249*G1_0_1 + 1.2867724867725*G1_1_0 + 0.135449735449737*G1_1_1 + 1.28677248677249*G3_0_1 + 1.2867724867725*G3_1_0 + 0.135449735449737*G3_1_1;
    A[1329] = 0.135449735449729*G1_0_0 + 0.474074074074067*G1_0_1 + 0.474074074074072*G1_1_0 + 0.81269841269842*G1_1_1 + 0.135449735449729*G3_0_0 + 0.474074074074067*G3_0_1 + 0.474074074074072*G3_1_0 + 0.81269841269842*G3_1_1;
    A[1330] = -0.101587301587299*G1_0_0 - 0.0507936507936479*G1_0_1 - 0.0507936507936499*G1_1_0 + 0.406349206349213*G1_1_1 - 0.101587301587299*G3_0_0 - 0.0507936507936479*G3_0_1 - 0.0507936507936499*G3_1_0 + 0.406349206349213*G3_1_1;
    A[1331] = 0.135449735449736*G1_0_0 - 0.338624338624335*G1_0_1 - 0.338624338624339*G1_1_0 + 1.03007880003503e-14*G1_1_1 + 0.135449735449736*G3_0_0 - 0.338624338624335*G3_0_1 - 0.338624338624339*G3_1_0 + 1.03007880003503e-14*G3_1_1;
    A[1332] = -0.812698412698389*G1_0_0 - 2.03174603174601*G1_0_1 - 2.03174603174602*G1_1_0 - 4.06349206349207*G1_1_1 - 0.812698412698389*G3_0_0 - 2.03174603174601*G3_0_1 - 2.03174603174602*G3_1_0 - 4.06349206349207*G3_1_1;
    A[1333] = -0.812698412698421*G1_0_0 + 1.2190476190476*G1_0_1 + 1.21904761904761*G1_1_0 - 0.812698412698432*G1_1_1 - 0.812698412698421*G3_0_0 + 1.2190476190476*G3_0_1 + 1.21904761904761*G3_1_0 - 0.812698412698432*G3_1_1;
    A[1334] = 5.68888888888887*G1_0_0 + 2.84444444444443*G1_0_1 + 2.84444444444443*G1_1_0 + 5.6888888888889*G1_1_1 + 5.68888888888887*G3_0_0 + 2.84444444444443*G3_0_1 + 2.84444444444443*G3_1_0 + 5.6888888888889*G3_1_1;
    A[1335] = 0.00705467372134046*G5_0 + 0.00705467372134032*G5_1;
    A[1336] = -0.00705467372134038*G5_0;
    A[1337] = -0.00705467372134043*G5_1;
    A[1338] = 0.0677248677248675*G5_0 + 0.0225749559082886*G5_1;
    A[1339] = -0.186243386243385*G5_0 - 0.0507936507936496*G5_1;
    A[1340] = -0.112874779541446*G5_0 - 0.203174603174604*G5_1;
    A[1341] = -0.0677248677248676*G5_0 - 0.0451499118165791*G5_1;
    A[1342] = 0.186243386243386*G5_0 + 0.135449735449736*G5_1;
    A[1343] = 0.112874779541446*G5_0 - 0.0902998236331578*G5_1;
    A[1344] = -0.0451499118165782*G5_0 - 0.0677248677248687*G5_1;
    A[1345] = -0.0846560846560848*G5_1;
    A[1346] = 0.0451499118165782*G5_0 - 0.0225749559082903*G5_1;
    A[1347] = 0.135449735449735*G5_0 + 0.270899470899469*G5_1;
    A[1348] = -0.135449735449735*G5_0 + 0.135449735449735*G5_1;
    A[1349] = 0.0;
    A[1350] = 0.0257495590828924*G6_0 + 0.0257495590828924*G6_1;
    A[1351] = 0.00511463844797179*G6_0;
    A[1352] = 0.00511463844797176*G6_1;
    A[1353] = 0.00776014109347438*G6_0 + 0.00776014109347429*G6_1;
    A[1354] = 0.00511463844797178*G6_0 + 0.00511463844797192*G6_1;
    A[1355] = 0.00776014109347446*G6_0 + 0.00776014109347438*G6_1;
    A[1356] = 0.00634920634920632*G6_0 - 0.0458553791887124*G6_1;
    A[1357] = 0.00194003527336868*G6_0 + 0.0326278659611991*G6_1;
    A[1358] = -0.00776014109347445*G6_0 - 0.0176366843033509*G6_1;
    A[1359] = -0.0458553791887127*G6_0 + 0.0063492063492062*G6_1;
    A[1360] = 0.0326278659611994*G6_0 + 0.00194003527336865*G6_1;
    A[1361] = -0.017636684303351*G6_0 - 0.00776014109347439*G6_1;
    A[1362] = -0.00705467372134048*G6_0 - 0.00705467372134031*G6_1;
    A[1363] = -0.00705467372134022*G6_0 - 0.00705467372134047*G6_1;
    A[1364] = -0.00705467372134046*G6_0 - 0.00705467372134032*G6_1;
    A[1365] = 0.0257495590828924*G7_0 + 0.0257495590828924*G7_1;
    A[1366] = 0.00511463844797179*G7_0;
    A[1367] = 0.00511463844797176*G7_1;
    A[1368] = 0.00776014109347438*G7_0 + 0.00776014109347429*G7_1;
    A[1369] = 0.00511463844797178*G7_0 + 0.00511463844797192*G7_1;
    A[1370] = 0.00776014109347446*G7_0 + 0.00776014109347438*G7_1;
    A[1371] = 0.00634920634920632*G7_0 - 0.0458553791887124*G7_1;
    A[1372] = 0.00194003527336868*G7_0 + 0.0326278659611991*G7_1;
    A[1373] = -0.00776014109347445*G7_0 - 0.0176366843033509*G7_1;
    A[1374] = -0.0458553791887127*G7_0 + 0.0063492063492062*G7_1;
    A[1375] = 0.0326278659611994*G7_0 + 0.00194003527336865*G7_1;
    A[1376] = -0.017636684303351*G7_0 - 0.00776014109347439*G7_1;
    A[1377] = -0.00705467372134048*G7_0 - 0.00705467372134031*G7_1;
    A[1378] = -0.00705467372134022*G7_0 - 0.00705467372134047*G7_1;
    A[1379] = -0.00705467372134046*G7_0 - 0.00705467372134032*G7_1;
    A[1380] = 0.0;
    A[1381] = 0.0;
    A[1382] = 0.0;
    A[1383] = 0.0;
    A[1384] = 0.0;
    A[1385] = 0.0;
    A[1386] = 0.0;
    A[1387] = 0.0;
    A[1388] = 0.0;
    A[1389] = 0.0;
    A[1390] = 0.0;
    A[1391] = 0.0;
    A[1392] = 0.0;
    A[1393] = 0.0;
    A[1394] = 0.0;
    A[1395] = -0.0051146384479718*G6_0 - 0.00511463844797173*G6_1;
    A[1396] = -0.0257495590828923*G6_0;
    A[1397] = 0.00511463844797177*G6_1;
    A[1398] = -0.00634920634920633*G6_0 - 0.0522045855379187*G6_1;
    A[1399] = -0.00194003527336863*G6_0 + 0.0306878306878306*G6_1;
    A[1400] = 0.00776014109347447*G6_0 - 0.00987654320987643*G6_1;
    A[1401] = -0.0077601410934744*G6_0;
    A[1402] = -0.00511463844797175*G6_0;
    A[1403] = -0.00776014109347447*G6_0;
    A[1404] = 0.0176366843033509*G6_0 + 0.00987654320987649*G6_1;
    A[1405] = -0.032627865961199*G6_0 - 0.0306878306878307*G6_1;
    A[1406] = 0.0458553791887123*G6_0 + 0.0522045855379187*G6_1;
    A[1407] = 0.00705467372134023*G6_0;
    A[1408] = 0.00705467372134051*G6_0;
    A[1409] = 0.00705467372134038*G6_0;
    A[1410] = -0.0051146384479718*G7_0 - 0.00511463844797173*G7_1;
    A[1411] = -0.0257495590828923*G7_0;
    A[1412] = 0.00511463844797177*G7_1;
    A[1413] = -0.00634920634920633*G7_0 - 0.0522045855379187*G7_1;
    A[1414] = -0.00194003527336863*G7_0 + 0.0306878306878306*G7_1;
    A[1415] = 0.00776014109347447*G7_0 - 0.00987654320987643*G7_1;
    A[1416] = -0.0077601410934744*G7_0;
    A[1417] = -0.00511463844797175*G7_0;
    A[1418] = -0.00776014109347447*G7_0;
    A[1419] = 0.0176366843033509*G7_0 + 0.00987654320987649*G7_1;
    A[1420] = -0.032627865961199*G7_0 - 0.0306878306878307*G7_1;
    A[1421] = 0.0458553791887123*G7_0 + 0.0522045855379187*G7_1;
    A[1422] = 0.00705467372134023*G7_0;
    A[1423] = 0.00705467372134051*G7_0;
    A[1424] = 0.00705467372134038*G7_0;
    A[1425] = 0.0;
    A[1426] = 0.0;
    A[1427] = 0.0;
    A[1428] = 0.0;
    A[1429] = 0.0;
    A[1430] = 0.0;
    A[1431] = 0.0;
    A[1432] = 0.0;
    A[1433] = 0.0;
    A[1434] = 0.0;
    A[1435] = 0.0;
    A[1436] = 0.0;
    A[1437] = 0.0;
    A[1438] = 0.0;
    A[1439] = 0.0;
    A[1440] = -0.0051146384479718*G6_0 - 0.00511463844797179*G6_1;
    A[1441] = 0.00511463844797177*G6_0;
    A[1442] = -0.0257495590828923*G6_1;
    A[1443] = -0.00987654320987657*G6_0 + 0.00776014109347437*G6_1;
    A[1444] = 0.0306878306878308*G6_0 - 0.00194003527336844*G6_1;
    A[1445] = -0.0522045855379189*G6_0 - 0.00634920634920647*G6_1;
    A[1446] = 0.00987654320987659*G6_0 + 0.017636684303351*G6_1;
    A[1447] = -0.0306878306878308*G6_0 - 0.0326278659611992*G6_1;
    A[1448] = 0.0522045855379189*G6_0 + 0.0458553791887125*G6_1;
    A[1449] = -0.00776014109347438*G6_1;
    A[1450] = -0.00511463844797181*G6_1;
    A[1451] = -0.00776014109347442*G6_1;
    A[1452] = 0.00705467372134029*G6_1;
    A[1453] = 0.00705467372134041*G6_1;
    A[1454] = 0.00705467372134043*G6_1;
    A[1455] = -0.0051146384479718*G7_0 - 0.00511463844797179*G7_1;
    A[1456] = 0.00511463844797177*G7_0;
    A[1457] = -0.0257495590828923*G7_1;
    A[1458] = -0.00987654320987657*G7_0 + 0.00776014109347437*G7_1;
    A[1459] = 0.0306878306878308*G7_0 - 0.00194003527336844*G7_1;
    A[1460] = -0.0522045855379189*G7_0 - 0.00634920634920647*G7_1;
    A[1461] = 0.00987654320987659*G7_0 + 0.017636684303351*G7_1;
    A[1462] = -0.0306878306878308*G7_0 - 0.0326278659611992*G7_1;
    A[1463] = 0.0522045855379189*G7_0 + 0.0458553791887125*G7_1;
    A[1464] = -0.00776014109347438*G7_1;
    A[1465] = -0.00511463844797181*G7_1;
    A[1466] = -0.00776014109347442*G7_1;
    A[1467] = 0.00705467372134029*G7_1;
    A[1468] = 0.00705467372134041*G7_1;
    A[1469] = 0.00705467372134043*G7_1;
    A[1470] = 0.0;
    A[1471] = 0.0;
    A[1472] = 0.0;
    A[1473] = 0.0;
    A[1474] = 0.0;
    A[1475] = 0.0;
    A[1476] = 0.0;
    A[1477] = 0.0;
    A[1478] = 0.0;
    A[1479] = 0.0;
    A[1480] = 0.0;
    A[1481] = 0.0;
    A[1482] = 0.0;
    A[1483] = 0.0;
    A[1484] = 0.0;
    A[1485] = -0.00776014109347426*G6_0 - 0.007760141093474*G6_1;
    A[1486] = -0.0458553791887123*G6_0;
    A[1487] = -0.017636684303351*G6_1;
    A[1488] = -0.158024691358024*G6_0 - 0.158024691358024*G6_1;
    A[1489] = 0.0507936507936507*G6_0 - 0.022574955908289*G6_1;
    A[1490] = -0.0451499118165785*G6_0;
    A[1491] = 0.0225749559082891*G6_0 + 0.011287477954144*G6_1;
    A[1492] = 0.0169312169312168*G6_0 + 0.00282186948853604*G6_1;
    A[1493] = 0.0451499118165785*G6_0 + 0.0112874779541441*G6_1;
    A[1494] = 0.033862433862433*G6_0 + 0.0451499118165783*G6_1;
    A[1495] = -0.0592592592592578*G6_0 - 0.0902998236331564*G6_1;
    A[1496] = 0.0790123456790113*G6_0 + 0.158024691358024*G6_1;
    A[1497] = -0.0677248677248674*G6_0 - 0.0225749559082885*G6_1;
    A[1498] = 0.203174603174603*G6_0 + 0.112874779541446*G6_1;
    A[1499] = -0.0677248677248675*G6_0 - 0.0225749559082886*G6_1;
    A[1500] = -0.00776014109347426*G7_0 - 0.007760141093474*G7_1;
    A[1501] = -0.0458553791887123*G7_0;
    A[1502] = -0.017636684303351*G7_1;
    A[1503] = -0.158024691358024*G7_0 - 0.158024691358024*G7_1;
    A[1504] = 0.0507936507936507*G7_0 - 0.022574955908289*G7_1;
    A[1505] = -0.0451499118165785*G7_0;
    A[1506] = 0.0225749559082891*G7_0 + 0.011287477954144*G7_1;
    A[1507] = 0.0169312169312168*G7_0 + 0.00282186948853604*G7_1;
    A[1508] = 0.0451499118165785*G7_0 + 0.0112874779541441*G7_1;
    A[1509] = 0.033862433862433*G7_0 + 0.0451499118165783*G7_1;
    A[1510] = -0.0592592592592578*G7_0 - 0.0902998236331564*G7_1;
    A[1511] = 0.0790123456790113*G7_0 + 0.158024691358024*G7_1;
    A[1512] = -0.0677248677248674*G7_0 - 0.0225749559082885*G7_1;
    A[1513] = 0.203174603174603*G7_0 + 0.112874779541446*G7_1;
    A[1514] = -0.0677248677248675*G7_0 - 0.0225749559082886*G7_1;
    A[1515] = 0.0;
    A[1516] = 0.0;
    A[1517] = 0.0;
    A[1518] = 0.0;
    A[1519] = 0.0;
    A[1520] = 0.0;
    A[1521] = 0.0;
    A[1522] = 0.0;
    A[1523] = 0.0;
    A[1524] = 0.0;
    A[1525] = 0.0;
    A[1526] = 0.0;
    A[1527] = 0.0;
    A[1528] = 0.0;
    A[1529] = 0.0;
    A[1530] = -0.00511463844797154*G6_0 - 0.00511463844797178*G6_1;
    A[1531] = 0.0326278659611992*G6_0;
    A[1532] = 0.0326278659611993*G6_1;
    A[1533] = 0.016931216931217*G6_0 + 0.0902998236331568*G6_1;
    A[1534] = -0.165079365079365*G6_0 - 0.165079365079365*G6_1;
    A[1535] = 0.0902998236331571*G6_0 + 0.016931216931217*G6_1;
    A[1536] = 0.0169312169312162*G6_0 + 0.0141093474426806*G6_1;
    A[1537] = -0.0211640211640207*G6_0 - 0.0105820105820104*G6_1;
    A[1538] = -0.090299823633157*G6_0 - 0.0310405643738975*G6_1;
    A[1539] = 0.0141093474426805*G6_0 + 0.0169312169312166*G6_1;
    A[1540] = -0.0105820105820109*G6_0 - 0.0211640211640212*G6_1;
    A[1541] = -0.0310405643738973*G6_0 - 0.0902998236331565*G6_1;
    A[1542] = -0.0846560846560831*G6_0 - 0.0846560846560833*G6_1;
    A[1543] = 0.05079365079365*G6_0 + 0.186243386243386*G6_1;
    A[1544] = 0.186243386243385*G6_0 + 0.0507936507936496*G6_1;
    A[1545] = -0.00511463844797154*G7_0 - 0.00511463844797178*G7_1;
    A[1546] = 0.0326278659611992*G7_0;
    A[1547] = 0.0326278659611993*G7_1;
    A[1548] = 0.016931216931217*G7_0 + 0.0902998236331568*G7_1;
    A[1549] = -0.165079365079365*G7_0 - 0.165079365079365*G7_1;
    A[1550] = 0.0902998236331571*G7_0 + 0.016931216931217*G7_1;
    A[1551] = 0.0169312169312162*G7_0 + 0.0141093474426806*G7_1;
    A[1552] = -0.0211640211640207*G7_0 - 0.0105820105820104*G7_1;
    A[1553] = -0.090299823633157*G7_0 - 0.0310405643738975*G7_1;
    A[1554] = 0.0141093474426805*G7_0 + 0.0169312169312166*G7_1;
    A[1555] = -0.0105820105820109*G7_0 - 0.0211640211640212*G7_1;
    A[1556] = -0.0310405643738973*G7_0 - 0.0902998236331565*G7_1;
    A[1557] = -0.0846560846560831*G7_0 - 0.0846560846560833*G7_1;
    A[1558] = 0.05079365079365*G7_0 + 0.186243386243386*G7_1;
    A[1559] = 0.186243386243385*G7_0 + 0.0507936507936496*G7_1;
    A[1560] = 0.0;
    A[1561] = 0.0;
    A[1562] = 0.0;
    A[1563] = 0.0;
    A[1564] = 0.0;
    A[1565] = 0.0;
    A[1566] = 0.0;
    A[1567] = 0.0;
    A[1568] = 0.0;
    A[1569] = 0.0;
    A[1570] = 0.0;
    A[1571] = 0.0;
    A[1572] = 0.0;
    A[1573] = 0.0;
    A[1574] = 0.0;
    A[1575] = -0.00776014109347442*G6_0 - 0.00776014109347428*G6_1;
    A[1576] = -0.0176366843033509*G6_0;
    A[1577] = -0.0458553791887124*G6_1;
    A[1578] = -0.0451499118165789*G6_1;
    A[1579] = -0.022574955908289*G6_0 + 0.0507936507936514*G6_1;
    A[1580] = -0.158024691358025*G6_0 - 0.158024691358025*G6_1;
    A[1581] = 0.0451499118165785*G6_0 + 0.0338624338624336*G6_1;
    A[1582] = -0.0902998236331573*G6_0 - 0.0592592592592593*G6_1;
    A[1583] = 0.158024691358025*G6_0 + 0.0790123456790117*G6_1;
    A[1584] = 0.0112874779541445*G6_0 + 0.0225749559082895*G6_1;
    A[1585] = 0.00282186948853648*G6_0 + 0.0169312169312169*G6_1;
    A[1586] = 0.0112874779541444*G6_0 + 0.045149911816578*G6_1;
    A[1587] = -0.0225749559082894*G6_0 - 0.0677248677248681*G6_1;
    A[1588] = -0.0225749559082889*G6_0 - 0.0677248677248674*G6_1;
    A[1589] = 0.112874779541446*G6_0 + 0.203174603174604*G6_1;
    A[1590] = -0.00776014109347442*G7_0 - 0.00776014109347428*G7_1;
    A[1591] = -0.0176366843033509*G7_0;
    A[1592] = -0.0458553791887124*G7_1;
    A[1593] = -0.0451499118165789*G7_1;
    A[1594] = -0.022574955908289*G7_0 + 0.0507936507936514*G7_1;
    A[1595] = -0.158024691358025*G7_0 - 0.158024691358025*G7_1;
    A[1596] = 0.0451499118165785*G7_0 + 0.0338624338624336*G7_1;
    A[1597] = -0.0902998236331573*G7_0 - 0.0592592592592593*G7_1;
    A[1598] = 0.158024691358025*G7_0 + 0.0790123456790117*G7_1;
    A[1599] = 0.0112874779541445*G7_0 + 0.0225749559082895*G7_1;
    A[1600] = 0.00282186948853648*G7_0 + 0.0169312169312169*G7_1;
    A[1601] = 0.0112874779541444*G7_0 + 0.045149911816578*G7_1;
    A[1602] = -0.0225749559082894*G7_0 - 0.0677248677248681*G7_1;
    A[1603] = -0.0225749559082889*G7_0 - 0.0677248677248674*G7_1;
    A[1604] = 0.112874779541446*G7_0 + 0.203174603174604*G7_1;
    A[1605] = 0.0;
    A[1606] = 0.0;
    A[1607] = 0.0;
    A[1608] = 0.0;
    A[1609] = 0.0;
    A[1610] = 0.0;
    A[1611] = 0.0;
    A[1612] = 0.0;
    A[1613] = 0.0;
    A[1614] = 0.0;
    A[1615] = 0.0;
    A[1616] = 0.0;
    A[1617] = 0.0;
    A[1618] = 0.0;
    A[1619] = 0.0;
    A[1620] = 0.0458553791887127*G6_0 + 0.0458553791887127*G6_1;
    A[1621] = 0.00776014109347446*G6_0;
    A[1622] = -0.017636684303351*G6_1;
    A[1623] = -0.0225749559082893*G6_0 - 0.0112874779541452*G6_1;
    A[1624] = -0.0169312169312169*G6_0 - 0.0141093474426799*G6_1;
    A[1625] = -0.0451499118165785*G6_0 - 0.0338624338624341*G6_1;
    A[1626] = 0.158024691358025*G6_0;
    A[1627] = -0.0507936507936507*G6_0 - 0.0733686067019404*G6_1;
    A[1628] = 0.0451499118165785*G6_0 + 0.0451499118165782*G6_1;
    A[1629] = -0.079012345679013*G6_0 + 0.0790123456790122*G6_1;
    A[1630] = 0.0592592592592599*G6_0 - 0.0310405643738976*G6_1;
    A[1631] = -0.0338624338624341*G6_0 + 0.0112874779541443*G6_1;
    A[1632] = -0.203174603174604*G6_0 - 0.0902998236331568*G6_1;
    A[1633] = 0.0677248677248684*G6_0 + 0.0451499118165785*G6_1;
    A[1634] = 0.0677248677248676*G6_0 + 0.0451499118165791*G6_1;
    A[1635] = 0.0458553791887127*G7_0 + 0.0458553791887127*G7_1;
    A[1636] = 0.00776014109347446*G7_0;
    A[1637] = -0.017636684303351*G7_1;
    A[1638] = -0.0225749559082893*G7_0 - 0.0112874779541452*G7_1;
    A[1639] = -0.0169312169312169*G7_0 - 0.0141093474426799*G7_1;
    A[1640] = -0.0451499118165785*G7_0 - 0.0338624338624341*G7_1;
    A[1641] = 0.158024691358025*G7_0;
    A[1642] = -0.0507936507936507*G7_0 - 0.0733686067019404*G7_1;
    A[1643] = 0.0451499118165785*G7_0 + 0.0451499118165782*G7_1;
    A[1644] = -0.079012345679013*G7_0 + 0.0790123456790122*G7_1;
    A[1645] = 0.0592592592592599*G7_0 - 0.0310405643738976*G7_1;
    A[1646] = -0.0338624338624341*G7_0 + 0.0112874779541443*G7_1;
    A[1647] = -0.203174603174604*G7_0 - 0.0902998236331568*G7_1;
    A[1648] = 0.0677248677248684*G7_0 + 0.0451499118165785*G7_1;
    A[1649] = 0.0677248677248676*G7_0 + 0.0451499118165791*G7_1;
    A[1650] = 0.0;
    A[1651] = 0.0;
    A[1652] = 0.0;
    A[1653] = 0.0;
    A[1654] = 0.0;
    A[1655] = 0.0;
    A[1656] = 0.0;
    A[1657] = 0.0;
    A[1658] = 0.0;
    A[1659] = 0.0;
    A[1660] = 0.0;
    A[1661] = 0.0;
    A[1662] = 0.0;
    A[1663] = 0.0;
    A[1664] = 0.0;
    A[1665] = -0.0326278659611995*G6_0 - 0.0326278659611993*G6_1;
    A[1666] = 0.00511463844797175*G6_0;
    A[1667] = 0.0326278659611992*G6_1;
    A[1668] = -0.0169312169312168*G6_0 - 0.00282186948853558*G6_1;
    A[1669] = 0.021164021164021*G6_0 + 0.0105820105820098*G6_1;
    A[1670] = 0.090299823633157*G6_0 + 0.0592592592592598*G6_1;
    A[1671] = -0.0169312169312165*G6_0 + 0.07336860670194*G6_1;
    A[1672] = 0.165079365079365*G6_0;
    A[1673] = -0.090299823633157*G6_0 - 0.0733686067019398*G6_1;
    A[1674] = 0.0310405643738982*G6_0 - 0.059259259259259*G6_1;
    A[1675] = 0.0105820105820103*G6_0 - 0.0105820105820107*G6_1;
    A[1676] = -0.0141093474426807*G6_0 + 0.00282186948853616*G6_1;
    A[1677] = -0.0507936507936513*G6_0 + 0.135449735449735*G6_1;
    A[1678] = 0.0846560846560846*G6_0;
    A[1679] = -0.186243386243386*G6_0 - 0.135449735449736*G6_1;
    A[1680] = -0.0326278659611995*G7_0 - 0.0326278659611993*G7_1;
    A[1681] = 0.00511463844797175*G7_0;
    A[1682] = 0.0326278659611992*G7_1;
    A[1683] = -0.0169312169312168*G7_0 - 0.00282186948853558*G7_1;
    A[1684] = 0.021164021164021*G7_0 + 0.0105820105820098*G7_1;
    A[1685] = 0.090299823633157*G7_0 + 0.0592592592592598*G7_1;
    A[1686] = -0.0169312169312165*G7_0 + 0.07336860670194*G7_1;
    A[1687] = 0.165079365079365*G7_0;
    A[1688] = -0.090299823633157*G7_0 - 0.0733686067019398*G7_1;
    A[1689] = 0.0310405643738982*G7_0 - 0.059259259259259*G7_1;
    A[1690] = 0.0105820105820103*G7_0 - 0.0105820105820107*G7_1;
    A[1691] = -0.0141093474426807*G7_0 + 0.00282186948853616*G7_1;
    A[1692] = -0.0507936507936513*G7_0 + 0.135449735449735*G7_1;
    A[1693] = 0.0846560846560846*G7_0;
    A[1694] = -0.186243386243386*G7_0 - 0.135449735449736*G7_1;
    A[1695] = 0.0;
    A[1696] = 0.0;
    A[1697] = 0.0;
    A[1698] = 0.0;
    A[1699] = 0.0;
    A[1700] = 0.0;
    A[1701] = 0.0;
    A[1702] = 0.0;
    A[1703] = 0.0;
    A[1704] = 0.0;
    A[1705] = 0.0;
    A[1706] = 0.0;
    A[1707] = 0.0;
    A[1708] = 0.0;
    A[1709] = 0.0;
    A[1710] = 0.0176366843033509*G6_0 + 0.0176366843033511*G6_1;
    A[1711] = 0.00776014109347439*G6_0;
    A[1712] = -0.0458553791887124*G6_1;
    A[1713] = -0.0451499118165786*G6_0 - 0.011287477954145*G6_1;
    A[1714] = 0.0902998236331572*G6_0 + 0.0310405643738984*G6_1;
    A[1715] = -0.158024691358025*G6_0 - 0.0790123456790126*G6_1;
    A[1716] = -0.0451499118165784*G6_1;
    A[1717] = 0.0225749559082889*G6_0 + 0.0733686067019396*G6_1;
    A[1718] = 0.158024691358025*G6_0;
    A[1719] = -0.0112874779541447*G6_0 + 0.0338624338624342*G6_1;
    A[1720] = -0.00282186948853594*G6_0 + 0.0141093474426807*G6_1;
    A[1721] = -0.0112874779541447*G6_0 + 0.0112874779541442*G6_1;
    A[1722] = 0.0225749559082885*G6_0 - 0.0451499118165791*G6_1;
    A[1723] = 0.0225749559082897*G6_0 - 0.045149911816578*G6_1;
    A[1724] = -0.112874779541446*G6_0 + 0.0902998236331578*G6_1;
    A[1725] = 0.0176366843033509*G7_0 + 0.0176366843033511*G7_1;
    A[1726] = 0.00776014109347439*G7_0;
    A[1727] = -0.0458553791887124*G7_1;
    A[1728] = -0.0451499118165786*G7_0 - 0.011287477954145*G7_1;
    A[1729] = 0.0902998236331572*G7_0 + 0.0310405643738984*G7_1;
    A[1730] = -0.158024691358025*G7_0 - 0.0790123456790126*G7_1;
    A[1731] = -0.0451499118165784*G7_1;
    A[1732] = 0.0225749559082889*G7_0 + 0.0733686067019396*G7_1;
    A[1733] = 0.158024691358025*G7_0;
    A[1734] = -0.0112874779541447*G7_0 + 0.0338624338624342*G7_1;
    A[1735] = -0.00282186948853594*G7_0 + 0.0141093474426807*G7_1;
    A[1736] = -0.0112874779541447*G7_0 + 0.0112874779541442*G7_1;
    A[1737] = 0.0225749559082885*G7_0 - 0.0451499118165791*G7_1;
    A[1738] = 0.0225749559082897*G7_0 - 0.045149911816578*G7_1;
    A[1739] = -0.112874779541446*G7_0 + 0.0902998236331578*G7_1;
    A[1740] = 0.0;
    A[1741] = 0.0;
    A[1742] = 0.0;
    A[1743] = 0.0;
    A[1744] = 0.0;
    A[1745] = 0.0;
    A[1746] = 0.0;
    A[1747] = 0.0;
    A[1748] = 0.0;
    A[1749] = 0.0;
    A[1750] = 0.0;
    A[1751] = 0.0;
    A[1752] = 0.0;
    A[1753] = 0.0;
    A[1754] = 0.0;
    A[1755] = 0.0458553791887128*G6_0 + 0.0458553791887128*G6_1;
    A[1756] = -0.0176366843033509*G6_0;
    A[1757] = 0.00776014109347434*G6_1;
    A[1758] = -0.033862433862434*G6_0 - 0.0451499118165791*G6_1;
    A[1759] = -0.0141093474426807*G6_0 - 0.0169312169312162*G6_1;
    A[1760] = -0.0112874779541446*G6_0 - 0.0225749559082893*G6_1;
    A[1761] = 0.0790123456790122*G6_0 - 0.0790123456790125*G6_1;
    A[1762] = -0.0310405643738975*G6_0 + 0.0592592592592587*G6_1;
    A[1763] = 0.0112874779541446*G6_0 - 0.033862433862434*G6_1;
    A[1764] = 0.158024691358025*G6_1;
    A[1765] = -0.0733686067019392*G6_0 - 0.0507936507936506*G6_1;
    A[1766] = 0.0451499118165782*G6_0 + 0.0451499118165782*G6_1;
    A[1767] = -0.0902998236331573*G6_0 - 0.203174603174603*G6_1;
    A[1768] = 0.0451499118165791*G6_0 + 0.0677248677248674*G6_1;
    A[1769] = 0.0451499118165782*G6_0 + 0.0677248677248687*G6_1;
    A[1770] = 0.0458553791887128*G7_0 + 0.0458553791887128*G7_1;
    A[1771] = -0.0176366843033509*G7_0;
    A[1772] = 0.00776014109347434*G7_1;
    A[1773] = -0.033862433862434*G7_0 - 0.0451499118165791*G7_1;
    A[1774] = -0.0141093474426807*G7_0 - 0.0169312169312162*G7_1;
    A[1775] = -0.0112874779541446*G7_0 - 0.0225749559082893*G7_1;
    A[1776] = 0.0790123456790122*G7_0 - 0.0790123456790125*G7_1;
    A[1777] = -0.0310405643738975*G7_0 + 0.0592592592592587*G7_1;
    A[1778] = 0.0112874779541446*G7_0 - 0.033862433862434*G7_1;
    A[1779] = 0.158024691358025*G7_1;
    A[1780] = -0.0733686067019392*G7_0 - 0.0507936507936506*G7_1;
    A[1781] = 0.0451499118165782*G7_0 + 0.0451499118165782*G7_1;
    A[1782] = -0.0902998236331573*G7_0 - 0.203174603174603*G7_1;
    A[1783] = 0.0451499118165791*G7_0 + 0.0677248677248674*G7_1;
    A[1784] = 0.0451499118165782*G7_0 + 0.0677248677248687*G7_1;
    A[1785] = 0.0;
    A[1786] = 0.0;
    A[1787] = 0.0;
    A[1788] = 0.0;
    A[1789] = 0.0;
    A[1790] = 0.0;
    A[1791] = 0.0;
    A[1792] = 0.0;
    A[1793] = 0.0;
    A[1794] = 0.0;
    A[1795] = 0.0;
    A[1796] = 0.0;
    A[1797] = 0.0;
    A[1798] = 0.0;
    A[1799] = 0.0;
    A[1800] = -0.0326278659611995*G6_0 - 0.0326278659611996*G6_1;
    A[1801] = 0.0326278659611991*G6_0;
    A[1802] = 0.00511463844797176*G6_1;
    A[1803] = 0.0592592592592591*G6_0 + 0.0902998236331569*G6_1;
    A[1804] = 0.0105820105820106*G6_0 + 0.0211640211640208*G6_1;
    A[1805] = -0.00282186948853619*G6_0 - 0.016931216931217*G6_1;
    A[1806] = -0.0592592592592591*G6_0 + 0.0310405643738981*G6_1;
    A[1807] = -0.0105820105820106*G6_0 + 0.0105820105820106*G6_1;
    A[1808] = 0.00282186948853618*G6_0 - 0.0141093474426807*G6_1;
    A[1809] = 0.0733686067019408*G6_0 - 0.0169312169312163*G6_1;
    A[1810] = 0.165079365079365*G6_1;
    A[1811] = -0.0733686067019394*G6_0 - 0.0902998236331566*G6_1;
    A[1812] = 0.135449735449736*G6_0 - 0.0507936507936519*G6_1;
    A[1813] = -0.135449735449736*G6_0 - 0.186243386243386*G6_1;
    A[1814] = 0.0846560846560848*G6_1;
    A[1815] = -0.0326278659611995*G7_0 - 0.0326278659611996*G7_1;
    A[1816] = 0.0326278659611991*G7_0;
    A[1817] = 0.00511463844797176*G7_1;
    A[1818] = 0.0592592592592591*G7_0 + 0.0902998236331569*G7_1;
    A[1819] = 0.0105820105820106*G7_0 + 0.0211640211640208*G7_1;
    A[1820] = -0.00282186948853619*G7_0 - 0.016931216931217*G7_1;
    A[1821] = -0.0592592592592591*G7_0 + 0.0310405643738981*G7_1;
    A[1822] = -0.0105820105820106*G7_0 + 0.0105820105820106*G7_1;
    A[1823] = 0.00282186948853618*G7_0 - 0.0141093474426807*G7_1;
    A[1824] = 0.0733686067019408*G7_0 - 0.0169312169312163*G7_1;
    A[1825] = 0.165079365079365*G7_1;
    A[1826] = -0.0733686067019394*G7_0 - 0.0902998236331566*G7_1;
    A[1827] = 0.135449735449736*G7_0 - 0.0507936507936519*G7_1;
    A[1828] = -0.135449735449736*G7_0 - 0.186243386243386*G7_1;
    A[1829] = 0.0846560846560848*G7_1;
    A[1830] = 0.0;
    A[1831] = 0.0;
    A[1832] = 0.0;
    A[1833] = 0.0;
    A[1834] = 0.0;
    A[1835] = 0.0;
    A[1836] = 0.0;
    A[1837] = 0.0;
    A[1838] = 0.0;
    A[1839] = 0.0;
    A[1840] = 0.0;
    A[1841] = 0.0;
    A[1842] = 0.0;
    A[1843] = 0.0;
    A[1844] = 0.0;
    A[1845] = 0.017636684303351*G6_0 + 0.0176366843033513*G6_1;
    A[1846] = -0.0458553791887123*G6_0;
    A[1847] = 0.00776014109347433*G6_1;
    A[1848] = -0.0790123456790122*G6_0 - 0.158024691358025*G6_1;
    A[1849] = 0.0310405643738975*G6_0 + 0.0902998236331571*G6_1;
    A[1850] = -0.0112874779541446*G6_0 - 0.0451499118165783*G6_1;
    A[1851] = 0.033862433862434*G6_0 - 0.0112874779541449*G6_1;
    A[1852] = 0.0141093474426807*G6_0 - 0.00282186948853644*G6_1;
    A[1853] = 0.0112874779541446*G6_0 - 0.0112874779541451*G6_1;
    A[1854] = -0.045149911816579*G6_0;
    A[1855] = 0.0733686067019411*G6_0 + 0.0225749559082896*G6_1;
    A[1856] = 0.158024691358024*G6_1;
    A[1857] = -0.0451499118165791*G6_0 + 0.022574955908289*G6_1;
    A[1858] = 0.0902998236331573*G6_0 - 0.112874779541446*G6_1;
    A[1859] = -0.0451499118165782*G6_0 + 0.0225749559082903*G6_1;
    A[1860] = 0.017636684303351*G7_0 + 0.0176366843033513*G7_1;
    A[1861] = -0.0458553791887123*G7_0;
    A[1862] = 0.00776014109347433*G7_1;
    A[1863] = -0.0790123456790122*G7_0 - 0.158024691358025*G7_1;
    A[1864] = 0.0310405643738975*G7_0 + 0.0902998236331571*G7_1;
    A[1865] = -0.0112874779541446*G7_0 - 0.0451499118165783*G7_1;
    A[1866] = 0.033862433862434*G7_0 - 0.0112874779541449*G7_1;
    A[1867] = 0.0141093474426807*G7_0 - 0.00282186948853644*G7_1;
    A[1868] = 0.0112874779541446*G7_0 - 0.0112874779541451*G7_1;
    A[1869] = -0.045149911816579*G7_0;
    A[1870] = 0.0733686067019411*G7_0 + 0.0225749559082896*G7_1;
    A[1871] = 0.158024691358024*G7_1;
    A[1872] = -0.0451499118165791*G7_0 + 0.022574955908289*G7_1;
    A[1873] = 0.0902998236331573*G7_0 - 0.112874779541446*G7_1;
    A[1874] = -0.0451499118165782*G7_0 + 0.0225749559082903*G7_1;
    A[1875] = 0.0;
    A[1876] = 0.0;
    A[1877] = 0.0;
    A[1878] = 0.0;
    A[1879] = 0.0;
    A[1880] = 0.0;
    A[1881] = 0.0;
    A[1882] = 0.0;
    A[1883] = 0.0;
    A[1884] = 0.0;
    A[1885] = 0.0;
    A[1886] = 0.0;
    A[1887] = 0.0;
    A[1888] = 0.0;
    A[1889] = 0.0;
    A[1890] = 0.00705467372134038*G6_0 + 0.00705467372134042*G6_1;
    A[1891] = -0.00705467372134055*G6_0;
    A[1892] = -0.00705467372134057*G6_1;
    A[1893] = 0.0677248677248676*G6_0 + 0.0225749559082888*G6_1;
    A[1894] = 0.0846560846560842*G6_0 + 0.0846560846560849*G6_1;
    A[1895] = 0.0225749559082894*G6_0 + 0.067724867724868*G6_1;
    A[1896] = 0.203174603174604*G6_0 + 0.0902998236331575*G6_1;
    A[1897] = 0.0507936507936505*G6_0 - 0.135449735449736*G6_1;
    A[1898] = -0.0225749559082894*G6_0 + 0.0451499118165781*G6_1;
    A[1899] = 0.0902998236331568*G6_0 + 0.203174603174604*G6_1;
    A[1900] = -0.135449735449736*G6_0 + 0.0507936507936507*G6_1;
    A[1901] = 0.0451499118165789*G6_0 - 0.0225749559082898*G6_1;
    A[1902] = 0.0;
    A[1903] = -0.270899470899469*G6_0 - 0.135449735449734*G6_1;
    A[1904] = -0.135449735449735*G6_0 - 0.270899470899469*G6_1;
    A[1905] = 0.00705467372134038*G7_0 + 0.00705467372134042*G7_1;
    A[1906] = -0.00705467372134055*G7_0;
    A[1907] = -0.00705467372134057*G7_1;
    A[1908] = 0.0677248677248676*G7_0 + 0.0225749559082888*G7_1;
    A[1909] = 0.0846560846560842*G7_0 + 0.0846560846560849*G7_1;
    A[1910] = 0.0225749559082894*G7_0 + 0.067724867724868*G7_1;
    A[1911] = 0.203174603174604*G7_0 + 0.0902998236331575*G7_1;
    A[1912] = 0.0507936507936505*G7_0 - 0.135449735449736*G7_1;
    A[1913] = -0.0225749559082894*G7_0 + 0.0451499118165781*G7_1;
    A[1914] = 0.0902998236331568*G7_0 + 0.203174603174604*G7_1;
    A[1915] = -0.135449735449736*G7_0 + 0.0507936507936507*G7_1;
    A[1916] = 0.0451499118165789*G7_0 - 0.0225749559082898*G7_1;
    A[1917] = 0.0;
    A[1918] = -0.270899470899469*G7_0 - 0.135449735449734*G7_1;
    A[1919] = -0.135449735449735*G7_0 - 0.270899470899469*G7_1;
    A[1920] = 0.0;
    A[1921] = 0.0;
    A[1922] = 0.0;
    A[1923] = 0.0;
    A[1924] = 0.0;
    A[1925] = 0.0;
    A[1926] = 0.0;
    A[1927] = 0.0;
    A[1928] = 0.0;
    A[1929] = 0.0;
    A[1930] = 0.0;
    A[1931] = 0.0;
    A[1932] = 0.0;
    A[1933] = 0.0;
    A[1934] = 0.0;
    A[1935] = 0.00705467372134065*G6_0 + 0.00705467372134074*G6_1;
    A[1936] = -0.00705467372134029*G6_0;
    A[1937] = -0.00705467372134054*G6_1;
    A[1938] = -0.203174603174603*G6_0 - 0.112874779541446*G6_1;
    A[1939] = -0.0507936507936509*G6_0 - 0.186243386243386*G6_1;
    A[1940] = 0.0225749559082894*G6_0 + 0.0677248677248683*G6_1;
    A[1941] = -0.0677248677248689*G6_0 - 0.0451499118165792*G6_1;
    A[1942] = -0.0846560846560838*G6_0;
    A[1943] = -0.0225749559082894*G6_0 + 0.0451499118165775*G6_1;
    A[1944] = -0.0451499118165794*G6_0 - 0.0677248677248674*G6_1;
    A[1945] = 0.135449735449736*G6_0 + 0.186243386243387*G6_1;
    A[1946] = -0.0902998236331575*G6_0 + 0.112874779541445*G6_1;
    A[1947] = 0.270899470899473*G6_0 + 0.135449735449737*G6_1;
    A[1948] = 0.0;
    A[1949] = 0.135449735449735*G6_0 - 0.135449735449735*G6_1;
    A[1950] = 0.00705467372134065*G7_0 + 0.00705467372134074*G7_1;
    A[1951] = -0.00705467372134029*G7_0;
    A[1952] = -0.00705467372134054*G7_1;
    A[1953] = -0.203174603174603*G7_0 - 0.112874779541446*G7_1;
    A[1954] = -0.0507936507936509*G7_0 - 0.186243386243386*G7_1;
    A[1955] = 0.0225749559082894*G7_0 + 0.0677248677248683*G7_1;
    A[1956] = -0.0677248677248689*G7_0 - 0.0451499118165792*G7_1;
    A[1957] = -0.0846560846560838*G7_0;
    A[1958] = -0.0225749559082894*G7_0 + 0.0451499118165775*G7_1;
    A[1959] = -0.0451499118165794*G7_0 - 0.0677248677248674*G7_1;
    A[1960] = 0.135449735449736*G7_0 + 0.186243386243387*G7_1;
    A[1961] = -0.0902998236331575*G7_0 + 0.112874779541445*G7_1;
    A[1962] = 0.270899470899473*G7_0 + 0.135449735449737*G7_1;
    A[1963] = 0.0;
    A[1964] = 0.135449735449735*G7_0 - 0.135449735449735*G7_1;
    A[1965] = 0.0;
    A[1966] = 0.0;
    A[1967] = 0.0;
    A[1968] = 0.0;
    A[1969] = 0.0;
    A[1970] = 0.0;
    A[1971] = 0.0;
    A[1972] = 0.0;
    A[1973] = 0.0;
    A[1974] = 0.0;
    A[1975] = 0.0;
    A[1976] = 0.0;
    A[1977] = 0.0;
    A[1978] = 0.0;
    A[1979] = 0.0;
    A[1980] = 0.00705467372134039*G6_0 + 0.00705467372134069*G6_1;
    A[1981] = -0.00705467372134037*G6_0;
    A[1982] = -0.00705467372134003*G6_1;
    A[1983] = 0.0677248677248675*G6_0 + 0.0225749559082892*G6_1;
    A[1984] = -0.186243386243386*G6_0 - 0.05079365079365*G6_1;
    A[1985] = -0.112874779541446*G6_0 - 0.203174603174603*G6_1;
    A[1986] = -0.0677248677248677*G6_0 - 0.0451499118165788*G6_1;
    A[1987] = 0.186243386243386*G6_0 + 0.135449735449736*G6_1;
    A[1988] = 0.112874779541446*G6_0 - 0.0902998236331581*G6_1;
    A[1989] = -0.0451499118165784*G6_0 - 0.0677248677248674*G6_1;
    A[1990] = -0.0846560846560849*G6_1;
    A[1991] = 0.0451499118165785*G6_0 - 0.0225749559082902*G6_1;
    A[1992] = 0.135449735449736*G6_0 + 0.270899470899471*G6_1;
    A[1993] = -0.135449735449735*G6_0 + 0.135449735449737*G6_1;
    A[1994] = 0.0;
    A[1995] = 0.00705467372134039*G7_0 + 0.00705467372134069*G7_1;
    A[1996] = -0.00705467372134037*G7_0;
    A[1997] = -0.00705467372134003*G7_1;
    A[1998] = 0.0677248677248675*G7_0 + 0.0225749559082892*G7_1;
    A[1999] = -0.186243386243386*G7_0 - 0.05079365079365*G7_1;
    A[2000] = -0.112874779541446*G7_0 - 0.203174603174603*G7_1;
    A[2001] = -0.0677248677248677*G7_0 - 0.0451499118165788*G7_1;
    A[2002] = 0.186243386243386*G7_0 + 0.135449735449736*G7_1;
    A[2003] = 0.112874779541446*G7_0 - 0.0902998236331581*G7_1;
    A[2004] = -0.0451499118165784*G7_0 - 0.0677248677248674*G7_1;
    A[2005] = -0.0846560846560849*G7_1;
    A[2006] = 0.0451499118165785*G7_0 - 0.0225749559082902*G7_1;
    A[2007] = 0.135449735449736*G7_0 + 0.270899470899471*G7_1;
    A[2008] = -0.135449735449735*G7_0 + 0.135449735449737*G7_1;
    A[2009] = 0.0;
    A[2010] = 0.0;
    A[2011] = 0.0;
    A[2012] = 0.0;
    A[2013] = 0.0;
    A[2014] = 0.0;
    A[2015] = 0.0;
    A[2016] = 0.0;
    A[2017] = 0.0;
    A[2018] = 0.0;
    A[2019] = 0.0;
    A[2020] = 0.0;
    A[2021] = 0.0;
    A[2022] = 0.0;
    A[2023] = 0.0;
    A[2024] = 0.0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class ffc_form_52164074808682a61c0a422f4a828fb73a118312_form_0: public ufc::form
{
public:

  /// Constructor
  ffc_form_52164074808682a61c0a422f4a828fb73a118312_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_52164074808682a61c0a422f4a828fb73a118312_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "3d105efca949da7afb587090258c3c03e6d38ca3f540b0ec7d6f6b874c28eb85ddbe4aa0783e58a213c5f380826d3f5fe17056082868a0fc68ce10e0c2899ee4";
  }


  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 0;
  }

  /// Return original coefficient position for each coefficient (0 <= i < n)
  virtual std::size_t original_coefficient_position(std::size_t i) const
  {
    static const std::vector<std::size_t> position({});
    return position[i];
  }


  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2();
        break;
      }
    case 1:
      {
        return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_dofmap_2();
        break;
      }
    }
    
    return 0;
  }


  /// Return the number of cell domains
  virtual std::size_t max_cell_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t max_exterior_facet_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t max_interior_facet_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of vertex domains
  virtual std::size_t max_vertex_subdomain_id() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t max_custom_subdomain_id() const
  {
    return 0;
  }


  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any vertex integrals
  virtual bool has_vertex_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }


  /// Create a new cell integral on sub domain subdomain_id
  virtual ufc::cell_integral* create_cell_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain subdomain_id
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain subdomain_id
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new vertex integral on sub domain subdomain_id
  virtual ufc::vertex_integral* create_vertex_integral(std::size_t subdomain_id) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain subdomain_id
  virtual ufc::custom_integral* create_custom_integral(std::size_t subdomain_id) const
  {
    return 0;
  }


  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new ffc_form_52164074808682a61c0a422f4a828fb73a118312_cell_integral_0_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new vertex integral on everywhere else
  virtual ufc::vertex_integral* create_default_vertex_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

#endif
